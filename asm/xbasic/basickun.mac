; BASICKUN.MAC
;
; MSX BASIC KUN (version 2.1)
;
; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA
;
; Code Copyrighted by ASCII
; Source comments by Arjen Zeilemaker
;
; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders

	.Z80
        ASEG
	ORG	4000H

VDP.DR	EQU	0006H
VDP.DW	EQU	0007H
IDBYT2	EQU	002DH
WRTVDP	EQU	0047H
CHGMOD	EQU	005FH
CHGCLR	EQU	0062H
CLRSPR	EQU	0069H
CALPAT	EQU	0084H
CALATR	EQU	0087H
GSPSIZ	EQU	008AH
WRTPSG	EQU	0093H
CHSNS	EQU	009CH
CHGET	EQU	009FH
QINLIN	EQU	00B4H
BEEP	EQU	00C0H
CLS	EQU	00C3H
POSIT	EQU	00C6H
ERAFNK	EQU	00CCH
DSPFNK	EQU	00CFH
GTSTCK	EQU	00D5H
GTTRIG	EQU	00D8H
GTPAD	EQU	00DBH
GTPDL	EQU	00DEH
SCALXY	EQU	010EH
MAPXYC	EQU	0111H
READC	EQU	011DH
CALBAS	EQU	0159H
EXTROM	EQU	015FH

S.INIPLT	EQU	0141H
S.RSTPLT	EQU	0145H
S.GETPLT	EQU	0149H
S.SETPLT	EQU	014DH

M406F	EQU	406FH			; BASIC error
M57F1	EQU	57F1H			; PSET
M58C1	EQU	58C1H			; LINE boxfill
M58FC	EQU	58FCH			; LINE
M5912	EQU	5912H			; LINE box
M59E3	EQU	59E3H			; PAINT MSX1
M5B19	EQU	5B19H			; CIRCLE
M5EA4	EQU	5EA4H			; locate variable
M5F5D	EQU	5F5DH			; locate variable (search only)
M7810	EQU	7810H			; check ON <trap> GOTO

S266E	EQU	266EH			; PAINT MSX2 (subrom)


USRTAB	EQU	0F39AH
CSRY	EQU	0F3DCH
RG0SAV	EQU	0F3DFH
RG1SAV	EQU	0F3E0H
RG2SAV	EQU	0F3E1H
RG6SAV	EQU	0F3E5H
FORCLR	EQU	0F3E9H
BAKCLR	EQU	0F3EAH
BDRCLR	EQU	0F3EBH
ATRBYT	EQU	0F3F2H
LPTPOS	EQU	0F415H
PRTFLG	EQU	0F416H
CURLIN	EQU	0F41CH
BUF	EQU	0F55EH
TTYPOS	EQU	0F661H
VALTYP	EQU	0F663H
TXTTAB	EQU	0F676H
DATLIN	EQU	0F6A3H
SUBFLG	EQU	0F6A5H
SAVTXT	EQU	0F6AFH
SAVSTK	EQU	0F6B1H
STREND	EQU	0F6C6H
DATPTR	EQU	0F6C8H
DEFTBL	EQU	0F6CAH
SWPTMP	EQU	0F7BCH
FBUFFR	EQU	0F7C5H
DAC	EQU	0F7F6H
NULBUF	EQU	0F862H
DPPAGE	EQU	0FAF5H
ACPAGE	EQU	0FAF6H
MODE	EQU	0FAFCH
FNKFLG	EQU	0FBCEH
ONGSBF	EQU	0FBD8H
LINWRK	EQU	0FC18H
TRPTBL	EQU	0FC4CH
INTFLG	EQU	0FC9BH
JIFFY	EQU	0FC9EH
SCRMOD	EQU	0FCAFH
BRDATR	EQU	0FCB2H
GXPOS	EQU	0FCB3H
GYPOS	EQU	0FCB5H
GRPACX	EQU	0FCB7H
GRPACY	EQU	0FCB9H
PROCNM	EQU	0FD89H
RG8SAV	EQU	0FFE7H
RG11SAV	EQU	0FFEAH
RG23SAV	EQU	0FFF6H
RG25SAV	EQU	0FFFAH
RG26SAV	EQU	0FFFBH

        DEFB	"AB"
        DEFW	0
        DEFW	C4032
        DEFW	0
        DEFW	0
	DEFS	6,0

	DEFM	"BASIC'n ver 2.1 (C) 1992 by ASCII"
	DEFB	0

C4032:	EI
	LD	DE,I4047
	PUSH	HL
	LD	HL,PROCNM
	CALL	C4065			; check if recognized CALL statement
	POP	HL
	RET	C			; not recognized, quit with statement not recognized
	CALL	C4045			; start statement handler
	EI
	AND	A			; statement recognized, quit
	RET

;	  Subroutine start statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C4045:	PUSH	DE
	RET

I4047:	DEFB	"RUN"
	DEFB	0
	DEFW	C4149
	DEFB	"TURBO"
	DEFB	0FFH
	DEFB	"ON"
	DEFB	0
	DEFW	C4E88
	DEFB	"TURBO"
	DEFB	0FFH
	DEFB	"OFF"
	DEFB	0
	DEFW	C4EFF
	DEFB	0FFH
	
;	  Subroutine check if recognized CALL statement
;	     Inputs  HL = pointer to statement string, DE = statement table
;	     Outputs Cx set if statement not recognized, Cx reset if statement recognized, DE = statement handler (if statement recognized)

C4065:	PUSH	HL
	LD	A,(DE)
	INC	A			; end of statement table ?
	JR	Z,J4075			; yep, quit
	CALL	C4078			; check if this statement
	POP	HL
	JR	NZ,C4065		; nope, next statement
	EX	DE,HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; statement handler
	RET

J4075:	SCF				; statement not recognized
	POP	HL
	RET

;	  Subroutine check if this statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4078:	OR	A
	RET	Z
J407A:	LD	A,(DE)
	CP	(HL)
	INC	DE
	INC	HL
	JR	Z,C4078
	INC	A
	JR	NZ,J408D
	DEC	HL
J4084:	LD	A,(HL)
	CP	" "
	INC	HL
	JR	Z,J4084
	DEC	HL
	JR	J407A

J408D:	DEC	DE
J408E:	LD	A,(DE)
	AND	A
	INC	DE
	JR	NZ,J408E
	INC	DE
	INC	DE
	INC	A
	RET

I4097:	DEFW	J4E16			; unused token, BASIC error: syntax error
	DEFW	C4D0A			; END
	DEFW	C480E			; FOR
	DEFW	J48BF			; NEXT
	DEFW	J4DF2			; DATA
	DEFW	C4A6B			; INPUT
	DEFW	J452C			; DIM
	DEFW	J4519			; READ
	DEFW	C445F			; LET
	DEFW	C4696			; GOTO
	DEFW	C467C			; RUN
	DEFW	C45DD			; IF
	DEFW	C4A2A			; RESTORE
	DEFW	C4699			; GOSUB
	DEFW	C4689			; RETURN
	DEFW	C43BA			; REM
	DEFW	C4D13			; STOP
	DEFW	C4B34			; PRINT
	DEFW	J4E16			; CLEAR, BASIC error: syntax error
	DEFW	J4E16			; LIST, BASIC error: syntax error
	DEFW	J4E16			; NEW, BASIC error: syntax error
	DEFW	C46C0			; ON
	DEFW	C4CA6			; WAIT
	DEFW	C4CE3			; DEF
	DEFW	C4B9E			; POKE
	DEFW	J4E16			; CONT, BASIC error: syntax error
	DEFW	J4E16			; CSAVE, BASIC error: syntax error
	DEFW	J4E16			; CLOAD, BASIC error: syntax error
	DEFW	C4C1B			; OUT
	DEFW	C4B1D			; LPRINT
	DEFW	J4E16			; LLIST, BASIC error: syntax error
	DEFW	C6956			; CLS
	DEFW	J4E16			; WIDTH, BASIC error: syntax error
	DEFW	J4E16			; ELSE, BASIC error: syntax error
	DEFW	J4E16			; TRON, BASIC error: syntax error
	DEFW	J4E16			; TROFF, BASIC error: syntax error
	DEFW	C47DF			; SWAP
	DEFW	J4E16			; ERASE, BASIC error: syntax error
	DEFW	J4E16			; ERROR, BASIC error: syntax error
	DEFW	J4E16			; RESUME, BASIC error: syntax error
	DEFW	J4E16			; DELETE, BASIC error: syntax error
	DEFW	J4E16			; AUTO, BASIC error: syntax error
	DEFW	J4E16			; RENUM, BASIC error: syntax error
	DEFW	C479A			; DEFSTR
	DEFW	C4797			; DEFINT
	DEFW	C479D			; DEFSGN
	DEFW	C47A0			; DEFDBL
	DEFW	C66D5			; LINE
	DEFW	J4E16			; OPEN, BASIC error: syntax error
	DEFW	J4E16			; FIELD, BASIC error: syntax error
	DEFW	J4E16			; GET, BASIC error: syntax error
	DEFW	C6880			; PUT
	DEFW	J4E16			; CLOSE, BASIC error: syntax error
	DEFW	J4E16			; LOAD, BASIC error: syntax error
	DEFW	J4E16			; MERGE, BASIC error: syntax error
	DEFW	J4E16			; FILES, BASIC error: syntax error
	DEFW	J4E16			; LSET, BASIC error: syntax error
	DEFW	J4E16			; RSET, BASIC error: syntax error
	DEFW	J4E16			; SAVE, BASIC error: syntax error
	DEFW	J4E16			; LFILES, BASIC error: syntax error
	DEFW	C6853			; CIRCLE
	DEFW	C65A4			; COLOR
	DEFW	J4E16			; DRAW, BASIC error: syntax error
	DEFW	C6AC0			; PAINT
	DEFW	C4B95			; BEEP
	DEFW	J4E16			; PLAY, BASIC error: syntax error
	DEFW	C677A			; PSET
	DEFW	C677B			; PRESET
	DEFW	C4DA5			; SOUND
	DEFW	C6933			; SCREEN
	DEFW	C695C			; VPOKE
	DEFW	C4D22			; SPRITE
	DEFW	C6A81			; VDP
	DEFW	J4E16			; BASE, BASIC error: syntax error
	DEFW	C4E36			; CALL
	DEFW	C4DE6			; TIME
	DEFW	C4D34			; KEY
	DEFW	J4E16			; MAX, BASIC error: syntax error
	DEFW	J4E16			; MOTOR, BASIC error: syntax error
	DEFW	J4E16			; BLOAD, BASIC error: syntax error
	DEFW	J4E16			; BSAVE, BASIC error: syntax error
	DEFW	J4E16			; DSKO$, BASIC error: syntax error
	DEFW	C69A3			; SET
	DEFW	J4E16			; NAME, BASIC error: syntax error
	DEFW	J4E16			; KILL, BASIC error: syntax error
	DEFW	J4E16			; IPL, BASIC error: syntax error
	DEFW	C6B1D			; COPY
	DEFW	J4E16			; CMD, BASIC error: syntax error
	DEFW	C4DC7			; LOCATE

;	  Subroutine CALL RUN
;	     Inputs  ________________________
;	     Outputs ________________________

C4149:	LD	(SAVTXT),HL
	LD	DE,DEFTBL
	LD	B,26
	LD	A,8
J4153:	LD	(DE),A
	INC	DE
	DJNZ	J4153
	LD	HL,(TXTTAB)
	DEC	HL
	LD	(DATPTR),HL		; initialize DATA pointer
	INC	HL
	XOR	A			; not in turbo block

; start turbo block

J4160:	LD	(BUF+7),HL		; start of turbo block basic text
	LD	(BUF+5),A		; turbo flag
	LD	(SAVSTK),SP
	AND	A			; in turbo block ?
	JR	Z,J4171			; nope,
	LD	B,A
	XOR	A
	CPIR				; skip to end of line
J4171:	LD	BC,0			; number of BASIC lines = 0
J4174:	INC	BC
	LD	A,(HL)
	INC	HL
	PUSH	HL
	POP	IX
	LD	H,(HL)
	LD	L,A			; next line pointer
	OR	H			; end of program ?
	JR	Z,J4191			; yep,
	INC	IX
	INC	IX
	INC	IX			; skip line number
	CALL	C6032			; get BASIC character (skip spaces)
	CP	0CAH			; line start with CALL token ?
	JR	Z,J4190			; yep,
	CP	"_"			; line start with CALL character ?
	JR	NZ,J4174		; nope, next line

J4190:	INC	BC
J4191:	LD	L,C
	LD	H,B			; number of BASIC lines
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL			; *6
	LD	(BUF+19),HL		; size of line number list buffer
	EX	DE,HL
	LD	HL,0
	ADD	HL,SP			; current bottom of stack
	SBC	HL,DE
	LD	(BUF+17),HL		; start list of code pointer per line number
	LD	SP,HL			; allocate space on stack for line number list
	LD	(HL),0FFH
	INC	HL
	LD	(HL),0FFH
	DEC	HL			; end marker line number list
	DEC	H
	DEC	H
	DEC	HL
	DEC	HL
	DEC	HL
	DEC	HL
	LD	(HL),0
	LD	(BUF+21),HL		; start of variable list
	LD	(BUF+23),HL		; end of variable list
	XOR	A
	LD	(BUF+4),A		; no bytes in execution buffer
	LD	(BUF+6),A		; no traps defined
	LD	(BUF+12),A		; reset force float flag
	LD	(BUF+13),A		; reset NULBUF in use flag
	LD	(BUF+14),A		; next overflow check off
	LD	HL,(STREND)
	LD	(BUF+0),HL		; start of compiled basic program
	LD	(BUF+2),HL		; current compiled code pointer
	LD	IX,(BUF+7)		; start of turbo block basic text
	LD	A,(BUF+5)
	AND	A			; in turbo block ?
	JR	Z,J41F1			; nope, skip CALL TURBO ON parameter parsing
	LD	A,(IX+0)
	CP	":"			; next statement ?
	JR	Z,J420F			; yep, start compiling
	INC	IX
	AND	A			; end of line ?
	JR	Z,J41F1			; yep, check if end of program and start compiling
	CP	"("
	JP	NZ,J4E16		; BASIC error: syntax error
	CALL	C4E97			; parse CALL TURBO ON parameters
	JR	J4214

J41F1:	LD	A,(IX+0)
	OR	(IX+1)			; end of basic program ?
	JR	Z,J421A			; yep, stop compiling
	LD	(BUF+15),IX
	LD	L,(IX+2)
	LD	H,(IX+3)		; line number
	LD	(CURLIN),HL
	CALL	C42D9			; register code pointer of line number
	INC	IX
	INC	IX
	INC	IX
J420F:	INC	IX
	CALL	C4258			; compile statement
J4214:	JR	C,J420F			; end of statement, next statement
	INC	IX
	JR	J41F1			; next line

J421A:	LD	A,(BUF+5)
	AND	A			; in turbo block ?
	JR	Z,J422B			; nope,
	LD	HL,(BUF+15)
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	DEC	HL
	LD	(SAVTXT),HL
J422B:	CALL	C4D0A			; compile END statement
	CALL	C4387			; replace line number references by code pointers
	CALL	C648C			; update compiled BASIC variable address references
	LD	HL,(BUF+19)		; size of line number list buffer
	ADD	HL,SP
	LD	SP,HL			; release line number list on stack
	LD	HL,-2
	LD	(CURLIN),HL		; running compiled basic
	LD	HL,3579H		; y5
	LD	(SWPTMP+0),HL
	LD	HL,7531H		; 1u
	LD	(SWPTMP+2),HL
	LD	HL,MODE
	RES	4,(HL)			; 212 lines mode
	LD	HL,I4E28		; BASIC error: return without gosub
	PUSH	HL
	LD	HL,(BUF+0)
	JP	(HL)			; start compiled basic program

;	  Subroutine compile statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4258:	CALL	C6032			; get BASIC character (skip spaces)
	AND	A			; end of line ?
	RET	Z			; yep, quit
	CP	":"			; end of statement ?
	SCF
	RET	Z			; yep, quit
	PUSH	AF
	LD	A,(BUF+6)
	AND	A			; traps defined ?
	JR	Z,J4270			; nope, skip trap check handler
	CALL	C6058			; copy code block in execution buffer

	CALL	C6C27			; check for traps
	DEFW	0

J4270:	POP	AF
	INC	IX
	CP	"_"			; call statement ?
	JR	NZ,J427C		; nope,
	CALL	C4E36			; handle CALL statement
	JR	J42CC			; check for end of statement and quit

J427C:	AND	A			; statement/function token ?
	JP	M,J4285			; yep,
	CALL	C4464			; compile LET statement
	JR	J42CC			; check for end of statement and quit

J4285:	CP	0FFH			; function token ?
	JR	NZ,J42B8		; nope,
	LD	A,(IX+0)
	INC	IX
	LD	HL,J42CC
	PUSH	HL			; when quit, check for end of statement and quit
	CP	83H			; MID$ function token ?
	JP	Z,J61B6			; yep,
	CP	0A3H			; STRIG function token ?
	JP	Z,J4D2F			; yep,
	CP	85H			; INT function token ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	LD	A,"E"
	CALL	C604A
	LD	A,"R"
	CALL	C604A
	LD	A,0FFH
	CALL	C604A
	LD	A,94H
	CALL	C604A			; check for BASIC ERVAL
	JP	J4D1D

J42B8:	CP	0D9H			; valid statement token ?
	JP	NC,J4E16		; nope, BASIC error: syntax error
	ADD	A,A
	LD	L,A
	LD	H,0
	LD	BC,I4097
	ADD	HL,BC
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A			; statement handler
	CALL	C42D8			; invoke statement handler

;	  Subroutine check for end of statement and quit
;	     Inputs  ________________________
;	     Outputs ________________________

J42CC:	CALL	C6032			; get BASIC character (skip spaces)
	AND	A			; end of line ?
	RET	Z			; yep, quit
	CP	":"			; end of statement ?
	SCF
	RET	Z			; yep, quit
	JP	J4E16			; BASIC error: syntax error

;	  Subroutine invoke statement handler
;	     Inputs  HL = statement handler
;	     Outputs ________________________

C42D8:	JP	(HL)

;	  Subroutine register code pointer of line number
;	     Inputs  HL = linenumber
;	     Outputs ________________________

C42D9:	PUSH	IX
	LD	IX,(BUF+17)		; start list of code pointer per line number
J42DF:	LD	A,(IX+0)
	AND	(IX+1)
	INC	A			; end marker ?
	JR	Z,J42FB			; yep, create new entry
	LD	A,L
	CP	(IX+0)			; line number found ?
	JR	NZ,J42F4		; nope, next
	LD	A,H
	CP	(IX+1)			; line number found ?
	JR	Z,J4310			; yep, register code pointer of line number
J42F4:	LD	BC,6
	ADD	IX,BC
	JR	J42DF			; next entry

J42FB:	LD	(IX+0),L
	LD	(IX+1),H		; line number
	XOR	A
	LD	(IX+4),A
	LD	(IX+5),A		; code pointer of referenced line number = unknown
	LD	(IX+6),0FFH
	LD	(IX+7),0FFH		; new end marker
J4310:	LD	HL,(BUF+2)		; current compiled code pointer
	LD	(IX+2),L
	LD	(IX+3),H
	POP	IX
	RET

;	  Subroutine fetch code pointer of line number and generate address
;	     Inputs  HL = line number
;	     Outputs ________________________

C431C:	PUSH	IX
	LD	IX,(BUF+17)		; start list of code pointer per line number
J4322:	LD	A,(IX+0)
	AND	(IX+1)
	INC	A			; end marker ?
	JR	Z,J433E			; yep, create new entry
	LD	A,L
	CP	(IX+0)			; line number found ?
	JR	NZ,J4337		; nope, next entry
	LD	A,H
	CP	(IX+1)			; line number found ?
	JR	Z,J4360			; yep,
J4337:	LD	BC,6
	ADD	IX,BC
	JR	J4322			; next entry

J433E:	LD	(IX+0),L
	LD	(IX+1),H		; line number
	XOR	A
	LD	(IX+2),A
	LD	(IX+3),A		; code pointer of line number = unknown
	LD	HL,(BUF+2)		; current compiled code pointer
	LD	(IX+4),L
	LD	(IX+5),H		; code pointer of referenced line number
	LD	(IX+6),0FFH
	LD	(IX+7),0FFH		; new end marker
	LD	L,A
	LD	H,A			; code pointer of line number = unknown
	JR	J4381

J4360:	LD	A,(IX+2)
	OR	(IX+3)			; code pointer of line number unknown ?
	JR	Z,J4370			; yep,
	LD	L,(IX+2)
	LD	H,(IX+3)		; code pointer of line number
	JR	J4381

J4370:	LD	L,(IX+4)
	LD	H,(IX+5)		; code pointer of referenced line number
	PUSH	HL
	LD	HL,(BUF+2)		; current compiled code pointer
	LD	(IX+4),L
	LD	(IX+5),H		; update code pointer of referenced line number
	POP	HL
J4381:	CALL	C60AE			; put word in execution buffer
	POP	IX
	RET

;	  Subroutine replace line number references by code pointers
;	     Inputs  ________________________
;	     Outputs ________________________

C4387:	LD	IX,(BUF+17)		; start list of code pointer per line number
J438B:	LD	A,(IX+0)
	AND	(IX+1)
	INC	A			; end marker ?
	RET	Z			; yep, quit
	LD	E,(IX+2)
	LD	D,(IX+3)		; code pointer of line number
	LD	A,E
	OR	D			; code pointer unknown ?
	JP	Z,J4E19			; yep, BASIC error: undefined linenumber
	LD	L,(IX+4)
	LD	H,(IX+5)		; code pointer of referenced line number
	LD	A,L
	OR	H			; line number referenced ?
	JR	Z,J43B3			; nope,
J43A8:	LD	C,(HL)
	LD	(HL),E
	INC	HL
	LD	B,(HL)
	LD	(HL),D			; replace next referenced code pointer by code pointer of linenumber
	LD	L,C
	LD	H,B			; next referenced code pointer
	LD	A,L
	OR	H			; more replacements ?
	JR	NZ,J43A8		; yep, next
J43B3:	LD	BC,6
	ADD	IX,BC
	JR	J438B			; next entry

;	  Subroutine REM statement
;	     Inputs  ________________________
;	     Outputs ________________________

C43BA:	LD	A,(IX+0)
	CP	0E6H			; ' token ?
	JR	NZ,J43C3
	INC	IX			; yep, skip
J43C3:	CALL	C6032			; get BASIC character (skip spaces)
	CP	"#"			; basic compiler option ?
	JP	NZ,J4453		; nope,
	LD	A,(IX+1)
	CALL	C7E39			; to upper
	CP	"I"
	JR	NZ,J441F

; I -> inline

	INC	IX
J43D7:	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	PUSH	IX
	POP	DE
	CALL	C7E39			; to upper
	CP	"@"			; linenumber indicator ?
	JR	Z,J43F8			; yep,
	CP	"A"
	JR	C,J4405
	CP	"Z"+1
	JR	NC,J4405
	CALL	C6503			; fetch variable name
	LD	C,0			; generate address code
	CALL	C62E7			; create simple variable if needed, generate variable address code
	JR	J4412

J43F8:	INC	DE
	CALL	C7D18			; convert numeric string to float
	PUSH	DE
	CALL	C7901			; convert float to integer
	CALL	C431C			; fetch code pointer of line number and generate address
	JR	J4410

J4405:	CALL	C7D18			; convert numeric string to float
	PUSH	DE
	CALL	C7901			; convert float to integer
	LD	A,L
	CALL	C60B9			; put byte in execution buffer
J4410:	POP	IX
J4412:	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J43D7
	AND	A
	JP	NZ,J4E16		; BASIC error: syntax error
	JR	J4453

J441F:	CP	"C"
	JR	NZ,J4441

; C -> clip

	LD	A,(IX+2)
	CP	"+"
	LD	HL,0A6CBH		; RES 4,(HL)
	JR	Z,J4434
	CP	"-"
	JR	NZ,J4453
	LD	HL,0E6CBH		; SET 4,(HL)
J4434:	CALL	C6058			; copy code block in execution buffer

	LD	HL,MODE
	DEFW	0

	CALL	C60AE			; put word in execution buffer
	JR	J4453

J4441:	CP	"N"
	JR	NZ,J4453

; N -> next overflow check

	LD	A,(IX+2)
	CP	"+"
	JR	Z,J4450
	SUB	"-"
	JR	NZ,J4453
J4450:	LD	(BUF+14),A		; next overflow check
J4453:	LD	HL,(BUF+15)
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	DEC	HL
	PUSH	HL
	POP	IX
	RET

;	  Subroutine LET statement
;	     Inputs  ________________________
;	     Outputs ________________________

C445F:	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX

;	  Subroutine compile LET statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4464:	DEC	IX
	CALL	C5BF3			; fetch variable name or index variable name with index
	PUSH	AF
	CALL	C603C			; check for BASIC token =
	POP	AF
	INC	B
	BIT	5,A			; string variable ?
	JP	NZ,J44DF		; yep,
	BIT	6,A			; float variable ?
	JR	NZ,J449F		; yep,

; compile LET statement integer variable

	DJNZ	J4481

; B=0, integer constant (array with a constant index)

	PUSH	HL
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	POP	HL
	JR	C44B2			; put LD (xxxx),HL in execution buffer

J4481:	DJNZ	J448B

; B=1, variable

	PUSH	HL
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	POP	HL
	JP	C608B			; put LD (var),HL in execution buffer (AF retained)

; B>1, generated integer (array with a variable index)

J448B:	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C6058			; copy code block in execution buffer

	POP	DE
	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	DEFW	0

	RET

; compile LET statement float variable

J449F:	DJNZ	J44B7

; B=0, integer constant (array with a constant index)

	PUSH	HL
	CALL	C4FAE			; evaluate numeric expression, convert to float, generate code
	POP	HL
J44A6:	CALL	C6058			; copy code block in execution buffer

	LD	A,B
	DEFW	0

	LD	A,32H			; LD (xxxx),A
	CALL	C60AB			; put 3 bytes in execution buffer
	INC	HL

;	  Subroutine put LD (xxxx),HL in execution buffer
;	     Inputs  HL = xxxx
;	     Outputs ________________________

C44B2:	LD	A,22H			; LD (xxxx),HL
	JP	C60AB			; put 3 bytes in execution buffer

J44B7:	DJNZ	J44C9

; B=1, variable

	PUSH	HL
	CALL	C4FAE			; evaluate numeric expression, convert to float, generate code
	POP	HL

;	  Subroutine generate store in variable code
;	     Inputs  ________________________
;	     Outputs ________________________

C44BE:	CALL	C6058			; copy code block in execution buffer

	LD	A,B
	DEFW	0

	LD	C,2			; generate store code
	JP	C62E7			; create simple variable if needed, generate variable address code

; B>1, generated integer (array with a variable index)

J44C9:	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C4FAE			; evaluate numeric expression, convert to float, generate code
	CALL	C6058			; copy code block in execution buffer

	POP	DE
	EX	DE,HL
	LD	(HL),B
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	DEFW	0

	RET

; compile LET statement string variable

J44DF:	DJNZ	J44ED

; B=0, integer constant (array with a constant index)

	PUSH	HL
	CALL	C4FFE			; evaluate string expression
	POP	HL
J44E6:	LD	A,11H			; LD DE,xxxx
	CALL	C60AB			; put 3 bytes in execution buffer
	JR	J450D			; generate copy string code

J44ED:	DJNZ	J44FE

; B=1, variable

	PUSH	HL
	CALL	C4FFE			; evaluate string expression
	POP	HL
J44F4:	LD	A,11H			; LD DE,xxxx
	CALL	C60B9			; put byte in execution buffer
	CALL	C62E7			; create simple variable if needed, generate variable address code
	JR	J450D			; generate copy string code

; B>1, generated integer (array with a variable index)

J44FE:	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C4FFE			; evaluate string expression
	CALL	C6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

J450D:	CALL	C6058			; copy code block in execution buffer

	LD	C,(HL)			; size of string
	LD	B,0
	INC	BC			; include endmarker
	LDIR
	DEFW	0

	RET

;	  Subroutine READ statement
;	     Inputs  ________________________
;	     Outputs ________________________

J4519:	LD	HL,I75A1		; read numeric input handler
	LD	DE,I7560		; read string input handler
	CALL	C4A88			; invoke input handler
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	RET	NZ
	INC	IX
	JR	J4519

;	  Subroutine DIM statement
;	     Inputs  ________________________
;	     Outputs ________________________

J452C:	LD	A,(BUF+4)
	AND	A			; bytes in the execution buffer ?
	JP	NZ,J4E22		; yep, BASIC error: redemensioned array
	CALL	C6503			; fetch variable name
	LD	(BUF+25),HL		; save variable id
	CALL	C6044			; check for BASIC character "("
	LD	D,0			; 0 dimensions
J453E:	PUSH	DE
	CALL	C4FA9			; evaluate integer operand
	POP	DE
	LD	A,B
	AND	A			; constant integer ?
	JP	NZ,J4E0D		; nope, BASIC error: illegal function call
	INC	HL
	LD	A,L
	OR	H			; 65535 ?
	JP	Z,J4E1F			; yep, BASIC error: out of memory
	PUSH	HL			; save number of elements
	INC	D			; increase dimensions
	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	CP	")"			; end of dimension list ?
	JR	Z,J4560			; yep,
	CP	","
	JR	Z,J453E			; yep, next dimension
	JP	J4E16			; BASIC error: syntax error

J4560:	PUSH	DE
	LD	HL,(BUF+25)		; variable id
	LD	DE,(BUF+0)		; start of compiled basic program (= address of array)
	PUSH	DE
	CALL	C62FB			; create array variable if needed, generate variable address code
	POP	HL
	POP	BC
	LD	(HL),B			; register number of dimensions (+0)
J456F:	POP	DE			; restore number of elements
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; number of elements
	DJNZ	J456F			; next dimension
	LD	HL,(BUF+0)		; start of compiled basic program
	LD	B,(HL)			; number of dimensions
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; number of elements
	INC	HL
	DEC	B			; more dimensions ?
	JR	Z,J4591			; nope,
J4582:	LD	A,(HL)
	INC	HL
	PUSH	HL
	PUSH	BC
	LD	H,(HL)
	LD	L,A			; number of elements next dimension
	CALL	C7624			; multiply
	EX	DE,HL
	POP	BC
	POP	HL
	INC	HL
	DJNZ	J4582			; next dimension
J4591:	EX	DE,HL
	LD	A,(BUF+26)
	BIT	5,A			; array of strings ?
	JR	Z,J45A3			; nope,

; array of strings

	LD	A,H
	AND	A			; total elements > 255 ?
	JP	NZ,J4E1F		; yep, BASIC error: out of memory
	LD	H,L
	LD	L,0			; memory size of array = 256 * total elements
	JR	J45B1

J45A3:	LD	C,L
	LD	B,H
	ADD	HL,HL			; assume integer, 2 bytes per element
	JP	C,J4E1F			; overflow, BASIC error: out of memory
	BIT	6,A			; array of floats ?
	JR	Z,J45B1			; nope, assumption was ok
	ADD	HL,BC			; 3 bytes per element
	JP	C,J4E1F			; overflow, BASIC error: out of memory

J45B1:	LD	C,L
	LD	B,H			; memory size of array
	ADD	HL,DE			; + start address of array
	JP	C,J4E1F			; past 64KB top, BASIC error: out of memory
	PUSH	HL
	PUSH	DE
	LD	DE,(BUF+23)		; end of variable list
	SBC	HL,DE			; past variable list ?
	JP	NC,J4E1F		; yep, BASIC error: out of memory
	POP	DE
	POP	HL
	LD	(BUF+0),HL		; update start of compiled basic program
	LD	(BUF+2),HL		; update current compiled code pointer
J45CA:	XOR	A
	LD	(DE),A
	INC	DE
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J45CA		; clear array
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","			; more arrays ?
	RET	NZ			; nope, quit
	INC	IX
	JP	J452C

;	  Subroutine IF statement
;	     Inputs  ________________________
;	     Outputs ________________________

C45DD:	CALL	C4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C6032			; get BASIC character (skip spaces)
	CP	89H			; GOTO token ?
	JR	Z,J45EC			; yep,
	LD	A,0DAH			; THEN token
	CALL	C604A			; check for BASIC character
J45EC:	LD	A,B
	CP	2			; generated integer ?
	JR	Z,J45FA			; yep,
	CALL	C6058			; copy code block in execution buffer

	LD	A,B
	AND	A			; is float 0.0 ?
	DEFW	0

	JR	J4601

J45FA:	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	OR	H			; is integer 0 ?
	DEFW	0

J4601:	CALL	C6058			; copy code block in execution buffer

	JP	Z,0FFFFH		; jump over THEN code
	DEFW	0

	LD	HL,(BUF+2)		; current compiled code pointer
	PUSH	HL			; save start of THEN code
	CALL	C6032			; get BASIC character (skip spaces)
	CP	0DH			; linepointer token ?
	JR	Z,J4618			; yep,
	CP	0EH			; linenumber token ?
	JR	NZ,J4623		; nope,
J4618:	CALL	C4696			; compile GOTO statement
	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,J4626			; yep,
	JP	J4E16			; BASIC error: syntax error

J4623:	CALL	C4258			; compile statement
J4626:	AND	A			; end of line ?
	JR	Z,J4671			; yep,
	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	0A1H			; ELSE token ?
	JR	NZ,J4623		; nope, compile next statement
	INC	IX
	CALL	C6058			; copy code block in execution buffer

	JP	0FFFFH			; THEN code, jump over ELSE code
	DEFW	0

	LD	HL,(BUF+2)		; current compiled code pointer
	LD	E,L
	LD	D,H
	EX	(SP),HL			; save start of THEN code
	DEC	HL
	LD	(HL),D
	DEC	HL
	LD	(HL),E			; update start of THEN code
	CALL	C6032			; get BASIC character (skip spaces)
	CP	0DH			; linepointer token ?
	JR	Z,J4651			; yep,
	CP	0EH			; linenumber token ?
	JR	NZ,J465C		; nope,
J4651:	CALL	C4696			; compile GOTO statement
	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,J465F			; yep,
	JP	J4E16			; nope, BASIC error: syntax error

J465C:	CALL	C4258			; compile statement
J465F:	PUSH	IX
	POP	HL
	AND	A			; end of line ?
	JR	Z,J4671			; yep,
	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	0A1H			; ELSE token ?
	JR	NZ,J465C		; nope,
	PUSH	HL
	POP	IX
J4671:	POP	HL
	DEC	HL
	DEC	HL
	LD	DE,(BUF+2)		; current compiled code pointer
	LD	(HL),E
	INC	HL
	LD	(HL),D			; update start of THEN or ELSE code
	RET

;	  Subroutine RUN statement
;	     Inputs  ________________________
;	     Outputs ________________________

C467C:	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	NZ,C4696		; nope, compile GOTO statement
	LD	A,0C3H			; JP xxxx
	LD	HL,(BUF+0)		; start of compiled basic program
	JP	C60AB			; put 3 bytes in execution buffer

;	  Subroutine RETURN statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4689:	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	LD	A,0C9H			; RET
	JP	Z,C60B9			; yep, put byte in execution buffer and quit
	LD	A,0F1H			; POP AF (removes return address)
	CALL	C60B9			; put byte in execution buffer

;	  Subroutine GOTO statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4696:	LD	A,0C3H			; opcode JP
	DEFB	001H			; psuedo LD BC,xxxx (skip next instruction)

;	  Subroutine GOSUB statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4699:	LD	A,0CDH			; opcode CALL

;	  Subroutine generate code for statement with linenumber
;	     Inputs  A = Z80 opcode
;	     Outputs ________________________

C469B:	CALL	C60B9			; put byte in execution buffer
	CALL	C6032			; get BASIC character (skip spaces)
	LD	L,(IX+1)
	LD	H,(IX+2)
	INC	IX
	INC	IX
	INC	IX
	CP	0EH			; linenumber token ?
	JR	Z,J46BD			; yep,
	CP	0DH			; linepointer token ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	INC	HL
	INC	HL
	INC	HL			; skip next line pointer
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A			; linenumber
J46BD:	JP	C431C			; fetch code pointer of line number and generate address

;	  Subroutine ON statement
;	     Inputs  ________________________
;	     Outputs ________________________

C46C0:	CALL	C6032			; get BASIC character (skip spaces)
	PUSH	IX
	POP	HL
	LD	IX,M7810
	CALL	CALBAS			; check if trap identifier
	EI
	PUSH	HL
	POP	IX
	JP	NC,J4744		; yep, handle ON <trap> GOSUB
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	AND	A
	JP	Z,0FFFFH
	DEFW	0

	LD	HL,(BUF+2)		; current compiled code pointer
	PUSH	HL
	CALL	C6032			; get BASIC character (skip spaces)
	CP	89H			; GOTO token ?
	JR	NZ,J4701		; nope,
J46EB:	INC	IX
	CALL	C6058			; copy code block in execution buffer

	DEC	A
	DEFW	0

	LD	A,0CAH			; opcode JP Z,xxxx
	CALL	C469B			; generate code for statement with linenumber
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J46EB
	JR	J4733

J4701:	SUB	8DH			; GOSUB token ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	LD	L,A
	LD	H,A			; end marker
	PUSH	HL

J4709:	INC	IX
	CALL	C6058			; copy code block in execution buffer

	DEC	A
	JR	NZ,J4711+6
J4711:	DEFW	0

	CALL	C4699			; compile GOSUB statement
	CALL	C6058			; copy code block in execution buffer

	JP	0FFFFH
	DEFW	0

	LD	HL,(BUF+2)		; current compiled code pointer
	PUSH	HL
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","			; more gosub routines ?
	JR	Z,J4709			; yep,
J4729:	POP	HL
	LD	A,L
	OR	H			; end marker ?
	JR	Z,J4733			; yep,
	CALL	C4734			; replace address with current compiled code pointer
	JR	J4729

J4733:	POP	HL

;	  Subroutine replace address with current compiled code pointer
;	     Inputs  ________________________
;	     Outputs ________________________

C4734:	LD	BC,(BUF+2)		; current compiled code pointer
	DEC	HL
	LD	(HL),B
	DEC	HL
	LD	(HL),C
	RET

;	  Subroutine replace relative jump offset of saved relative jump
;	     Inputs  BC = after relative jump compiled code pointer
;	     Outputs ________________________

C473D:	LD	A,(BUF+2)		; current compiled code pointer (low byte)
	SUB	C			; after relative jump compiled code pointer (low byte)
	DEC	BC			; to relative jump offset
	LD	(BC),A			; update jump offset
	RET

;	  Subroutine ON <trap> GOSUB
;	     Inputs  ________________________
;	     Outputs ________________________

J4744:	INC	IX
	LD	A,8DH			; GOSUB token
	LD	(BUF+6),A		; traps defined
	CALL	C604A			; check for BASIC character
J474E:	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J478E
	LD	A,21H			; LD HL,xxxx
	CALL	C60B9			; put byte in execution buffer
	CALL	C6032			; get BASIC character (skip spaces)
	LD	L,(IX+1)
	LD	H,(IX+2)
	INC	IX
	INC	IX
	INC	IX
	CP	0EH			; linenumber token ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	LD	A,L
	OR	H
	JR	Z,J4779
	PUSH	BC
	CALL	C431C			; fetch code pointer of line number and generate address
	POP	BC
	JR	J477C

J4779:	CALL	C60AE			; put word in execution buffer
J477C:	LD	HL,TRPTBL+1
	LD	E,B
	LD	D,0			; trap number
	ADD	HL,DE
	ADD	HL,DE
	ADD	HL,DE			; *3
	CALL	C44B2			; put LD (xxxx),HL in execution buffer
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	RET	NZ
J478E:	INC	IX
	INC	B
	DEC	C
	JR	NZ,J474E
	JP	J4E16			; BASIC error: syntax error

;	  Subroutine DEFINT
;	     Inputs  ________________________
;	     Outputs ________________________

C4797:	LD	E,2			; integer type
	DEFB	001H

;	  Subroutine DEFSTR
;	     Inputs  ________________________
;	     Outputs ________________________

C479A:	LD	E,3			; string type
	DEFB	001H

;	  Subroutine DEFSGN
;	     Inputs  ________________________
;	     Outputs ________________________

C479D:	LD	E,4			; single type
	DEFB	001H

;	  Subroutine DEFDBL
;	     Inputs  ________________________
;	     Outputs ________________________

C47A0:	LD	E,8			; double type
J47A2:	CALL	C47D1			; get and check variable letter for default type definition
	LD	C,A			; save start offset
	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	0F2H			; - token ?
	JR	NZ,J47B6		; nope, use start offset as end offset
	INC	IX
	CALL	C47D1			; get and check variable letter for default type definition
	INC	IX
J47B6:	LD	A,B			; end offset
	SUB	C			; - start offset : calculate range
	JP	C,J4E16			; end smaller then start, BASIC error: syntax error
	INC	A			; number of entries
	LD	HL,DEFTBL
	LD	B,0
	ADD	HL,BC			; start in DEFTBL
J47C2:	LD	(HL),E			; change default type
	INC	HL
	DEC	A
	JR	NZ,J47C2		; next entry
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","			; more definitions ?
	RET	NZ			; nope, quit
	INC	IX
	JR	J47A2			; next definition

;	  Subroutine get and check variable letter for default type definition
;	     Inputs  ________________________
;	     Outputs A = B = offset

C47D1:	CALL	C6032			; get BASIC character (skip spaces)
	SUB	'A'
	LD	B,A
	JR	C,J47DC
	CP	'Z'-'A'+1
	RET	C
J47DC:	JP	J4E16			; BASIC error: syntax error

;	  Subroutine SWAP statement
;	     Inputs  ________________________
;	     Outputs ________________________

C47DF:	CALL	C5BDE
	PUSH	AF
	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C6040			; check for BASIC character ","
	CALL	C5BDE
	CALL	C6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

	POP	BC
	CP	B			; variables of the same type ?
	JP	NZ,J4E10		; nope, BASIC error: type mismatch
	LD	HL,I6BFB		; swap string
	BIT	5,A			; string variable ?
	JR	NZ,J480B		; yep,
	LD	HL,I6BFF		; swap float
	BIT	6,A			; float variable ?
	JR	NZ,J480B		; yep,
	LD	HL,I6BF7		; swap integer
J480B:	JP	C4DA0			; generate CALL xxxx (xxxx in HL)

;	  Subroutine FOR statement
;	     Inputs  ________________________
;	     Outputs ________________________

C480E:	CALL	C6503			; fetch variable name
	CALL	C603C			; check for BASIC token =
	PUSH	HL
	BIT	6,H			; float variable ?
	JP	NZ,J487F		; yep,

; FOR with integer loop variable

	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	POP	HL
	PUSH	HL
	CALL	C608B			; put LD (var),HL in execution buffer (AF retained)
	LD	A,0D9H			; TO token
	CALL	C604A			; check for BASIC character
	CALL	C4FE9			; evaluate numeric expression, convert to integer, generate code
	EX	DE,HL
	POP	HL
	INC	B
	DJNZ	J483B

; B=0 (FOR end value is integer constant)

	PUSH	DE
	LD	D,B
	LD	E,B			; constant end value, assume step value is constant (DE=0)
	CALL	C6301			; create FOR variable (end value and step value flags) if needed, generate variable address code
	POP	DE
	CALL	C6305			; create FOR variable (constant end value) if needed, generate variable address code
	JR	J4849

; B>0 (FOR end value is variable)

J483B:	LD	DE,2*256+0		; variable end value, assume step value is constant (DE=512)
	CALL	C6301			; create FOR variable (end value and step value flags) if needed, generate variable address code
	LD	A,22H			; LD (xxxx),HL
	CALL	C60B9			; put byte in execution buffer
	CALL	C62EB			; create FOR variable (variable end value) if needed, generate variable address code

J4849:	CALL	C6032			; get BASIC character (skip spaces)
	CP	0DCH			; STEP token ?
	JR	Z,J4858			; yep,
	LD	DE,1			; use step value 1
	CALL	C630B			; create FOR variable (constant step value) if needed, generate variable address code
	JR	J4878

J4858:	INC	IX
	PUSH	HL
	CALL	C4FE9			; evaluate numeric expression, convert to integer, generate code
	EX	DE,HL
	POP	HL
	INC	B
	DJNZ	J4868

; B=0 (STEP value is integer constant)

	CALL	C630B			; create FOR variable (constant step value) if needed, generate variable address code
	JR	J4878			; create FOR variable (code pointer start FOR) and quit

; B>0 (STEP value is variable)

J4868:	CALL	C643F			; fetch address FOR variable (end value and step value flags)
	LD	E,2			; change step value variable
	CALL	C6301			; create FOR variable (end value and step value flags) if needed, generate variable address code
	LD	A,22H			; LD (xxxx),HL
	CALL	C60B9			; put byte in execution buffer
J4875:	CALL	C62F1			; create FOR variable (variable step value) if needed, generate variable address code

J4878:	LD	DE,(BUF+2)		; current compiled code pointer
	JP	J6313			; create FOR variable (code pointer start FOR) if needed, generate variable address code

; FOR with float loop variable

J487F:	CALL	C4FAE			; evaluate numeric expression, convert to float, generate code
	POP	HL
	PUSH	HL
	CALL	C44BE			; generate store in variable code
	LD	A,0D9H			; TO token
	CALL	C604A			; check for BASIC character
	CALL	C4FAE			; evaluate numeric expression, convert to float, generate code
	CALL	C6058			; copy code block in execution buffer

	LD	A,B
	DEFW	0

	POP	HL
	PUSH	HL
	LD	C,2			; generate store code
	CALL	C62EB			; create FOR variable (variable end value) if needed, generate variable address code
	CALL	C6032			; get BASIC character (skip spaces)
	CP	0DCH			; STEP token ?
	JR	NZ,J48B0		; nope,
	INC	IX
	CALL	C4FAE			; evaluate numeric expression, convert to float, generate code
	CALL	C6058			; copy code block in execution buffer

	LD	A,B
	DEFW	0

	JR	J48BA

J48B0:	CALL	C6058			; copy code block in execution buffer

	LD	A,81H
	LD	HL,0
	DEFW	0

J48BA:	POP	HL
	LD	C,2			; generate store code
	JR	J4875

;	  Subroutine NEXT statement
;	     Inputs  ________________________
;	     Outputs ________________________

J48BF:	CALL	C6503			; fetch variable name
	BIT	6,H			; float variable ?
	JP	NZ,J49DB		; yep,

; NEXT with integer loop variable

	CALL	C6086			; put LD HL,(var) in execution buffer
	CALL	C643F			; fetch address FOR variable (end value and step value flags)
	LD	A,E
	AND	A			; step value variable ?
	JR	NZ,J491E		; yep, use different code

; NEXT with integer loop variable, step value is constant

	CALL	C6449			; fetch address FOR variable (constant step value)
	LD	A,(BUF+14)
	AND	A			; next overflow check enabled ?
	JR	NZ,J48FD		; yep, can not use INC/DEC approach
	OR	D			; step > 255 or negative ?
	JR	NZ,J48E2		; yep, can not use INC approach
	LD	A,E			; low byte step
	LD	C,23H			; INC HL
	JR	J48EA

J48E2:	INC	A			; step > -255
	JR	NZ,J48FD		; yep, can not use DEC approach
	LD	A,E
	NEG				; change sign step
	LD	C,2BH			; DEC HL
J48EA:	CP	5			; step value less then 5 ?
	JR	NC,J48FD		; nope, use ADD approach
	AND	A			; step value is zero ?
	JR	Z,J48F8			; yep, skip INC/DEC generation
	LD	B,A			; step value
	LD	A,C			; step opcode
J48F3:	CALL	C60B9			; put byte in execution buffer
	DJNZ	J48F3
J48F8:	LD	BC,0			; do not adjust HL=HL+DE code
	JR	J4905

J48FD:	EX	DE,HL			; step value in HL
	CALL	C6079			; put LD DE,xxxx in execution buffer
	EX	DE,HL
	CALL	C4951			; generate HL=HL+DE code

J4905:	PUSH	BC			; save adjust HL=HL+DE compiled code pointer
	CALL	C608B			; put LD (var),HL in execution buffer (AF retained)
	BIT	7,D			; flag for positive or negative step value
	CALL	C4971			; generate FOR end value check

J490E:	POP	HL			; restore adjust HL=HL+DE compiled code pointer
	LD	A,L
	OR	H			; adjust HL=HL+DE code ?
	CALL	NZ,C4734		; yep, replace address with current compiled code pointer
J4914:	CALL	C6032			; get BASIC character (skip spaces)
	CP	","			; more loop variables ?
	RET	NZ			; nope, quit
	INC	IX
	JR	J48BF			; next loop

; NEXT with integer loop variable, step value is variable

J491E:	PUSH	HL
	LD	HL,5BEDH		; LD DE,(xxxx)
	CALL	C60AE			; put word in execution buffer
	POP	HL
	CALL	C62F1			; create FOR variable (variable step value) if needed, generate variable address code
	CALL	C4951			; generate HL=HL+DE code
	PUSH	BC			; save adjust HL=HL+DE compiled code pointer
	CALL	C608B			; put LD (var),HL in execution buffer (AF retained)
	CALL	C6058			; copy code block in execution buffer

	BIT	7,D			; negative step value ?
J4935:	JR	NZ,J4935		; nope,
	DEFW	0

	XOR	A			; flag postive step value
	CALL	C4971			; generate FOR end value check
	CALL	C6058			; copy code block in execution buffer

J4940:	JR	J4940			;
	DEFW	0

	CALL	C473D			; replace relative jump offset of saved relative jump
	OR	01H			; flag negative step value
	CALL	C4971			; generate FOR end value check
	CALL	C473D			; replace relative jump offset of saved relative jump
	JR	J490E			; finish next

;	  Subroutine generate HL=HL+DE code
;	     Inputs  ________________________
;	     Outputs BC = compiled code pointer after HL=HL+DE code (if code need to be adjusted)

C4951:	LD	A,(BUF+14)
	AND	A			; next overflow check enabled ?
	JR	NZ,J4961		; yep,
	CALL	C6058			; copy code block in execution buffer

	ADD	HL,DE
	DEFW	0

	LD	BC,0			; no need to adjust HL=HL+DE code
	RET

J4961:	CALL	C6058			; copy code block in execution buffer

	AND	A
	ADC	HL,DE
J4967:	JP	PE,J4967
	DEFW	0

	LD	BC,(BUF+2)		; current compiled code pointer
	RET

;	  Subroutine generate FOR end value check
;	     Inputs  Zx set = generate for positive step value, Zx reset = generate for negative step value, 
;	     Outputs BC = compiled code pointer start of ? code

C4971:	LD	BC,(BUF+2)		; current compiled code pointer
	PUSH	BC
	CALL	C6058			; copy code block in execution buffer

	LD	A,H
	XOR	80H
	LD	H,A			; change sign
	DEFW	0

	PUSH	AF			; save step value sign
	LD	A,0EBH			; opcode EX DE,HL
	CALL	Z,C60B9			; postive step value, put byte in execution buffer
	CALL	C643F			; fetch address FOR variable (end value and step value flags)
	LD	A,D
	AND	A			; end value is a constant ?
	JR	NZ,J499E		; nope, generate code for variable end value

; end value is a constant

	CALL	C6443			; fetch address FOR variable (constant end value)
	EX	DE,HL
	LD	A,H
	XOR	80H
	LD	H,A			; change sign
	POP	AF			; restore step value sign
	CALL	Z,C607E			; postive step value, put LD HL,xxxx in execution buffer
	CALL	NZ,C6079		; negative step value, put LD DE,xxxx in execution buffer
	EX	DE,HL
	JR	J49C8

; end value is variable

J499E:	POP	AF			; restore step value sign
	JR	NZ,J49B4		; negative step value,

; end value is variable and step value is positive

	LD	A,2AH			; LD HL,(xxxx)
	CALL	C60B9			; put byte in execution buffer
	CALL	C62EB			; create FOR variable (variable end value) if needed, generate variable address code
	CALL	C6058			; copy code block in execution buffer

	LD	A,H
	XOR	80H
	LD	H,A			; change sign
	DEFW	0

	JR	J49C8

; end value is variable and step value is negative

J49B4:	PUSH	HL
	LD	HL,5BEDH		; LD DE,(xxxx)
	CALL	C60AE			; put word in execution buffer
	POP	HL
	CALL	C62EB			; create FOR variable (variable end value) if needed, generate variable address code
	CALL	C6058			; copy code block in execution buffer

	LD	A,D
	XOR	80H
	LD	D,A			; change sign
	DEFW	0

J49C8:	CALL	C6058			; copy code block in execution buffer

	SBC	HL,DE
	DEFW	0

	CALL	C6451			; fetch address FOR variable (code pointer start FOR)
	EX	DE,HL
	LD	A,0D2H			; JP NC,xxxx
	CALL	C60AB			; put 3 bytes in execution buffer
	EX	DE,HL
	POP	BC
	RET

; NEXT with float loop variable

J49DB:	LD	C,0AH			; generate fetch code
	CALL	C62E7			; create simple variable if needed, generate variable address code
	CALL	C6058			; copy code block in execution buffer

	LD	C,A
	EX	DE,HL
	DEFW	0

	LD	C,0AH			; generate fetch code
	CALL	C62F1			; create FOR variable (variable step value) if needed, generate variable address code
	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	LD	B,A
	CALL	C76D7			; add floats
	DEFW	0

	CALL	C44BE			; generate store in variable code
	CALL	C6058			; copy code block in execution buffer

	LD	C,B
	EX	DE,HL
	DEFW	0

	LD	C,0AH			; generate fetch code
	CALL	C62EB			; create FOR variable (variable end value) if needed, generate variable address code
	CALL	C6058			; copy code block in execution buffer

	LD	B,A
	CALL	C7966			; compare floats
	POP	HL
	DEFW	0

	CALL	C6451			; fetch address FOR variable (code pointer start FOR)
	EX	DE,HL
	LD	A,0CAH			; JP Z,xxxx
	CALL	C60AB			; put 3 bytes in execution buffer
	CALL	C6058			; copy code block in execution buffer

	BIT	7,H
	JR	Z,J4A20
	CCF
J4A20:	DEFW	0

	LD	A,0D2H			; JP NC,xxxx
	CALL	C60AB			; put 3 bytes in execution buffer
	JP	J4914

;	  Subroutine RESTORE statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4A2A:	LD	HL,(TXTTAB)
	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,J4A5E			; yep, use start of tokenized basic text
	CP	0EH			; linenumber token ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	LD	C,(IX+1)
	LD	B,(IX+2)		; linenumber
	INC	IX
	INC	IX
	INC	IX			; update pointer
	LD	HL,(TXTTAB)		; start of tokenized basic text
J4A46:	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; next line pointer
	LD	A,E
	OR	D			; end of program ?
	JP	Z,J4E19			; yep, BASIC error: undefined linenumber
	INC	HL
	LD	A,(HL)
	CP	C			; line number found ?
	JR	NZ,J4A58		; nope, next line
	INC	HL
	LD	A,(HL)
	CP	B			; line number found ?
	JR	Z,J4A5B			; yep,
J4A58:	EX	DE,HL
	JR	J4A46			; next line

J4A5B:	DEC	HL
	DEC	HL
	DEC	HL
J4A5E:	DEC	HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	CALL	C6058			; copy code block in execution buffer

	LD	(DATPTR),HL
	DEFW	0

	RET

;	  Subroutine INPUT statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4A6B:	CALL	C6032			; get BASIC character (skip spaces)
	CP	'"'			; input text parameter ?
	LD	HL,J751A		; get numeric input handler
	LD	DE,I7546		; get string input handler
	JR	NZ,C4A88		; nope, invoke input handler for plain input
	INC	IX
	CALL	C583B			; generate code for constant string
	LD	A,";"
	CALL	C604A			; check for BASIC character
	LD	HL,I7517		; print string and get numeric input handler
	LD	DE,I7543		; print string and get string input handler

;	  Subroutine invoke input handler
;	     Inputs  HL = numeric input handler, DE = string input handler
;	     Outputs ________________________

C4A88:	PUSH	HL
	PUSH	DE
	PUSH	IX
	CALL	C6503			; fetch variable name
	POP	IX
	BIT	5,H			; string variable ?
	JR	Z,J4ABE			; nope,

; INPUT with string variable

	POP	HL			; HL = string input handler
	POP	AF
	CALL	C4DA0			; generate CALL xxxx (xxxx in HL)
	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C5BF3			; fetch variable name or index variable name with index
	INC	B
	DJNZ	J4AAC

; B=0, integer constant (array with a constant index)

	CALL	C60D7			; remove byte from execution buffer (PUSH HL)
	JP	J44E6			; generate copy string code

J4AAC:	DJNZ	J4AB4

; B=1, variable

	CALL	C60D7			; remove byte from execution buffer (PUSH HL)
	JP	J44F4			; generate copy string to variable code

; B>1, generated integer (array with a variable index)

J4AB4:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	POP	HL
	DEFW	0

	JP	J450D			; generate copy string code

; INPUT with numeric variable

J4ABE:	POP	AF
	EX	(SP),HL			; HL = numeric input handler
	CALL	C4DA0			; generate CALL xxxx (xxxx in HL)
	POP	HL
	BIT	6,H			; float variable ?
	JR	NZ,J4AEF		; yep,

; INPUT with integer variable

	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	PUSH	HL
	DEFW	0

	CALL	C5BF3			; fetch variable name or index variable name with index
	INC	B
	DJNZ	J4ADD

; B=0, integer constant (array with a constant index)

	CALL	C60D7			; remove byte from execution buffer (PUSH HL)
	JP	C44B2			; put LD (xxxx),HL in execution buffer

J4ADD:	DJNZ	J4AE5

; B=1, variable

	CALL	C60D7			; remove byte from execution buffer (PUSH HL)
	JP	C608B			; put LD (var),HL in execution buffer (AF retained)

; B>1, generated integer (array with a variable index)

J4AE5:	CALL	C6058			; copy code block in execution buffer

	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	DEFW	0

	RET

; INPUT with float variable

J4AEF:	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	PUSH	BC
	DEFW	0

	CALL	C5BF3			; fetch variable name or index variable name with index
	INC	B
	DJNZ	J4B05

; B=0, integer constant (array with a constant index)

	CALL	C60D7			; remove byte from execution buffer (PUSH BC)
	CALL	C60D7			; remove byte from execution buffer (PUSH HL)
	JP	J44A6

J4B05:	DJNZ	J4B10

; B=1, variable

	CALL	C60D7			; remove byte from execution buffer (PUSH BC)
	CALL	C60D7			; remove byte from execution buffer (PUSH HL)
	JP	C44BE			; generate store in variable code

; B>1, generated integer (array with a variable index)

J4B10:	CALL	C6058			; copy code block in execution buffer

	POP	BC
	POP	DE
	LD	(HL),B
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	DEFW	0

	RET

;	  Subroutine LPRINT statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4B1D:	CALL	C6058			; copy code block in execution buffer

	LD	A,1
	LD	(PRTFLG),A
	DEFW	0

	CALL	C4B34			; generate PRINT statement code
	CALL	C6058			; copy code block in execution buffer

	XOR	A
	LD	(PRTFLG),A
	DEFW	0

	RET

;	  Subroutine PRINT statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4B34:	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,J4B5B			; yep, print new line and quit
J4B39:	CALL	C4B64			; print expression
	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,J4B5B			; yep, print new line and quit
	CP	","			; more arguments with tab seperation ?
	JR	NZ,J4B4F		; nope,
	CALL	C6058			; copy code block in execution buffer

	CALL	C74F3			; print tab
	DEFW	0

	JR	J4B53

J4B4F:	CP	";"			; more arguments with no seperation ?
	JR	NZ,J4B55		; nope,
J4B53:	INC	IX
J4B55:	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	NZ,J4B39		; nope, next
	RET

J4B5B:	CALL	C6058			; copy code block in execution buffer

	CALL	C74F7			; print new line
	DEFW	0

	RET

;	  Subroutine print expression
;	     Inputs  ________________________
;	     Outputs ________________________

C4B64:	CALL	C5012			; evaluate expression
	INC	B
	DJNZ	J4B6F

; B=0 (expression is a integer constant)

	CALL	C607E			; put LD HL,xxxx in execution buffer
	JR	J4B78

J4B6F:	DJNZ	J4B76

; B=1 (expression is a variable)

	CALL	C6086			; put LD HL,(var) in execution buffer
	JR	J4B78

J4B76:	DJNZ	J4B81

; B=2 (expression is a generated integer)

J4B78:	CALL	C6058			; copy code block in execution buffer

	CALL	C7508			; print integer
	DEFW	0

	RET

J4B81:	DJNZ	J4B8C

; B=3 (expression is a generated float)

	CALL	C6058			; copy code block in execution buffer

	CALL	C750D			; print float
	DEFW	0

	RET


; B=4 (expression is a generated string)

J4B8C:	CALL	C6058			; copy code block in execution buffer

	CALL	C74FE			; print string
	DEFW	0

	RET

;	  Subroutine BEEP
;	     Inputs  ________________________
;	     Outputs ________________________

C4B95:	CALL	C6058			; copy code block in execution buffer

	CALL	BEEP
	DEFW	0

	RET

;	  Subroutine POKE statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4B9E:	CALL	C4FA9			; evaluate integer operand
	CALL	C6040			; check for BASIC character ","
	DEC	IX
	LD	DE,C4FA9		; operand2 handler = evaluate integer operand
	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type
	
	DEFW	C4BCD			; integer constant, integer constant
	DEFW	C4BD2			; integer constant, variable
	DEFW	C4BD7			; integer constant, generated integer
	DEFW	C4BE3			; variable, integer constant
	DEFW	C4BEA			; variable, variable
	DEFW	C4BF1			; variable, generated integer
	DEFW	C4C02			; generated integer, integer constant
	DEFW	C4C08			; generated integer, variable
	DEFW	C4C12			; generated integer, generated integer
	DEFW	0			; integer constant, generated float
	DEFW	0			; variable, generated float
	DEFW	0			; generated integer, generated float
	DEFW	0			; generated float, integer constant
	DEFW	0			; generated float, variable
	DEFW	0			; generated float, generated integer
	DEFW	0			; generated float, generated float

	RET

;	  Subroutine poke, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C4BCD:	CALL	C4F5A			; generate LD A,constant code
	JR	J4BDD

;	  Subroutine poke, integer constant, integer variable
;	     Inputs  ________________________
;	     Outputs ________________________

C4BD2:	CALL	C4F75			; generate LD A,(variable) code
	JR	J4BDD

;	  Subroutine poke, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C4BD7:	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

J4BDD:	EX	DE,HL
	LD	A,32H			; LD (xxxx),A
	JP	C60AB			; put 3 bytes in execution buffer

;	  Subroutine poke, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C4BE3:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C4C02

;	  Subroutine poke, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C4BEA:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C4C08

;	  Subroutine poke, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C4BF1:	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	CALL	C6058			; copy code block in execution buffer

	LD	(HL),A
	DEFW	0

	RET

;	  Subroutine poke, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C4C02:	LD	H,L
	LD	L,36H			; LD (HL),xx
	JP	C60AE			; put word in execution buffer

;	  Subroutine poke, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C4C08:	CALL	C4F75			; generate LD A,(variable) code
	CALL	C6058			; copy code block in execution buffer

	LD	(HL),A
	DEFW	0

	RET

;	  Subroutine poke, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C4C12:	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	POP	HL
	LD	(HL),A
	DEFW	0

	RET

;	  Subroutine OUT statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4C1B:	CALL	C4FA9			; evaluate integer operand
	CALL	C6040			; check for BASIC character ","
	DEC	IX
	LD	DE,C4FA9		; operand2 handler = evaluate integer operand
	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C4C4A			; integer constant, integer constant
	DEFW	C4C4F			; integer constant, variable
	DEFW	C4C54			; integer constant, generated integer
	DEFW	C4C60			; variable, integer constant
	DEFW	C4C65			; variable, variable
	DEFW	C4C7A			; variable, generated integer
	DEFW	C4C8C			; generated integer, integer constant
	DEFW	C4C91			; generated integer, variable
	DEFW	C4C9D			; generated integer, generated integer
	DEFW	0			; integer constant, generated float
	DEFW	0			; variable, generated float
	DEFW	0			; generated integer, generated float
	DEFW	0			; generated float, integer constant
	DEFW	0			; generated float, variable
	DEFW	0			; generated float, generated integer
	DEFW	0			; generated float, generated float

	RET

;	  Subroutine out, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C4C4A:	CALL	C4F5A			; generate LD A,constant code
	JR	J4C5A

;	  Subroutine out, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C4C4F:	CALL	C4F75			; generate LD A,(variable) code
	JR	J4C5A

;	  Subroutine out, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C4C54:	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

J4C5A:	LD	H,E
	LD	L,0D3H			; OUT (xx),A
	JP	C60AE			; put word in execution buffer

;	  Subroutine out, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C4C60:	CALL	C4F5A			; generate LD A,constant code
	JR	J4C68

;	  Subroutine out, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C4C65:	CALL	C4F75			; generate LD A,(variable) code
J4C68:	LD	HL,4BEDH		; LD BC,(xxxx)
	CALL	C60AE			; put word in execution buffer
	EX	DE,HL
	CALL	C62E7			; create simple variable if needed, generate variable address code
	CALL	C6058			; copy code block in execution buffer

	OUT	(C),A
	DEFW	0

	RET

;	  Subroutine out, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C4C7A:	LD	HL,4BEDH		; LD BC,(xxxx)
	CALL	C60AE			; put word in execution buffer
	EX	DE,HL
	CALL	C62E7			; create simple variable if needed, generate variable address code
	CALL	C6058			; copy code block in execution buffer

	OUT	(C),L
	DEFW	0

	RET

;	  Subroutine out, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C4C8C:	CALL	C4F5A			; generate LD A,constant code
	JR	J4C94

;	  Subroutine out, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C4C91:	CALL	C4F75			; generate LD A,(variable) code
J4C94:	CALL	C6058			; copy code block in execution buffer

	LD	C,L
	OUT	(C),A
	DEFW	0

	RET

;	  Subroutine out, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C4C9D:	CALL	C6058			; copy code block in execution buffer

	POP	BC
	OUT	(C),L
	DEFW	0

	RET

;	  Subroutine WAIT statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4CA6:	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C6040			; check for BASIC character ","
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J4CC9
	CALL	C6058			; copy code block in execution buffer

	LD	D,A
	POP	BC
J4CC1:	IN	A,(C)
	AND	D
	JR	Z,J4CC1
	DEFW	0

	RET

J4CC9:	INC	IX
	CALL	C6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	LD	H,A
	POP	DE
	POP	BC
J4CDA:	IN	A,(C)
	XOR	H
	AND	D
	JR	Z,J4CDA
	DEFW	0

	RET

;	  Subroutine DEF statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4CE3:	LD	A,0DDH			; USR token
	CALL	C604A			; check for BASIC character
	CALL	C6032			; get BASIC character (skip spaces)
	LD	C,0
	SUB	11H
	JR	C,J4CF8
	CP	0AH
	JR	NC,J4CF8
	LD	C,A
	INC	IX
J4CF8:	CALL	C603C			; check for BASIC token =
	PUSH	BC
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	POP	BC
	LD	B,0
	LD	HL,USRTAB
	ADD	HL,BC
	ADD	HL,BC
	JP	C44B2			; put LD (xxxx),HL in execution buffer

;	  Subroutine END statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4D0A:	CALL	C6058			; copy code block in execution buffer

	JP	J4DFA
	DEFW	0

	RET

;	  Subroutine STOP statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4D13:	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,C4D0A			; yep, compile END statement
	LD	HL,TRPTBL+10*3
	JR	J4D6A

;	  Subroutine INTERVAL statement
;	     Inputs  ________________________
;	     Outputs ________________________

J4D1D:	LD	HL,TRPTBL+17*3
	JR	J4D6A

;	  Subroutine SPRITE statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4D22:	CALL	C6032			; get BASIC character (skip spaces)
	CP	"$"
	JP	Z,J68FC
	LD	HL,TRPTBL+11*3
	JR	J4D6A

;	  Subroutine STRIG statement
;	     Inputs  ________________________
;	     Outputs ________________________

J4D2F:	LD	DE,TRPTBL+12*3
	JR	J4D58

;	  Subroutine KEY statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4D34:	CALL	C6032			; get BASIC character (skip spaces)
	CP	95H			; ON token ?
	JR	NZ,J4D46		; nope,
	INC	IX
	CALL	C6058			; copy code block in execution buffer

	CALL	DSPFNK
	DEFW	0

	RET

J4D46:	CP	0EBH			; OFF token ?
	JR	NZ,J4D55		; nope,
	INC	IX
	CALL	C6058			; copy code block in execution buffer

	CALL	ERAFNK
	DEFW	0

	RET

J4D55:	LD	DE,TRPTBL-3
J4D58:	PUSH	DE
	CALL	C6044			; check for BASIC character "("
	CALL	C4FA9			; evaluate integer operand
	CALL	C6048			; check for BASIC character ")"
	POP	DE
	INC	B
	DJNZ	J4D6F

; B=0 (integer constant)

	EX	DE,HL
	ADD	HL,DE
	ADD	HL,DE
	ADD	HL,DE			; FKEY*3
J4D6A:	CALL	C607E			; put LD HL,xxxx in execution buffer
	JR	J4D85

J4D6F:	DEC	B			; B=1 (variable) ?
	CALL	Z,C6086			; yep, put LD HL,(var) in execution buffer
	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	CALL	C6058			; copy code block in execution buffer

	ADD	HL,DE
	ADD	HL,DE
	ADD	HL,DE			; FKEY*3
	DEFW	0

J4D85:	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	CP	95H			; ON token ?
	LD	HL,I6C8B		; enable trap handler
	JR	Z,C4DA0
	CP	0EBH			; OFF token ?
	LD	HL,I6C9E		; disable trap handler
	JR	Z,C4DA0
	CP	90H			; STOP token ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	LD	HL,C6CA7		; pause trap handler

;	  Subroutine generate CALL xxxx (xxxx in HL)
;	     Inputs  ________________________
;	     Outputs ________________________

C4DA0:	LD	A,0CDH			; CALL xxxx
	JP	C60AB			; put 3 bytes in execution buffer

;	  Subroutine SOUND statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4DA5:	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6040			; check for BASIC character ","
	CALL	C6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	LD	E,A
	POP	AF
	CP	7
	JR	NZ,J4DC1
	RES	6,E
	SET	7,E
J4DC1:	CALL	WRTPSG
	DEFW	0

	RET

;	  Subroutine LOCATE statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4DC7:	CALL	C6032			; get BASIC character (skip spaces)
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C6040			; check for BASIC character ","
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	POP	HL
	LD	L,A
	INC	L
	INC	H
	CALL	POSIT
	DEFW	0

	RET

;	  Subroutine TIME statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4DE6:	CALL	C603C			; check for BASIC token =
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	LD	HL,JIFFY
	JP	C44B2			; put LD (xxxx),HL in execution buffer

;	  Subroutine DATA statement
;	     Inputs  ________________________
;	     Outputs ________________________

J4DF2:	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	RET	Z			; end of line, quit
	INC	IX
	JR	J4DF2

J4DFA:	LD	HL,MODE
	RES	4,(HL)			; 212 lines mode
	LD	SP,(SAVSTK)
	LD	HL,(SAVTXT)
	RET

J4E07:	LD	E,4
	DEFB	001H
J4E0A:	LD	E,12
	DEFB	001H
J4E0D:	LD	E,5
	DEFB	001H
J4E10:	LD	E,13
	DEFB	001H
J4E13:	LD	E,16
	DEFB	001H
J4E16:	LD	E,2
	DEFB	001H
J4E19:	LD	E,8
	DEFB	001H
J4E1C:	LD	E,1
	DEFB	001H
J4E1F:	LD	E,7
	DEFB	001H
J4E22:	LD	E,10
	DEFB	001H
J4E25:	LD	E,9
	DEFB	001H
I4E28:	LD	E,3
	LD	HL,MODE
	RES	4,(HL)			; 212 lines mode
	LD	IX,M406F
	JP	CALBAS			; BASIC error

;	  Subroutine CALL statement
;	     Inputs  ________________________
;	     Outputs ________________________

C4E36:	LD	A,(BUF+5)
	AND	A			; in turbo block ?
	JP	Z,J4E16			; nope, BASIC error: syntax error
	CALL	C6032			; get BASIC character (skip spaces)
	LD	DE,PROCNM
	LD	B,15
J4E45:	LD	A,(IX+0)
	CALL	C4F03			; is BASIC character end of line of statement ?
	JR	Z,J4E57			; yep,
	CP	"("			; start of parameters ?
	JR	Z,J4E57			; yep,
	LD	(DE),A
	INC	IX
	INC	DE
	DJNZ	J4E45
J4E57:	LD	A,B
	CP	15			; CALL name zero length ?
	JP	Z,J4E16			; yep, BASIC error: syntax error
J4E5D:	XOR	A
	LD	(DE),A
	DEC	DE
	LD	A,(DE)
	CP	" "
	JR	Z,J4E5D			; strip off trailing spaces
	LD	DE,I4047
	LD	HL,PROCNM
	CALL	C4065			; check if recognized CALL statement
	JP	C,J4E16			; BASIC error: syntax error
	LD	HL,C4EFF
	SBC	HL,DE			; TURBO OFF ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	CALL	C6032			; get BASIC character (skip spaces)
	AND	A			; end of line ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	LD	IX,I4E85		; fake end of program
	RET

I4E85:	DEFB	0			; end of line
	DEFW	0			; end of program

;	  Subroutine CALL TURBO ON
;	     Inputs  ________________________
;	     Outputs ________________________

C4E88:	LD	DE,(CURLIN)
	LD	A,E
	AND	D			; in direct mode ?
	INC	A
	JP	Z,J4E0A			; yep, BASIC error: illegal direct
	LD	A,1			; turbo block
	JP	J4160			; start turbo block

;	  Subroutine parse CALL TURBO ON parameters
;	     Inputs  ________________________
;	     Outputs ________________________

C4E97:	CALL	C6503			; fetch variable name
	LD	A,H
	AND	60H			; integer variable ?
	JP	NZ,J4E0D		; nope, BASIC error: illegal function call
	PUSH	HL
	LD	HL,SWPTMP+1
	LD	A,(HL)
	AND	A
	JR	Z,J4EA9
	INC	HL
J4EA9:	LD	(HL),"%"		; add % to variable name (force integer type)
	CALL	C6032			; get BASIC character (skip spaces)
	CP	"("			; array indicator ?
	JR	Z,J4EDB			; yep,
	LD	HL,SWPTMP
	PUSH	IX
	LD	IX,M5F5D
	CALL	CALBAS			; locate variable (search only)
	EI
	POP	IX
	LD	A,E
	OR	D			; variable found ?
	JP	Z,J4E0D			; nope, BASIC error: illegal function call
	POP	HL
	CALL	C63E1			; register simple variable reference
J4ECA:	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	CP	","
	JR	Z,C4E97			; next variable
	CP	")"
	JP	NZ,J4E16		; BASIC error: syntax error
	JP	J42CC			; check for end of statement and quit

J4EDB:	INC	IX
	CALL	C6048			; check for BASIC character ")"
	LD	HL,SWPTMP
	LD	A,1
	LD	(SUBFLG),A		; variable search flag = array variable
	PUSH	IX
	LD	IX,M5EA4
	CALL	CALBAS			; locate variable
	EI
	POP	IX
	LD	(SUBFLG),A		; clear search flag
	LD	E,C
	LD	D,B
	POP	HL
	CALL	C63E5			; register array variable reference
	JR	J4ECA

;	  Subroutine CALL TURBO OFF
;	     Inputs  ________________________
;	     Outputs ________________________

C4EFF:	RET

;	  Subroutine get BASIC character (skip spaces), is end of line or statement ?
;	     Inputs  ________________________
;	     Outputs ________________________

C4F00:	CALL	C6032			; get BASIC character (skip spaces)

;	  Subroutine is BASIC character end of line of statement ?
;	     Inputs  ________________________
;	     Outputs ________________________

C4F03:	AND	A
	RET	Z
	CP	":"
	RET

I4F08:	DEFW	J4E16			; unkown token, BASIC error: syntax error
	DEFW	C6149			; LEFT$
	DEFW	C614E			; RIGHT$
	DEFW	C6173			; MID$
	DEFW	C5B51			; SGN
	DEFW	C5B04			; INT
	DEFW	C5B2A			; ABS
	DEFW	C5AF6			; SQR
	DEFW	C5AD3			; RND
	DEFW	C5AE2			; SIN
	DEFW	C5ADD			; LOG
	DEFW	C5AD8			; EXP
	DEFW	C5AE7			; COS
	DEFW	C5AEC			; TAN
	DEFW	C5AF1			; ATN
	DEFW	J4E16			; FRE, BASIC error: syntax error
	DEFW	C5B9B			; INP
	DEFW	C5C8B			; POS
	DEFW	C6273			; LEN
	DEFW	C625A			; STR$
	DEFW	C6296			; VAL
	DEFW	C6284			; ASC
	DEFW	C621B			; CHR$
	DEFW	C5B85			; PEEK
	DEFW	C6A73			; VPEEK
	DEFW	C6216			; SPACE$
	DEFW	C6208			; OCT$
	DEFW	C6203			; HEX$
	DEFW	C5C90			; LPOS
	DEFW	C620D			; BIN$
	DEFW	J4E16			; CINT, BASIC error: syntax error
	DEFW	J4E16			; CSNG, BASIC error: syntax error
	DEFW	J4E16			; CDBL, BASIC error: syntax error
	DEFW	C5B17			; FIX
	DEFW	C5CA3			; STICK
	DEFW	C5CB4			; TRIG
	DEFW	C5D14			; PDL
	DEFW	C5CC7			; PAD

;	  Subroutine evaluate byte operand and generate LD A, byte operand code
;	     Inputs  ________________________
;	     Outputs ________________________

C4F54:	CALL	C5008			; evaluate numeric expression

;	  Subroutine generate LD A,byte operand code
;	     Inputs  ________________________
;	     Outputs ________________________

C4F57:	INC	B
	DJNZ	C4F73			; generate LD A,non constant

;	  Subroutine generate LD A,constant code
;	     Inputs  L = value
;	     Outputs ________________________

C4F5A:	LD	A,L
	AND	A			; low byte zero ?
	JR	NZ,J4F67		; nope, use LD

; generate LD A,0

	CALL	C6058			; copy code block in execution buffer

	XOR	A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

; generate LD A,constant code

J4F67:	LD	A,3EH			; LD A,xx
	CALL	C60B9			; put byte in execution buffer
	LD	A,L
	CALL	C60B9			; put byte in execution buffer
	LD	B,2			; result = generated integer
	RET

;	  Subroutine generate LD A,non constant
;	     Inputs  ________________________
;	     Outputs ________________________

C4F73:	DJNZ	J4F80

;	  Subroutine generate LD A,(variable) code
;	     Inputs  ________________________
;	     Outputs ________________________

C4F75:	LD	A,3AH			; LD A,(xxxx)
	CALL	C60B9			; put byte in execution buffer
	CALL	C62E7			; create simple variable if needed, generate variable address code
	LD	B,2			; result = generated integer
	RET

J4F80:	DJNZ	J4F8B

; generate LD A,integer in register HL

	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

	LD	B,2			; result = generated integer
	RET

; generate LD A,float in register B:HL

J4F8B:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	LD	A,L
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine evaluate integer operand, generate LD HL, integer operand code
;	     Inputs  ________________________
;	     Outputs ________________________

C4F97:	CALL	C5008			; evaluate numeric expression
	CALL	C4FEF			; convert to integer
	CALL	C4FE0			; if constant, compile LD HL,xxxx

;	  Subroutine if load from variable, generate LD HL,(variable) code
;	     Inputs  ________________________
;	     Outputs ________________________

C4FA0:	LD	A,B
	DEC	A			; B=1 (variable) ?
	RET	NZ			; nope, quit
	CALL	C6086			; put LD HL,(var) in execution buffer
	LD	B,2			; result = generated integer
	RET

;	  Subroutine evaluate integer operand
;	     Inputs  ________________________
;	     Outputs ________________________

C4FA9:	CALL	C5008			; evaluate numeric expression
	JR	C4FEF			; convert to integer and quit

;	  Subroutine evaluate numeric expression, convert to float, generate code
;	     Inputs  ________________________
;	     Outputs ________________________

C4FAE:	LD	A,1
	LD	(BUF+12),A		; set force float flag
	CALL	C5008			; evaluate numeric expression
J4FB6:	CALL	C4FA0			; if load from variable, generate LD HL,(variable) code
	LD	A,B
	CP	2			; generated integer ?
	JR	NZ,J4FC4		; nope,
	CALL	C6140			; generate convert integer to float code
	LD	B,3			; result = generated float
	RET

J4FC4:	INC	B
	DEC	B			; constant ?
	RET	NZ			; nope, quit
	CALL	C78DF			; convert integer to float

;	  Subroutine generate load float code
;	     Inputs  BHL = float value
;	     Outputs ________________________

C4FCA:	LD	A,06H			; LD B,xx
	CALL	C60B9			; put byte in execution buffer
	LD	A,B
	CALL	C60B9			; put byte in execution buffer
	AND	A
	CALL	NZ,C607E		; yep, put LD HL,xxxx in execution buffer
	LD	B,3			; result = generated float
	RET

;	  Subroutine evaluate numeric expression and generate appropriate code
;	     Inputs  ________________________
;	     Outputs ________________________

C4FDA:	CALL	C5008			; evaluate numeric expression
	CALL	C4FA0			; if load from variable, generate LD HL,(variable) code

;	  Subroutine if constant, compile LD HL,xxxx
;	     Inputs  ________________________
;	     Outputs ________________________

C4FE0:	INC	B
	DEC	B			; B=0 (integer constant) ?
	RET	NZ			; nope, quit
	CALL	C607E			; put LD HL,xxxx in execution buffer
	LD	B,2			; result = generated integer
	RET

;	  Subroutine evaluate numeric expression, convert to integer, generate code
;	     Inputs  ________________________
;	     Outputs ________________________

C4FE9:	CALL	C5008			; evaluate numeric expression
	CALL	C4FA0			; if load from variable, generate LD HL,(variable) code

;	  Subroutine convert to integer
;	     Inputs  ________________________
;	     Outputs ________________________

C4FEF:	LD	A,B
	CP	3			; float ?
	RET	NZ			; nope, quit
	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine evaluate string expression
;	     Inputs  ________________________
;	     Outputs ________________________

C4FFE:	CALL	C5012			; evaluate expression

;	  Subroutine check for string
;	     Inputs  ________________________
;	     Outputs ________________________

C5001:	LD	A,B
	CP	4			; string ?
	RET	Z			; yep, quit
	JP	J4E10			; nope, BASIC error: type mismatch

;	  Subroutine evaluate numeric expression
;	     Inputs  ________________________
;	     Outputs ________________________

C5008:	CALL	C5012			; evaluate expression

;	  Subroutine check for numeric
;	     Inputs  ________________________
;	     Outputs ________________________

C500B:	LD	A,B
	CP	4			; string ?
	RET	NZ			; nope, quit
	JP	J4E10			; yep, BASIC error: type mismatch

;	  Subroutine evaluate expression
;	     Inputs  ________________________
;	     Outputs ________________________
;
; expression is a series of value elements combined with operators
;
; operators are either arithmetic, comparison, (string) concat, logical and bitwise
;
; precedence rules:
;
; arithmetic and concat operators
;   ^
;   + - (unary)
;   * /
;   \
;   MOD
;   + -
;   + (string concat)
; comparison operators
;   =  <>  <  <=  >  >=
; logical and bitwise
;   NOT
;   AND
;   OR
;   XOR

C5012:	CALL	C5025			; OR or higher order
J5015:	CALL	C6032			; get BASIC character (skip spaces)
	CP	0F8H			; XOR token ?
	RET	NZ

; XOR

	LD	DE,C5025		; operand2 handler = OR or higher order
	LD	A,0EEH-0E6H		; XOR opcode offset
	CALL	C5D25			; generate logical operation code
	JR	J5015			; next XOR or quit to lower order

;	  Subroutine OR or higher order
;	     Inputs  ________________________
;	     Outputs ________________________

C5025:	CALL	C5038			; AND or higher order
J5028:	CALL	C6032			; get BASIC character (skip spaces)
	CP	0F7H			; OR token ?
	RET	NZ

; OR

	LD	DE,C5038		; operand2 handler = AND or higher order
	LD	A,0F6H-0E6H		; OR opcode offset
	CALL	C5D25			; generate logical operation code
	JR	J5028			; next OR or quit to lower order

;	  Subroutine AND or higher order
;	     Inputs  ________________________
;	     Outputs ________________________

C5038:	CALL	C504B			; comparison or higher order
J503B:	CALL	C6032			; get BASIC character (skip spaces)
	CP	0F6H			; AND token ?
	RET	NZ

; AND

	LD	DE,C504B		; operand2 handler =  or higher order
	LD	A,0E6H-0E6H		; AND opcode offset
	CALL	C5D25			; generate logical operation code
	JR	J503B			; next AND or quit to lower order

;	  Subroutine comparison or higher order
;	     Inputs  ________________________
;	     Outputs ________________________

C504B:	CALL	C5120			; evaluate arithmetic and concat expression
J504E:	LD	D,0			; assume no compare
J5050:	CALL	C6032			; get BASIC character (skip spaces)
	SUB	0EEH			; compare operator token (> = <) ?
	JR	C,J5068			; nope,
	CP	3
	JR	NC,J5068		; nope,
	CP	1
	RLA                             ; b0 is >, b1 is =, b2 is <
	XOR	D
	CP	D
	JP	C,J4E16			; BASIC error: syntax error
	LD	D,A
	INC	IX
	JR	J5050			; next compare operator

J5068:	LD	A,D
	AND	A			; no compare ?
	RET	Z			; yep, quit
	DEC	A
	ADD	A,A
	LD	D,A
	LD	A,B
	CP	4			; string ?
	LD	A,D
	JR	Z,J507E			; yep, string compare

; numeric compare

	DEC	IX
	LD	DE,C5120		; operand2 handler = evaluate arithmetic and concat expression
	CALL	C5E87			; numeric compare
	JR	J504E

; string compare

J507E:	PUSH	AF
	CALL	C50A1			; generate copy string to NULBUF code
	CALL	C5120			; evaluate arithmetic and concat expression
	CALL	C5001			; check for string
	POP	AF
	LD	E,A
	LD	D,0
	LD	HL,I50DE
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	LD	A,0CDH			; CALL xxxx
	CALL	C60AB			; put 3 bytes in execution buffer
	XOR	A
	LD	(BUF+13),A		; reset NULBUF in use flag
	LD	B,2			; result = generated integer
	JR	J504E

;	  Subroutine generate copy string to NULBUF code
;	     Inputs  ________________________
;	     Outputs ________________________

C50A1:	LD	HL,BUF+13
	LD	A,(HL)
	AND	A			; NULBUF in use flag set ?
	JP	NZ,J4E13		; yep, BASIC error: string formula too complex
	LD	(HL),1			; set NULBUF in use flag
	CALL	C6058			; copy code block in execution buffer

	CALL	C7F40			; copy string to NULBUF
	DEFW	0

	RET

I50B4:	DEFW	I50FF
	DEFW	I5100
	DEFW	I50EC
	DEFW	I50EC
	DEFW	I510E
	DEFW	I510D
	DEFW	I5100
	DEFW	I50FF
	DEFW	I50F6
	DEFW	I50F6
	DEFW	I510D
	DEFW	I510E
	DEFW	I511C
	DEFW	I511C

I50D0:	DEFW	C793C			; 001 >
	DEFW	C792A			; 010 =
	DEFW	C7946			; 011 >=
	DEFW	C794F			; 100 <
	DEFW	C7933			; 101 <>
	DEFW	C7958			; 110 <=
	DEFW	C7962			; 111 <=> return true

I50DE:	DEFW	C7F4B			; 001 >
	DEFW	C7F55			; 010 =
	DEFW	C7F5B			; 011 >=
	DEFW	C7F61			; 100 <
	DEFW	C7F67			; 101 <>
	DEFW	C7F6D			; 110 <=
	DEFW	C7F77			; 111 <=> return true

I50EC:	AND	A
	SBC	HL,DE
	LD	HL,-1
	JR	Z,J50F5
	INC	HL
J50F5:	DEFB	0

I50F6:	AND	A
	SBC	HL,DE
	JR	Z,J50FE
	LD	HL,0FFFFH
J50FE:	DEFB	0

I50FF:	EX	DE,HL
I5100:	LD	A,H
	XOR	80H
	LD	H,A
	LD	A,D
	XOR	80H
	LD	D,A
	SBC	HL,DE
	SBC	HL,HL
	DEFB	0

I510D:	EX	DE,HL
I510E:	LD	A,H
	XOR	80H
	LD	H,A
	LD	A,D
	XOR	80H
	LD	D,A
	SBC	HL,DE
	CCF
	SBC	HL,HL
	DEFB	0

I511C:	LD	HL,0FFFFH
	DEFB	0

;	  Subroutine evaluate arithmetic and concat expression
;	     Inputs  ________________________
;	     Outputs ________________________

C5120:	CALL	C525A			; MOD or higher order

; check if + or - 

J5123:	LD	DE,C525A		; operand2 handler = MOD or higher order
	CALL	C6032			; get BASIC character (skip spaces)
	CP	0F1H			; + token ?
	JR	Z,J5159
	CP	0F2H			; - token ?
	RET	NZ			; nope, quit

; -

	LD	IY,C76D3		; auxilair handler (used in operator handler) = handler for subtract floats
	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C51A2			; integer constant, integer constant
	DEFW	C51A9			; integer constant, variable
	DEFW	C51B0			; integer constant, generated integer
	DEFW	C51BC			; variable, integer constant
	DEFW	C51C3			; variable, variable
	DEFW	C51CA			; variable, generated integer
	DEFW	C51D6			; generated integer, integer constant
	DEFW	C51F7			; generated integer, variable
	DEFW	C51FC			; generated integer, generated integer
	DEFW	C60E1			; integer constant, generated float
	DEFW	C60F1			; variable, generated float
	DEFW	C60FE			; generated integer, generated float
	DEFW	C6109			; generated float, integer constant
	DEFW	C612B			; generated float, variable
	DEFW	C612E			; generated float, generated integer
	DEFW	C6131			; generated float, generated float

	JR	J5123			; next + or - or lower order

; +

J5159:	LD	A,B
	CP	4			; string ?
	JR	Z,J5187			; yep,
	LD	IY,C76D7		; auxilair handler (used in operator handler) = handler for add floats
	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C520E			; integer constant, integer constant
	DEFW	C5212			; integer constant, variable
	DEFW	C5215			; integer constant, generated integer
	DEFW	C5218			; variable, integer constant
	DEFW	C521F			; variable, variable
	DEFW	C5226			; variable, generated integer
	DEFW	C5229			; generated integer, integer constant
	DEFW	C5246			; generated integer, variable
	DEFW	C524B			; generated integer, generated integer
	DEFW	C60E1			; integer constant, generated float
	DEFW	C60F1			; variable, generated float
	DEFW	C60FE			; generated integer, generated float
	DEFW	C6109			; generated float, integer constant
	DEFW	C611B			; generated float, variable
	DEFW	C611E			; generated float, generated integer
	DEFW	C6121			; generated float, generated float

	JR	J5123			; next + or - or lower order

; + operator for strings

J5187:	INC	IX
	CALL	C50A1			; generate copy string to NULBUF code
	CALL	C525A			; MOD or higher order
	CALL	C5001			; check for string
	CALL	C6058			; copy code block in execution buffer

	CALL	C7F99			; concat strings
	DEFW	0

	XOR	A
	LD	(BUF+13),A		; reset NULBUF in use flag
	LD	B,4			; result = generated string
	JR	J5123			; next + or - or lower order

;	  Subroutine subtract, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C51A2:	EX	DE,HL
	AND	A
	SBC	HL,DE
	LD	B,0			; result = integer constant
	RET

;	  Subroutine subtract, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C51A9:	EX	DE,HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	EX	DE,HL
	JR	C51F7

;	  Subroutine subtract, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C51B0:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	JR	J5203

;	  Subroutine subtract, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C51BC:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C51D6

;	  Subroutine subtract, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C51C3:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C51F7

;	  Subroutine subtract, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C51CA:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	JR	J5203

;	  Subroutine subtract, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C51D6:	INC	H
	DEC	H
	JR	NZ,J51DF
	LD	A,L
	CP	5
	JR	C,J51E8
J51DF:	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
	JP	C5229

J51E8:	AND	A
	JR	Z,J51F4
	LD	B,A
J51EC:	CALL	C6058			; copy code block in execution buffer

	DEC	HL
	DEFW	0

	DJNZ	J51EC
J51F4:	LD	B,2			; result = generated integer
	RET

;	  Subroutine subtract, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C51F7:	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J5203

;	  Subroutine subtract, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C51FC:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	POP	HL
	DEFW	0

J5203:	CALL	C6058			; copy code block in execution buffer

	AND	A
	SBC	HL,DE
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine add, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C520E:	ADD	HL,DE
	LD	B,0			; result = integer constant
	RET

;	  Subroutine add, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5212:	EX	DE,HL
	JR	C5218

;	  Subroutine add, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C5215:	EX	DE,HL
	JR	C5229

;	  Subroutine add, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5218:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C5229

;	  Subroutine add, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C521F:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C5246

;	  Subroutine add, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C5226:	EX	DE,HL
	JR	C5246

;	  Subroutine add, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5229:	INC	H
	DEC	H
	JR	NZ,J5232
	LD	A,L
	CP	05H	; 5 
	JR	C,J5237
J5232:	CALL	C6079			; put LD DE,xxxx in execution buffer
	JR	J5251

J5237:	AND	A
	JR	Z,J5243
	LD	B,A
J523B:	CALL	C6058			; copy code block in execution buffer

	INC	HL
	DEFW	0

	DJNZ	J523B
J5243:	LD	B,2			; result = generated integer
	RET

;	  Subroutine add, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5246:	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J5251

;	  Subroutine add, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C524B:	CALL	C6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

J5251:	CALL	C6058			; copy code block in execution buffer

	ADD	HL,DE
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine MOD or higher order
;	     Inputs  ________________________
;	     Outputs ________________________

C525A:	CALL	C52E0			; \ or higher order
J525D:	CALL	C6032			; get BASIC character (skip spaces)
	CP	0FBH			; MOD
	RET	NZ			; nope, quit

; MOD

	LD	DE,C52E0		; operand2 handler = \ or higher order
	LD	IY,C76CE		; auxilair handler (used in operator handler) = remainer of divide integer
	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C528F			; integer constant, integer constant
	DEFW	C5296			; integer constant, variable
	DEFW	C529E			; integer constant, generated integer
	DEFW	C52AA			; variable, integer constant
	DEFW	C52B1			; variable, variable
	DEFW	C52B8			; variable, generated integer
	DEFW	C52C4			; generated integer, integer constant
	DEFW	C52C9			; generated integer, variable
	DEFW	C52CE			; generated integer, generated integer
	DEFW	C5392			; integer constant, generated float
	DEFW	C53A1			; variable, generated float
	DEFW	C53B0			; generated integer, generated float
	DEFW	C53BC			; generated float, integer constant
	DEFW	C53C9			; generated float, variable
	DEFW	C53DE			; generated float, generated integer
	DEFW	C53D6			; generated float, generated float

	JR	J525D			; next MOD or quit

;	  Subroutine mod, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C528F:	EX	DE,HL
	CALL	C76CE			; remainer of divide integer
	LD	B,0			; result = integer constant
	RET

;	  Subroutine mod, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5296:	EX	DE,HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	EX	DE,HL
	JP	C52C9

;	  Subroutine mod, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C529E:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	JR	J52D5

;	  Subroutine mod, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C52AA:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C52C4

;	  Subroutine mod, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C52B1:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C52C9

;	  Subroutine mod, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C52B8:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	JR	J52D5

;	  Subroutine mod, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C52C4:	CALL	C6079			; put LD DE,xxxx in execution buffer
	JR	J52D5

;	  Subroutine mod, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C52C9:	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J52D5

;	  Subroutine mod, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C52CE:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	POP	HL
	DEFW	0

J52D5:	CALL	C6058			; copy code block in execution buffer

	CALL	C76CE			; remainer of divide integer
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine \ or higher order
;	     Inputs  ________________________
;	     Outputs ________________________

C52E0:	CALL	C53F3			; / * or higher order
J52E3:	CALL	C6032			; get BASIC character (skip spaces)
	CP	0FCH			; \ token ?
	RET	NZ

; \

	LD	DE,C53F3		; operand2 handler = / * or higher order
	LD	IY,C7643		; auxilair handler (used in operator handler) = divide integer
	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C5315			; integer constant, integer constant
	DEFW	C531C			; integer constant, variable
	DEFW	C5324			; integer constant, generated integer
	DEFW	C5330			; variable, integer constant
	DEFW	C5337			; variable, variable
	DEFW	C533E			; variable, generated integer
	DEFW	C534A			; generated integer, integer constant
	DEFW	C537B			; generated integer, variable
	DEFW	C5380			; generated integer, generated integer
	DEFW	C5392			; integer constant, generated float
	DEFW	C53A1			; variable, generated float
	DEFW	C53B0			; generated integer, generated float
	DEFW	C53BC			; generated float, integer constant
	DEFW	C53C9			; generated float, variable
	DEFW	C53DE			; generated float, generated integer
	DEFW	C53D6			; generated float, generated float

	JR	J52E3			; next \ or quit to lower order

;	  Subroutine \, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5315:	EX	DE,HL
	CALL	C7643			; divide
	LD	B,0			; result = integer constant
	RET

;	  Subroutine \, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C531C:	EX	DE,HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	EX	DE,HL
	JP	C537B

;	  Subroutine \, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C5324:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	JR	J5387			; generate integer divide code and quit

;	  Subroutine \, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5330:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C534A

;	  Subroutine \, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5337:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C537B

;	  Subroutine \, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C533E:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	JR	J5387			; generate integer divide code and quit

;	  Subroutine \, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C534A:	CALL	C552D			; is value a bit shift value ?
	JR	C,J5354			; yep, use (fast) shift code
	CALL	C6079			; put LD DE,xxxx in execution buffer
	JR	J5387			; generate integer divide code and quit

J5354:	LD	A,H
	DEC	A
	OR	L			; divider = 256 ?
	JR	Z,J536E			; yep,
	LD	B,(IY+32)		; number of shifts
	INC	B
	DEC	B			; number of shifts = 0 ?
	JR	Z,J536B			; yep, done
J5360:	CALL	C6058			; copy code block in execution buffer

	SRA	H
	RR	L
	DEFW	0

	DJNZ	J5360			; next shift
J536B:	LD	B,2			; result = generated integer
	RET

J536E:	CALL	C6058			; copy code block in execution buffer

	LD	L,H			; / 256
	RL	H
	SBC	A,A
	LD	H,A			; retain sign
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine \, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C537B:	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J5387			; generate integer divide code and quit

;	  Subroutine \, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C5380:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	POP	HL
	DEFW	0

J5387:	CALL	C6058			; copy code block in execution buffer

	CALL	C7643			; divide
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine mod \, integer constant, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C5392:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	JR	J53E9

;	  Subroutine mod \, variable, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C53A1:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	JR	J53E9

;	  Subroutine mod \, generated integer, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C53B0:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	EX	DE,HL
	POP	HL
	DEFW	0

	JR	J53E9

;	  Subroutine mod \, generated float, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C53BC:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	DEFW	0

	CALL	C6079			; put LD DE,xxxx in execution buffer
	JR	J53E9

;	  Subroutine mod \, generated float, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C53C9:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	DEFW	0

	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J53E9

;	  Subroutine mod \, generated float, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C53D6:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	DEFW	0

;	  Subroutine mod \, generated float, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C53DE:	CALL	C6058			; copy code block in execution buffer

	POP	BC
	EX	(SP),HL
	CALL	C7901			; convert float to integer
	POP	DE
	DEFW	0

J53E9:	LD	B,2			; result = generated integer

;	  Subroutine generate CALL xxxx (xxxx is in IY)
;	     Inputs  ________________________
;	     Outputs ________________________

J53EB:	PUSH	IY
	POP	HL

;	  Subroutine generate CALL xxxx (xxxx is in HL)
;	     Inputs  ________________________
;	     Outputs ________________________

J53EE:	LD	A,0CDH			; CALL xxxx
	JP	C60AB			; put 3 bytes in execution buffer

;	  Subroutine / * or higher order
;	     Inputs  ________________________
;	     Outputs ________________________

C53F3:	CALL	C5622			; ^ or higher order
J53F6:	LD	DE,C5622		; operand2 handler = ^ or higher order
	CALL	C6032			; get BASIC character (skip spaces)
	CP	0F4H			; / token ?
	JR	Z,J542C
	CP	0F3H			; * token ?
	RET	NZ			; nope, quit

; *
	LD	IY,C7748		; auxilair handler (used in operator handler) = handler for multipy floats
	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C54D1			; integer constant, integer constant
	DEFW	C54D7			; integer constant, variable
	DEFW	C54DA			; integer constant, generated integer
	DEFW	C54DE			; variable, integer constant
	DEFW	C54E5			; variable, variable
	DEFW	C54EB			; variable, generated integer
	DEFW	C54EE			; generated integer, integer constant
	DEFW	C5517			; generated integer, variable
	DEFW	C551C			; generated integer, generated integer
	DEFW	C60E1			; integer constant, generated float
	DEFW	C60F1			; variable, generated float
	DEFW	C60FE			; generated integer, generated float
	DEFW	C6109			; generated float, integer constant
	DEFW	C611B			; generated float, variable
	DEFW	C611E			; generated float, generated integer
	DEFW	C6121			; generated float, generated float

	JR	J53F6			; next * / or quit to lower order

; /

J542C:	LD	IY,C782C		; auxilair handler (used in operator handler) = handler for divide floats
	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C5455			; integer constant, integer constant
	DEFW	C5469			; integer constant, variable
	DEFW	C546C			; integer constant, generated integer
	DEFW	C547F			; variable, integer constant
	DEFW	C5499			; variable, variable
	DEFW	C549C			; variable, generated integer
	DEFW	C5484			; generated integer, integer constant
	DEFW	C54AC			; generated integer, variable
	DEFW	C54AF			; generated integer, generated integer
	DEFW	C60E1			; integer constant, generated float
	DEFW	C60F1			; variable, generated float
	DEFW	C60FE			; generated integer, generated float
	DEFW	C6109			; generated float, integer constant
	DEFW	C612B			; generated float, variable
	DEFW	C612E			; generated float, generated integer
	DEFW	C6131			; generated float, generated float

	JR	J53F6

;	  Subroutine divide, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5455:	PUSH	DE
	CALL	C78DF			; convert integer to float
	POP	DE
	PUSH	HL
	PUSH	BC
	EX	DE,HL
	CALL	C78DF			; convert integer to float
	POP	DE
	LD	C,D
	POP	DE
	CALL	C782C			; divide floats
	JP	C4FCA			; generate load float code and quit

;	  Subroutine divide, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5469:	CALL	C6086			; put LD HL,(var) in execution buffer

;	  Subroutine divide, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C546C:	CALL	C6058			; copy code block in execution buffer

	CALL	C78DF			; convert integer to float
	LD	C,B
	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C78DF			; convert integer to float
	CALL	C4FCA			; generate load float code
	JR	J54C6

;	  Subroutine divide, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C547F:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL

;	  Subroutine divide, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5484:	CALL	C6140			; generate convert integer to float code
	CALL	C78DF			; convert integer to float
	LD	A,0EH			; LD C,xx
	CALL	C60B9			; put byte in execution buffer
	LD	A,B
	CALL	C60B9			; put byte in execution buffer
	AND	A
	CALL	NZ,C6079		; yep, put LD DE,xxxx in execution buffer
	JR	J54C6

;	  Subroutine divide, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5499:	CALL	C6086			; put LD HL,(var) in execution buffer

;	  Subroutine divide, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C549C:	CALL	C6058			; copy code block in execution buffer

	CALL	C78DF			; convert integer to float
	PUSH	HL
	PUSH	BC
	DEFW	0

	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	JR	J54BB

;	  Subroutine divide, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C54AC:	CALL	C6086			; put LD HL,(var) in execution buffer

;	  Subroutine divide, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C54AF:	CALL	C6058			; copy code block in execution buffer

	CALL	C78DF			; convert integer to float
	POP	DE
	PUSH	HL
	PUSH	BC
	EX	DE,HL
	DEFW	0

J54BB:	CALL	C6058			; copy code block in execution buffer

	CALL	C78DF			; convert integer to float
	POP	DE
	LD	C,D
	POP	DE
	DEFW	0

J54C6:	CALL	C6058			; copy code block in execution buffer

	CALL	C782C			; divide floats
	DEFW	0

	LD	B,3			; result = generated float
	RET

;	  Subroutine multiply, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C54D1:	CALL	C7624			; multiply
	LD	B,0			; result = integer constant
	RET

;	  Subroutine multiply, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C54D7:	EX	DE,HL
	JR	C54DE

;	  Subroutine multiply, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C54DA:	EX	DE,HL
	JP	C54EE

;	  Subroutine multiply, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C54DE:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C54EE

;	  Subroutine multiply, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C54E5:	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C5517

;	  Subroutine multiply, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C54EB:	EX	DE,HL
	JR	C5517

;	  Subroutine multiply, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C54EE:	CALL	C5587			; is value suitable for optimized code ?
	JR	C,J54FD			; yep, generate optimzed code
	CALL	C552D			; is value a bit shift value ?
	JR	C,J5509			; yep, use (fast) bit shift code
	CALL	C6079			; put LD DE,xxxx in execution buffer
	JR	J5522

J54FD:	LD	A,(HL)			; get code byte
	CP	0FFH			; end of optimzed code ?
	LD	B,2			; result = generated integer
	RET	Z			; yep, quit
	CALL	C60B9			; put byte in execution buffer
	INC	HL
	JR	J54FD			; next code byte

J5509:	LD	B,(IY+32)		; number of shifts
J550C:	CALL	C6058			; copy code block in execution buffer

	ADD	HL,HL
	DEFW	0

	DJNZ	J550C
	LD	B,2			; result = generated integer
	RET

;	  Subroutine multiply, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5517:	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J5522

;	  Subroutine multiply, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C551C:	CALL	C6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

J5522:	CALL	C6058			; copy code block in execution buffer

	CALL	C7624			; multiply
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine is value a bit shift value ?
;	     Inputs  HL = value
;	     Outputs Cx set if a bit shift value, Cx reset if not a bit shift value, IY+32 = pointer to number of shifts

C552D:	LD	IY,I5547
	LD	B,16
J5533:	LD	A,L
	CP	(IY+0)
	JR	NZ,J553F
	LD	A,H
	CP	(IY+1)
	SCF
	RET	Z
J553F:	INC	IY
	INC	IY
	DJNZ	J5533
	AND	A
	RET

; bit shift value

I5547:	DEFW	1
	DEFW	2
	DEFW	4
	DEFW	8
	DEFW	16
	DEFW	32
	DEFW	64
	DEFW	128
	DEFW	256
	DEFW	512
	DEFW	1024
	DEFW	2048
	DEFW	4096
	DEFW	8192
	DEFW	16384
	DEFW	32768

; number of bit shifts

	DEFW	0
	DEFW	1
	DEFW	2
	DEFW	3
	DEFW	4
	DEFW	5
	DEFW	6
	DEFW	7
	DEFW	8
	DEFW	9
	DEFW	10
	DEFW	11
	DEFW	12
	DEFW	13
	DEFW	14
	DEFW	15

;	  Subroutine is value suitable for optimized code ?
;	     Inputs  HL = value
;	     Outputs Cx set if optimzed code available, HL = optimized code handler

C5587:	LD	IY,I55AC
J558B:	LD	A,(IY+0)
	OR	(IY+1)			; end of table ?
	RET	Z			; yep, quit (no optimzed code for value)
	LD	A,(IY+0)
	CP	L			; value found ?
	JR	NZ,J559E		; nope, next
	LD	A,(IY+1)
	CP	H			; value found ?
	JR	Z,J55A4			; yep, quit with optimzed 
J559E:	INC	IY
	INC	IY
	JR	J558B

J55A4:	LD	L,(IY+34)
	LD	H,(IY+35)
	SCF
	RET

; values with optimzed code available

I55AC:	DEFW	1
	DEFW	3
	DEFW	5
	DEFW	6
	DEFW	7
	DEFW	9
	DEFW	10
	DEFW	20
	DEFW	25
	DEFW	40
	DEFW	50
	DEFW	80
	DEFW	100
	DEFW	200
	DEFW	256
	DEFW	257
	DEFW	0

; optimzed code for value

	DEFW	C55F3			; 1 -> generate no code, result = val
	DEFW	C55EF			; 3
	DEFW	C55F8			; 5
	DEFW	C55EE			; 6
	DEFW	C55FE			; 7
	DEFW	C5605			; 9
	DEFW	C55F7			; 10
	DEFW	C55F6			; 20
	DEFW	C560F			; 25
	DEFW	C55F5			; 40
	DEFW	C560E			; 50
	DEFW	C55F4			; 80
	DEFW	C560D			; 100
	DEFW	C560C			; 200
	DEFW	C561A			; 256
	DEFW	C561E			; 257

; optimized code for *6

C55EE:	ADD	HL,HL

; optimized code for *3

C55EF:	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,DE
C55F3:	DEFB	0FFH

; optimized code for *80

C55F4:	ADD	HL,HL

; optimized code for *40

C55F5:	ADD	HL,HL

; optimized code for *20

C55F6:	ADD	HL,HL

; optimized code for *10

C55F7:	ADD	HL,HL

; optimized code for *5

C55F8:	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,DE
	DEFB	0FFH

; optimized code for *7

C55FE:	LD	E,L
	LD	D,H
	ADD	HL,HL			; *2
	ADD	HL,DE			; *3
	ADD	HL,HL			; *6
	ADD	HL,DE			; *7
	DEFB	0FFH

; optimized code for *9

C5605:	LD	E,L
	LD	D,H
	ADD	HL,HL			; *2
	ADD	HL,HL			; *4
	ADD	HL,HL			; *8
	ADD	HL,DE			; *9
	DEFB	0FFH

; optimized code for *200

C560C:	ADD	HL,HL

; optimized code for *100

C560D:	ADD	HL,HL

; optimized code for *50

C560E:	ADD	HL,HL

; optimized code for *25

C560F:	LD	E,L
	LD	D,H
	ADD	HL,HL			; *2
	ADD	HL,HL			; *4
	ADD	HL,DE			; *5
	LD	E,L
	LD	D,H
	ADD	HL,HL			; *10
	ADD	HL,HL			; *20
	ADD	HL,DE			; *25
	DEFB	0FFH

C561A:	LD	H,L			; low byte to high byte = *256
	LD	L,0			; clear low byte
	DEFB	0FFH

C561E:	LD	A,L			; 1
	ADD	A,H
	LD	H,A			; *257
	DEFB	0FFH

;	  Subroutine ^ or higher order
;	     Inputs  ________________________
;	     Outputs ________________________

C5622:	CALL	C56EC			; evaluate factor
J5625:	CALL	C6032			; get BASIC character (skip spaces)
	CP	0F5H			; ^ token ?
	RET	NZ

; ^

	LD	DE,C56EC		; operand2 handler = evaluate factor
	LD	IY,I78BF		; auxilair handler (used in operator handler) = handler for ^ floats
	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C5657			; integer constant, integer constant
	DEFW	C5666			; integer constant, variable
	DEFW	C5672			; integer constant, generated integer
	DEFW	C5681			; variable, integer constant
	DEFW	C5688			; variable, variable
	DEFW	C568F			; variable, generated integer
	DEFW	C56A4			; generated integer, integer constant
	DEFW	C56AC			; generated integer, variable
	DEFW	C56B4			; generated integer, generated integer
	DEFW	C60E1			; integer constant, generated float
	DEFW	C60F1			; variable, generated float
	DEFW	C60FE			; generated integer, generated float
	DEFW	C56C9			; generated float, integer constant
	DEFW	C56CE			; generated float, variable
	DEFW	C56D9			; generated float, generated integer
	DEFW	C6131			; generated float, generated float

	JR	J5625			; next ^ or quit to lower order

;	  Subroutine ^, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5657:	PUSH	HL
	EX	DE,HL
	CALL	C78DF			; convert integer to float
	POP	DE
	CALL	C7878			; ^ handler
	CALL	C4FCA			; generate load float code
	LD	B,3			; result = generated float
	RET

;	  Subroutine ^, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5666:	PUSH	HL
	EX	DE,HL
	CALL	C78DF			; convert integer to float
	CALL	C4FCA			; generate load float code
	POP	HL
	JP	J56AF

;	  Subroutine ^, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C5672:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C78DF			; convert integer to float
	CALL	C4FCA			; generate load float code
	JR	J56BE

;	  Subroutine ^, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5681:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C56A4

;	  Subroutine ^, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5688:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C56AC

;	  Subroutine ^, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C568F:	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	CALL	C6058			; copy code block in execution buffer

	CALL	C78DF			; convert integer to float
	POP	DE
	DEFW	0

	JR	J56BE

;	  Subroutine ^, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C56A4:	CALL	C6140			; generate convert integer to float code
	CALL	C6079			; put LD DE,xxxx in execution buffer
	JR	J56BE

;	  Subroutine ^, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C56AC:	CALL	C6140			; generate convert integer to float code
J56AF:	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J56BE

;	  Subroutine ^, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C56B4:	CALL	C6058			; copy code block in execution buffer

	EX	(SP),HL
	CALL	C78DF			; convert integer to float
	POP	DE
	DEFW	0

J56BE:	CALL	C6058			; copy code block in execution buffer

	CALL	C7878			; ^ handler
	DEFW	0

	LD	B,3			; result = generated float
	RET

C56C9:	CALL	C6079			; put LD DE,xxxx in execution buffer
	JR	J56E1

C56CE:	CALL	C60D7			; remove byte from execution buffer
	CALL	C60D7			; remove byte from execution buffer
	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J56E1

C56D9:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	POP	BC
	POP	HL
	DEFW	0

J56E1:	CALL	C6058			; copy code block in execution buffer

	CALL	C7878			; ^ handler
	DEFW	0

	LD	B,3			; result = generated float
	RET

;	  Subroutine evaluate factor
;	     Inputs  ________________________
;	     Outputs ________________________

C56EC:	LD	HL,(BUF+21)		; start of variable list
	LD	BC,140
	ADD	HL,BC
	SBC	HL,SP
	JP	NC,J4E1F		; BASIC error: out of memory
	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	CP	"("
	JR	NZ,J5707
	CALL	C5012			; evaluate expression
	JP	C6048			; check for BASIC character ")"

J5707:	LD	HL,BUF+12
	BIT	0,(HL)			; force float flag ?
	RES	0,(HL)			; reset force float flag
	JR	Z,C5716			; nope, evaluate factor
	CALL	C5716			; evaluate factor
	JP	J4FB6			; convert to float, generate code and quit

;	  Subroutine evaluate factor
;	     Inputs  ________________________
;	     Outputs ________________________

C5716:	CP	11H			; constant very small integer ?
	JR	C,J5725			; nope,
	CP	1BH
	JR	NC,J5725		; nope,
	SUB	11H
	LD	L,A
	LD	H,0			; HL = very small integer
	LD	B,H			; B = 0
	RET

J5725:	CP	0FH			; constant small integer ?
	JR	NZ,J5732		; nope,
	LD	L,(IX+0)
	INC	IX
	LD	H,0			; HL = small integer
	LD	B,H			; B = 0
	RET

J5732:	CP	1CH			; constant integer ?
	JR	Z,J573E			; yep,
	CP	0CH			; hexadecimal constant integer ?
	JR	Z,J573E			; yep,
	CP	0BH			; octal constant integer ?
	JR	NZ,J574B		; nope,
J573E:	LD	L,(IX+0)
	LD	H,(IX+1)		; HL = integer
	INC	IX
	INC	IX
	LD	B,0			; result = integer constant
	RET

J574B:	CP	"&"
	JR	NZ,J576A
	LD	A,(IX+0)
	CP	"B"
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	LD	B,0			; result = integer constant
	LD	L,B
	LD	H,B			; HL = 0
J575B:	INC	IX
	LD	A,(IX+0)
	SUB	"0"
	CP	1+1
	RET	NC
	ADD	HL,HL
	OR	L
	LD	L,A
	JR	J575B

J576A:	CP	"0"
	JR	C,J578E
	CP	"9"+1
	JR	NC,J578E
	LD	B,0			; result = integer constant
	SUB	"0"
	LD	L,A
	LD	H,B
J5778:	CALL	C6032			; get BASIC character (skip spaces)
	SUB	"0"
	CP	9+1
	RET	NC
	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,HL
	LD	E,A
	LD	D,0
	ADD	HL,DE
	INC	IX
	JR	J5778

J578E:	CP	1DH			; single real ?
	LD	C,3			; 3 bytes mantissa (including sign bit)
	JR	Z,J579B
	CP	1FH			; double real ?
	LD	C,7			; 7 bytes mantissa (including sign bit)
	JP	NZ,J5837		; handle constant string, variable, NOT - or function
J579B:	LD	B,0
	LD	A,(IX+0)		; exponent
	ADD	IX,BC			; LSB of mantissa
	AND	A			; exponent = 0 ?
	JR	Z,J57EE			; yep, generate float 0.0 code and quit
	PUSH	IX
	LD	A,C
J57A8:	PUSH	AF
	LD	A,(IX+0)		; mantissa byte (low nibble)
	CALL	C57FA			; add converted nibble and /10
	LD	A,(IX+0)
	RRCA
	RRCA
	RRCA
	RRCA				; high nibble
	CALL	C57FA			; add converted nibble and /10
	POP	AF
	DEC	IX
	DEC	A
	JR	NZ,J57A8		; next mantissa byte
	LD	A,(IX+0)		; exponent
	POP	IX			; to LSB of mantissa
	INC	IX
	AND	A			; positive exponent ?
	JP	P,J57CE			; yep,
	SET	7,H
	AND	7FH
J57CE:	CP	40H
	JP	Z,C4FCA			; generate load float code and quit
	PUSH	AF
	JR	NC,J57E2
	LD	C,7DH
	LD	DE,4CCCH		; float 0.1
	CALL	C7748			; multipy floats
	POP	AF
	INC	A
	JR	J57CE

J57E2:	LD	C,84H
	LD	DE,2000H		; float 10
	CALL	C7748			; multipy floats
	POP	AF
	DEC	A
	JR	J57CE

J57EE:	INC	IX
	CALL	C6058			; copy code block in execution buffer

	LD	B,0
	DEFW	0

	LD	B,3			; result = generated float
	RET

;	  Subroutine add converted nibble and /10
;	     Inputs  ________________________
;	     Outputs ________________________

C57FA:	AND	0FH			; nibble
	PUSH	HL
	PUSH	BC
	LD	C,A
	LD	B,0
	LD	HL,I5819
	ADD	HL,BC
	ADD	HL,BC
	ADD	HL,BC
	POP	BC
	LD	C,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	E,(HL)			; C:DE = float
	POP	HL
	CALL	C76D7			; add floats
	LD	C,7DH
	LD	DE,4CCCH		; float 0.1
	JP	C7748			; multipy floats and quit

I5819:	DEFB	000H,000H,000H		; float 0.0 
	DEFB	081H,000H,000H		; float 1.0
	DEFB	082H,000H,000H		; float 2.0
	DEFB	082H,040H,000H		; float 3.0
	DEFB	083H,000H,000H		; float 4.0
	DEFB	083H,020H,000H		; float 5.0
	DEFB	083H,040H,000H		; float 6.0
	DEFB	083H,060H,000H		; float 7.0
	DEFB	084H,000H,000H		; float 8.0
	DEFB	084H,010H,000H		; float 9.0

;	  Subroutine generate code for 
;	     Inputs  ________________________
;	     Outputs ________________________

J5837:	CP	'"'
	JR	NZ,J586F

;	  Subroutine generate code for constant string
;	     Inputs  ________________________
;	     Outputs ________________________

C583B:	CALL	C6058			; copy code block in execution buffer

J583E:	JP	J583E			; dummy for jump over string
	RST	38H			; dummy for size of string
	DEFW	0

	LD	HL,(BUF+2)		; current compiled code pointer
	PUSH	HL
	LD	E,0
J584A:	LD	A,(IX+0)
	AND	A			; end of line ?
	JR	Z,J585C			; yep,
	INC	IX
	CP	'"'			; end of string ?
	JR	Z,J585C			; yep,
	CALL	C60B9			; put byte in execution buffer
	INC	E
	JR	J584A

J585C:	POP	HL
	DEC	HL
	LD	(HL),E			; size of string
	LD	DE,(BUF+2)		; current compiled code pointer
	DEC	HL
	DEC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; jump over string
	INC	HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	LD	B,4			; result = generated string
	RET

J586F:	CP	"A"
	JP	C,J5920
	CP	"Z"+1
	JP	NC,J5920
	DEC	IX
	CALL	C6503			; fetch variable name
	CP	"("			; array index indicator ?
	JR	Z,J58A4			; yep,
	BIT	5,H			; string variable ?
	JR	NZ,J5899		; yep,
	BIT	6,H			; float variable ?
	LD	B,1
	RET	Z			; nope, return fetch from variable
	LD	C,0AH			; generate fetch code
	CALL	C62E7			; create simple variable if needed, generate variable address code
	CALL	C6058			; copy code block in execution buffer

	LD	B,A
	DEFW	0

	LD	B,3			; result = generated float
	RET

J5899:	LD	A,21H			; LD HL,xxxx
	CALL	C60B9			; put byte in execution buffer
	CALL	C62E7			; create simple variable if needed, generate variable address code
	LD	B,4			; result = generated string
	RET

J58A4:	INC	IX
	CALL	C59FC			; fetch index
	BIT	5,A			; string array ?
	JP	NZ,J5904		; yep,
	BIT	6,A			; float array ?
	JR	NZ,J58D1		; yep,
	INC	B
	DJNZ	J58BF

; B=0 (integer constant)

	ADD	HL,HL			; 2 bytes per element
	ADD	HL,DE
	LD	A,2AH			; LD HL,(xxxx)
	CALL	C60AB			; put 3 bytes in execution buffer
	LD	B,2			; result = generated integer
	RET

; B>0

J58BF:	EX	DE,HL
	CALL	C6079			; put LD DE,xxxx in execution buffer
	CALL	C6058			; copy code block in execution buffer

	ADD	HL,HL			; 2 bytes per element
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

J58D1:	INC	B
	DJNZ	J58ED

; B=0 (integer constant)

	LD	C,L
	LD	B,H
	ADD	HL,HL
	ADD	HL,BC			; 3 bytes per element
	ADD	HL,DE
	LD	A,3AH			; LD A,(xxxx)
	CALL	C60AB			; put 3 bytes in execution buffer
	LD	A,2AH			; LD HL,(xxxx)
	INC	HL
	CALL	C60AB			; put 3 bytes in execution buffer
	CALL	C6058			; copy code block in execution buffer

	LD	B,A
	DEFW	0

	LD	B,3			; result = generated float
	RET

; B>0

J58ED:	EX	DE,HL
	CALL	C6079			; put LD DE,xxxx in execution buffer
	CALL	C6058			; copy code block in execution buffer

	LD	C,L
	LD	B,H
	ADD	HL,HL
	ADD	HL,BC			; 3 bytes per element
	ADD	HL,DE
	LD	B,(HL)
	INC	HL
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	DEFW	0

	LD	B,3			; result = generated float
	RET

J5904:	INC	B
	DJNZ	J5910

; B=0 (integer constant)

	LD	H,L
	LD	L,0			; 256 bytes per element
	ADD	HL,DE
	LD	B,4			; result = generated string
	JP	C607E			; put LD HL,xxxx in execution buffer

; B=1 (variable)

J5910:	EX	DE,HL
	CALL	C6079			; put LD DE,xxxx in execution buffer
	CALL	C6058			; copy code block in execution buffer

	LD	H,L
	LD	L,0			; 256 bytes per element
	ADD	HL,DE
	DEFW	0

	LD	B,4			; result = generated string
	RET

J5920:	CP	0E0H			; NOT token ?
	JR	NZ,J594A		; nope,

; NOT

	CALL	C56EC			; evaluate factor
	CALL	C500B			; check for numeric
	CALL	C4FA0			; if load from variable, generate LD HL,(variable) code
	CALL	C4FEF			; convert to integer
	INC	B
	DJNZ	J593C

; B=0 (integer constant)

	LD	A,L
	CPL
	LD	L,A
	LD	A,H
	CPL
	LD	H,A
	LD	B,0			; result = integer constant
	RET

; B=2 (generated integer)

J593C:	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	CPL
	LD	L,A
	LD	A,H
	CPL
	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

J594A:	CP	0F2H			; - token ?
	JR	NZ,J597E		; nope,

; -

	CALL	C56EC			; evaluate factor
	CALL	C500B			; check for numeric
	CALL	C4FA0			; if load from variable, generate LD HL,(variable) code
	INC	B
	DJNZ	J5961

; B=0 (integer constant)

	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
	RET

J5961:	DEC	B
	DJNZ	J5972

; B=2 (generated integer)

	CALL	C6058			; copy code block in execution buffer

	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

; B=3 (generated float)

J5972:	CALL	C6058			; copy code block in execution buffer

	LD	A,H
	XOR	80H
	LD	H,A
	DEFW	0

	LD	B,3			; result = generated float
	RET

J597E:	CP	0CBH			; TIME token ?
	JR	NZ,J5995		; nope,

; TIME function

	LD	A,2AH
	LD	HL,JIFFY		; LD HL,(JIFFY)
	CALL	C60AB			; put 3 bytes in execution buffer
	CALL	C6058			; copy code block in execution buffer

	CALL	C78CD			; convert unsigned integer to float
	DEFW	0

	LD	B,3			; result = generated float
	RET

J5995:	CP	0ECH			; INKEY$ token ?
	JR	NZ,J59A4		; nope,

; INKEY$ function

	CALL	C6058			; copy code block in execution buffer

	CALL	C7F01			; inkey$ handler
	DEFW	0

	LD	B,4			; result = generated string
	RET

J59A4:	CP	0E8H			; CSRLIN token ?
	JR	NZ,J59B4		; nope,

; CSRLIN function

	CALL	C6058			; copy code block in execution buffer

	LD	HL,(CSRY)
	DEC	L
	DEFW	0

	JP	J5B91

J59B4:	CP	0E3H			; STRING$ token ?
	JP	Z,J6228
	CP	0E5H			; INSTR token ?
	JP	Z,J62A7
	CP	0E7H			; VARPTR token ?
	JP	Z,J5BD3
	CP	0DDH			; USR token ?
	JP	Z,J5C55
	CP	0C8H			; VDP token ?
	JP	Z,J6AAF
	CP	0EDH			; POINT token ?
	JP	Z,J6AA3
	CP	0C7H			; SPRITE token ?
	JP	Z,J691A
	CP	0FFH			; function token ?
	JR	NZ,J59F9		; nope,
	LD	A,(IX+0)
	INC	IX
	AND	A
	JP	P,J4E16			; BASIC error: syntax error
	CP	0A6H
	JP	NC,J4E16		; BASIC error: syntax error
	ADD	A,A
	LD	L,A
	LD	H,0
	LD	DE,I4F08
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	CALL	C6044			; check for BASIC character "("
	JP	(HL)

J59F9:	JP	J4E16			; BASIC error: syntax error

;	  Subroutine fetch index
;	     Inputs  ________________________
;	     Outputs ________________________

C59FC:	PUSH	HL
	CALL	C643B			; fetch address of array variable
	PUSH	DE
	LD	A,(DE)
	LD	B,A			; number of dimensions
	CALL	C5ACB			; get start of array (for actual data)
	LD	HL,BUF+28
	CALL	C5A7E			; get array subscript element
	DEC	B			; array with 1 dimension ?
	CALL	NZ,C5A50		; nope, get other subscripts elements
	SUB	")"			; end marker of subscripts ?
	JP	NZ,J4E25		; nope. BASIC error: subscript out of range
	LD	(HL),A			; end marker
	INC	HL
	LD	A,L
	LD	DE,BUF+27
	SUB	E			; size of subscript list
	LD	(DE),A
	LD	C,A
	LD	B,0
	EX	DE,HL
	DEC	DE
	LD	HL,-1
	ADD	HL,SP
	EX	DE,HL
	DI
	LDDR
	EX	DE,HL
	INC	HL
	EI
	LD	SP,HL			; copy subscript list on stack
	PUSH	IX			; save
	INC	HL
	PUSH	HL
	POP	IX			; IX = HL
	CALL	C4FE9			; evaluate numeric expression, convert to integer, generate code
	POP	IX
	LD	A,B			; save
	PUSH	HL
	POP	IY			; save HL in IY
	LD	HL,0
	ADD	HL,SP
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	LD	SP,HL			; remove subscript list from stack
	PUSH	IY
	POP	HL			; restore HL from IY
	LD	B,A
	POP	DE			; address of array variable
	CALL	C5ACB			; get start of array (for actual data)
	POP	AF			; dispose
	RET

;	  Subroutine get other subscripts elements
;	     Inputs  ________________________
;	     Outputs ________________________

C5A50:	LD	(HL),0F1H		; + token
	INC	HL
	LD	(HL),1CH		; integer token
	INC	HL
	INC	HL
	DEC	DE
	LD	A,(DE)
	LD	(HL),A			; high byte number of elements
	DEC	DE
	DEC	HL
	LD	A,(DE)
	LD	(HL),A			; low byte number of elements
	INC	HL
	INC	HL
	LD	(HL),0F3H		; * token
	INC	HL
	LD	(HL),'('
	INC	HL
	LD	(HL),'('
	INC	HL
	CALL	C5A7E			; get array subscript element
	LD	(HL),')'
	INC	HL
	DEC	B			; more dimensions left in definition ?
	JR	Z,J5A7A			; no, quit
	CP	","			; more subscript elements specified ?
	JP	NZ,J4E25		; nope, BASIC error: subscript out of range
	CALL	C5A50			; get other subscripts elements
J5A7A:	LD	(HL),')'
	INC	HL
	RET

;	  Subroutine get array subscript element
;	     Inputs  HL = buffer for array subscript element
;	     Outputs ________________________

C5A7E:	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	AND	A			; end of line ?
	JP	Z,J4E25			; yep, BASIC error: subscript out of range
	CP	","			; next subscript element ?
	RET	Z			; yep, quit
	CP	")"			; end of subscript ?
	RET	Z			; yep, quit
	LD	(HL),A
	INC	HL
	CP	20H			; special token ?
	JR	C,J5AA2			; yep, check
	CP	"("			; new level in subscript ?
	JR	NZ,C5A7E		; nope, next character
J5A97:	CALL	C5A7E			; get array subscript element
	LD	(HL),A
	INC	HL
	CP	")"			; end of level in subscript ?
	JR	NZ,J5A97		; nope, next array subscript element
	JR	C5A7E			; next character

J5AA2:	CP	0BH			; special number token ?
	JR	C,C5A7E			; nope, next character
	PUSH	BC
	CP	0FH			; byte integer ?
	LD	B,1			; 1 byte
	JR	Z,J5ABF			; yep, copy
	INC	B			; 2 bytes
	JR	C,J5ABF			; yep, copy
	CP	1BH
	JR	C,J5AC8
	SUB	1CH
	JR	Z,J5ABF			; integer, copy 2 bytes
	DEC	A
	LD	B,4
	JR	Z,J5ABF			; single real, copy 4 bytes
	LD	B,8			; double real, copy 8 bytes
J5ABF:	LD	A,(IX+0)
	LD	(HL),A
	INC	IX
	INC	HL
	DJNZ	J5ABF
J5AC8:	POP	BC
	JR	C5A7E			; next character

;	  Subroutine get start of array (for actual data)
;	     Inputs  ________________________
;	     Outputs ________________________

C5ACB:	LD	A,(DE)			; number of dimensions
	INC	DE			; skip number of dimensions
J5ACD:	INC	DE
	INC	DE			; skip number of elements in dimension
	DEC	A			; more dimensions ?
	RET	Z			; nope, quit
	JR	J5ACD			; next dimension

;	  Subroutine RND function
;	     Inputs  ________________________
;	     Outputs ________________________

C5AD3:	LD	HL,I768E		; rnd handler
	JR	J5AF9

;	  Subroutine EXP function
;	     Inputs  ________________________
;	     Outputs ________________________

C5AD8:	LD	HL,J7AA8		; exp handler
	JR	J5AF9

;	  Subroutine LOG function
;	     Inputs  ________________________
;	     Outputs ________________________

C5ADD:	LD	HL,C7B01		; log handler
	JR	J5AF9

;	  Subroutine SIN function
;	     Inputs  ________________________
;	     Outputs ________________________

C5AE2:	LD	HL,C79EA		; sin handler
	JR	J5AF9

;	  Subroutine COS function
;	     Inputs  ________________________
;	     Outputs ________________________

C5AE7:	LD	HL,C79E2		; cos handler
	JR	J5AF9

;	  Subroutine TAN function
;	     Inputs  ________________________
;	     Outputs ________________________

C5AEC:	LD	HL,I7A41		; tan handler
	JR	J5AF9

;	  Subroutine ATN function
;	     Inputs  ________________________
;	     Outputs ________________________

C5AF1:	LD	HL,I7A63		; atn handler
	JR	J5AF9

;	  Subroutine SQR function
;	     Inputs  ________________________
;	     Outputs ________________________

C5AF6:	LD	HL,I7B60		; sqr handler
J5AF9:	PUSH	HL
	CALL	C4FAE			; evaluate numeric expression, convert to float, generate code
	CALL	C6048			; check for BASIC character ")"
	POP	HL
	JP	J53EE			; generate CALL xxxx (xxxx is in HL)

;	  Subroutine INT function
;	     Inputs  ________________________
;	     Outputs ________________________

C5B04:	CALL	C4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C6048			; check for BASIC character ")"
	LD	A,B
	CP	2			; generated integer ?
	RET	Z			; yep, quit
	CALL	C6058			; copy code block in execution buffer

	CALL	C7999			; INT handler
	DEFW	0

	RET

;	  Subroutine FIX function
;	     Inputs  ________________________
;	     Outputs ________________________

C5B17:	CALL	C4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C6048			; check for BASIC character ")"
	LD	A,B
	CP	2			; generated integer ?
	RET	Z			; yep, quit
	CALL	C6058			; copy code block in execution buffer

	CALL	C798C			; FIX handler
	DEFW	0

	RET

;	  Subroutine ABS function
;	     Inputs  ________________________
;	     Outputs ________________________

C5B2A:	CALL	C4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C6048			; check for BASIC character ")"
	LD	A,B
	CP	2			; generated integer ?
	JR	NZ,J5B47		; nope,
	CALL	C6058			; copy code block in execution buffer

	LD	A,H
	ADD	A,A
	JR	NC,J5B42
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
J5B42:	DEFW	0

	LD	B,2			; result = generated integer
	RET

J5B47:	CALL	C6058			; copy code block in execution buffer

	RES	7,H
	DEFW	0

	LD	B,3			; result = generated float
	RET

;	  Subroutine SGN function
;	     Inputs  ________________________
;	     Outputs ________________________

C5B51:	CALL	C4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C6048			; check for BASIC character ")"
	LD	A,B
	CP	2			; generated integer ?
	JR	NZ,J5B71		; nope,
	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	OR	H
	JR	Z,J5B6C
	BIT	7,H
	LD	HL,-1
	JR	NZ,J5B6C
	INC	HL
	INC	HL
J5B6C:	DEFW	0

	LD	B,2			; result = generated integer
	RET

J5B71:	CALL	C6058			; copy code block in execution buffer

	LD	A,B
	AND	A
	JR	Z,J5B80
	LD	B,81H
	LD	L,0
	LD	A,H
	AND	80H
	LD	H,A			; 1 or -1
J5B80:	DEFW	0

	LD	B,3			; result = generated float
	RET

;	  Subroutine PEEK function
;	     Inputs  ________________________
;	     Outputs ________________________

C5B85:	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	LD	L,(HL)
	DEFW	0

J5B91:	CALL	C6058			; copy code block in execution buffer

	LD	H,0
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine INP function
;	     Inputs  ________________________
;	     Outputs ________________________

C5B9B:	CALL	C4FA9			; evaluate integer operand
	CALL	C6048			; check for BASIC character ")"
	INC	B
	DJNZ	J5BB5
	LD	A,0DBH			; IN A,(xx)
	CALL	C60B9			; put byte in execution buffer
	LD	A,L
	CALL	C60B9			; put byte in execution buffer
J5BAD:	CALL	C6058			; copy code block in execution buffer

	LD	L,A
	DEFW	0

	JR	J5B91

J5BB5:	DJNZ	J5BC4
	PUSH	HL
	LD	HL,4BEDH		; LD BC,(xxxx)
	CALL	C60AE			; put word in execution buffer
	POP	HL
	CALL	C62E7			; create simple variable if needed, generate variable address code
	JR	J5BCA

J5BC4:	CALL	C6058			; copy code block in execution buffer

	LD	C,L
	DEFW	0

J5BCA:	CALL	C6058			; copy code block in execution buffer

	IN	L,(C)
	DEFW	0

	JR	J5B91

; VARPTR function

J5BD3:	CALL	C6044			; check for BASIC character "("
	CALL	C5BDE			; VARPTR handler
	LD	B,2			; result = generated integer
	JP	C6048			; check for BASIC character ")"

;	  Subroutine VARPTR handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5BDE:	CALL	C5BF3			; fetch variable name or index variable name with index
	PUSH	AF
	CALL	C4FE0			; if constant, compile LD HL,xxxx
	DJNZ	J5BF1

; B=1, variable

	LD	A,21H			; LD HL,xxxx
	CALL	C60B9			; put byte in execution buffer
	LD	C,0			; generate address
	CALL	C62E7			; create simple variable if needed, generate variable address code

; B>1, generated integer (array with a variable index)

J5BF1:	POP	AF
	RET

;	  Subroutine fetch variable name or index variable name with index
;	     Inputs  ________________________
;	     Outputs ________________________

C5BF3:	CALL	C6503			; fetch variable name
	CP	"("			; array index indicator ?
	JR	Z,J5C00			; yep,
	LD	B,1			; fetch from variable
	LD	A,H
	AND	60H			; A = variable type
	RET

J5C00:	INC	IX
	PUSH	HL
	CALL	C5C0A			; fetch index and calculate or compile code pointer
	POP	AF
	AND	60H			; A = variable type
	RET

;	  Subroutine fetch index and calculate or compile code pointer
;	     Inputs  ________________________
;	     Outputs ________________________

C5C0A:	CALL	C59FC			; fetch index
	INC	B
	DJNZ	J5C25

; array index a constant

	BIT	5,A			; string variable ?
	JR	NZ,J5C1E		; yep,
	LD	C,L
	LD	B,H
	ADD	HL,HL			; assume integer, 2 bytes per element
	BIT	6,A			; float variable ?
	JR	Z,J5C21			; nope, it is an integer
	ADD	HL,BC			; float has 3 bytes per element
	JR	J5C21

J5C1E:	LD	H,L
	LD	L,0			; 256 bytes per element
J5C21:	ADD	HL,DE
	LD	B,0			; result = constant
	RET

; array index not a constant

J5C25:	BIT	5,A			; string variable ?
	JR	NZ,J5C40		; yep,
	BIT	6,A			; float variable ?
	JR	Z,J5C38			; nope,
	CALL	C6058			; copy code block in execution buffer

	LD	C,L
	LD	B,H
	ADD	HL,HL
	ADD	HL,BC			; 3 bytes per element
	DEFW	0

	JR	J5C48

J5C38:	CALL	C6058			; copy code block in execution buffer

	ADD	HL,HL			; 2 bytes per element
	DEFW	0

	JR	J5C48

J5C40:	CALL	C6058			; copy code block in execution buffer

	LD	H,L
	LD	L,0			; 256 bytes per element
	DEFW	0

J5C48:	EX	DE,HL
	CALL	C6079			; put LD DE,xxxx in execution buffer
	CALL	C6058			; copy code block in execution buffer

	ADD	HL,DE
	DEFW	0

	LD	B,2			; result = generated integer
	RET

; USR function

J5C55:	CALL	C6032			; get BASIC character (skip spaces)
	LD	C,0
	SUB	11H
	JR	C,J5C65
	CP	9+1
	JR	NC,J5C65
	LD	C,A
	INC	IX
J5C65:	CALL	C6044			; check for BASIC character "("
	PUSH	BC
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	POP	BC
	CALL	C6048			; check for BASIC character ")"
	LD	HL,5BEDH		; LD DE,(xxxx)
	CALL	C60AE			; put word in execution buffer
	LD	HL,USRTAB
	LD	B,0
	ADD	HL,BC
	ADD	HL,BC
	CALL	C60AE			; put word in execution buffer
	CALL	C6058			; copy code block in execution buffer

	CALL	C6C0B			; put in DAC, execute routine DE (USR routine), get result from DAC
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine POS function
;	     Inputs  ________________________
;	     Outputs ________________________

C5C8B:	LD	HL,TTYPOS
	JR	J5C93

;	  Subroutine LPOS function
;	     Inputs  ________________________
;	     Outputs ________________________

C5C90:	LD	HL,LPTPOS
J5C93:	PUSH	HL
	CALL	C5012			; evaluate expression (dummy parameter)
	CALL	C6048			; check for BASIC character ")"
	POP	HL
	LD	A,2AH			; LD HL,(xxxx)
	CALL	C60AB			; put 3 bytes in execution buffer
	JP	J5B91

;	  Subroutine STICK function
;	     Inputs  ________________________
;	     Outputs ________________________

C5CA3:	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	CALL	GTSTCK
	DEFW	0

	JP	J5BAD

;	  Subroutine TRIG function
;	     Inputs  ________________________
;	     Outputs ________________________

C5CB4:	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	CALL	GTTRIG
	LD	L,A
	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine PAD function
;	     Inputs  ________________________
;	     Outputs ________________________

C5CC7:	CALL	C4FA9			; evaluate integer operand
	CALL	C6048			; check for BASIC character ")"
	INC	B
	DJNZ	J5CF4

; parameter is a constant

	PUSH	HL
	CALL	C4F5A			; generate LD A,constant code
	CALL	C6058			; copy code block in execution buffer

	CALL	GTPAD
	DEFW	0

	POP	HL
	LD	A,L
	ADD	A,04H
	AND	0F3H
	DEC	A
	CP	2
	JP	C,J5BAD
	CALL	C6058			; copy code block in execution buffer

	LD	L,A
	ADD	A,A
	SBC	A,A
	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

; parameter is not a constant

J5CF4:	CALL	C4F73			; generate LD A,non constant
	CALL	C6058			; copy code block in execution buffer

	PUSH	AF
	CALL	GTPAD
	LD	L,A
	LD	H,0
	POP	AF
	ADD	A,04H
	AND	0F3H
	DEC	A
	CP	2
	JR	C,J5D0F
	LD	A,L
	ADD	A,A
	SBC	A,A
	LD	H,A
J5D0F:	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine PDL function
;	     Inputs  ________________________
;	     Outputs ________________________

C5D14:	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	CALL	GTPDL
	DEFW	0

	JP	J5BAD

;	  Subroutine generate logical operation code
;	     Inputs  B = operand1 type, DE = operand2 handler
;	     Outputs ________________________

C5D25:	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C5D49			; integer constant, integer constant
	DEFW	C5D7C			; integer constant, variable
	DEFW	C5D81			; integer constant, generated integer
	DEFW	C5D7D			; variable, integer constant
	DEFW	C5E32			; variable, variable
	DEFW	C5E35			; variable, generated integer
	DEFW	C5D82			; generated integer, integer constant
	DEFW	C5E36			; generated integer, variable
	DEFW	C5E3B			; generated integer, generated integer
	DEFW	C5D68			; integer constant, generated float
	DEFW	C5DFE			; variable, generated float
	DEFW	C5E08			; generated integer, generated float
	DEFW	C5D72			; generated float, integer constant
	DEFW	C5E12			; generated float, variable
	DEFW	C5E24			; generated float, generated integer
	DEFW	C5E1C			; generated float, generated float

	RET

;	  Subroutine generate logical operation code, integer constant, integer constant
;	     Inputs  DE = integer constant (param1), HL = integer constant (param2), A = logical operator code
;	     Outputs ________________________

C5D49:	OR	0E6H			; Z80 opcode AND/OR/XOR xx
	LD	(BUF+9),A
	LD	A,0C9H			; RET
	LD	(BUF+11),A
	LD	A,E
	LD	(BUF+10),A		; xx = low byte param1
	LD	A,L			; low byte param2
	CALL	BUF+9			; execute logical operation
	LD	L,A
	LD	A,D
	LD	(BUF+10),A		; xx = high byte param1
	LD	A,H			; high byte param2
	CALL	BUF+9			; execute logical operation
	LD	H,A
	LD	B,0			; integer constant
	RET

;	  Subroutine generate logical operation code, integer constant, generated float
;	     Inputs  DE = integer constant, A = logical operator code
;	     Outputs ________________________

C5D68:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	DEFW	0

	JR	C5D81

;	  Subroutine generate logical operation code, generated float, integer constant
;	     Inputs  HL = integer constant, A = logical operator code
;	     Outputs ________________________

C5D72:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	DEFW	0

	JR	C5D82

;	  Subroutine generate logical operation code, integer constant, variable
;	     Inputs  DE = integer constant, DE = variable id, A = logical operator code
;	     Outputs ________________________

C5D7C:	EX	DE,HL

;	  Subroutine generate logical operation code, variable, integer constant
;	     Inputs  DE = variable id, HL = integer constant, A = logical operator code
;	     Outputs ________________________

C5D7D:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer

;	  Subroutine generate logical operation code, integer constant, generated integer
;	     Inputs  DE = integer constant (param1), A = logical operator code
;	     Outputs ________________________

C5D81:	EX	DE,HL

;	  Subroutine generate logical operation code, generated integer, integer constant
;	     Inputs  HL = integer constant (param2), A = logical operator code
;	     Outputs ________________________

C5D82:	OR	0E6H
	LD	B,A			; Z80 opcode AND xx, XOR xx, AND xx
	LD	A,L			; low byte
	CALL	C5E64			; AND 0FFH, OR 000H, XOR 000H ?
	JR	Z,J5DC0			; yep, skip to high byte (because low byte result = low byte param1)
	LD	A,L			; low byte
	CALL	C5E74			; XOR 0FFH ?
	JR	NZ,J5D9B		; nope, skip optimizer

; optimized code for XOR 0FFH

	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	CPL
	LD	L,A			; optimized code for XOR 0FFH
	DEFW	0

	JR	J5DC0			; to high byte

J5D9B:	LD	A,L			; low byte
	CALL	C5E7A			; AND 000H, OR 0FFH ?
	JR	NZ,J5DAC		; nope, use normal operation code

; optimized code for AND 000H, OR 0FFH

	LD	A,2EH			; Z80 opcode LD L,xx
	CALL	C60B9			; put byte in execution buffer
	LD	A,L			; AND 000H -> 000H, OR 0FFH -> 0FFH
	CALL	C60B9			; put byte in execution buffer
	JR	J5DC0			; to high byte

; normal code

J5DAC:	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

	LD	A,B			; Z80 opcode logical operation
	CALL	C60B9			; put byte in execution buffer
	LD	A,L			; low byte integer constant (param2)
	CALL	C60B9			; put byte in execution buffer
	CALL	C6058			; copy code block in execution buffer

	LD	L,A
	DEFW	0

J5DC0:	LD	A,H			; high byte
	CALL	C5E64			; AND 0FFH, OR 000H, XOR 000H ?
	JR	Z,J5DFB			; yep, skip to end (because high byte result = high byte param1)
	LD	A,H			; high byte
	CALL	C5E74			; XOR 0FFH ?
	JR	NZ,J5DD6		; nope, skip optimizer

; optimized code for XOR 0FFH

	CALL	C6058			; copy code block in execution buffer

	LD	A,H
	CPL
	LD	H,A			; optimize code for XOR 0FFH
	DEFW	0

	JR	J5DFB			; to end

J5DD6:	LD	A,H
	CALL	C5E7A			; AND 000H, OR 0FFH ?
	JR	NZ,J5DE7		; nope,

; optimized code for AND 000H, OR 0FFH

	LD	A,26H			; Z80 opcode LD H,xx
	CALL	C60B9			; put byte in execution buffer
	LD	A,H			; AND 000H -> 000H, OR 0FFH -> 0FFH
	CALL	C60B9			; put byte in execution buffer
	JR	J5DFB			; to end


; normal code

J5DE7:	CALL	C6058			; copy code block in execution buffer

	LD	A,H
	DEFW	0

	LD	A,B			; Z80 opcode logical operation
	CALL	C60B9			; put byte in execution buffer
	LD	A,H			; high byte integer constant (param2)
	CALL	C60B9			; put byte in execution buffer
	CALL	C6058			; copy code block in execution buffer

	LD	H,A
	DEFW	0

J5DFB:	LD	B,2			; result = generated integer
	RET

;	  Subroutine generate logical operation code, variable, generated float
;	     Inputs  DE = variable id, A = logical operator code
;	     Outputs ________________________

C5DFE:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	DEFW	0

	JR	C5E35

;	  Subroutine generate logical operation code, generated integer, generated float
;	     Inputs  A = logical operator code
;	     Outputs ________________________

C5E08:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	DEFW	0

	JR	C5E3B

;	  Subroutine generate logical operation code, generated float, variable
;	     Inputs  HL = variable id, A = logical operator code
;	     Outputs ________________________

C5E12:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	DEFW	0

	JR	C5E36

;	  Subroutine generate logical operation code, generated float, generated float
;	     Inputs  A = logical operator code
;	     Outputs ________________________

C5E1C:	CALL	C6058			; copy code block in execution buffer

	CALL	C7901			; convert float to integer
	DEFW	0

;	  Subroutine generate logical operation code, generated float, generated integer
;	     Inputs  A = logical operator code
;	     Outputs ________________________

C5E24:	CALL	C6058			; copy code block in execution buffer

	POP	BC
	POP	DE
	PUSH	HL
	EX	DE,HL
	CALL	C7901			; convert float to integer
	DEFW	0

	JR	C5E3B

;	  Subroutine generate logical operation code, variable, variable
;	     Inputs  DE = variable id, HL = variable id, A = logical operator code
;	     Outputs ________________________

C5E32:	CALL	C6086			; put LD HL,(var) in execution buffer

;	  Subroutine generate logical operation code, variable, generated integer
;	     Inputs  DE = variable id, A = logical operator code
;	     Outputs ________________________

C5E35:	EX	DE,HL

;	  Subroutine generate logical operation code, generated integer, variable
;	     Inputs  HL = variable id, A = logical operator code
;	     Outputs ________________________

C5E36:	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J5E41

;	  Subroutine generate logical operation code, generated integer, generated integer
;	     Inputs  A = logical operator code
;	     Outputs ________________________

C5E3B:	CALL	C6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

J5E41:	LD	B,A			; save logical operator code
	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

	LD	A,B			; restore logical operator code
	OR	0A3H			; Z80 opcode AND/XOR/OR E
	CALL	C60B9			; put byte in execution buffer
	CALL	C6058			; copy code block in execution buffer

	LD	L,A
	LD	A,H
	DEFW	0

	LD	A,B			; restore logical operator code
	OR	0A2H			; Z80 opcode AND/XOR/OR D
	CALL	C60B9			; put byte in execution buffer
	CALL	C6058			; copy code block in execution buffer

	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine AND 0FFH, OR 000H, XOR 000H ?
;	     Inputs  ________________________
;	     Outputs Zx set if byte does not effect result

C5E64:	AND	A			; A=0 ?
	JR	Z,J5E6D			; yep,
	INC	A			; A=FFH ?
	RET	NZ			; nope, quit
	LD	A,B
	CP	0E6H			; AND ?
	RET

J5E6D:	LD	A,B
	CP	0F6H			; OR ?
	RET	Z			; yep, quit
	CP	0EEH			; XOR ?
	RET

;	  Subroutine XOR 0FFH ?
;	     Inputs  ________________________
;	     Outputs ________________________

C5E74:	INC	A			; A=0FFH ?
	RET	NZ			; nope, quit
	LD	A,B
	CP	0EEH			; XOR ?
	RET

;	  Subroutine AND 000H, OR 0FFH ?
;	     Inputs  ________________________
;	     Outputs ________________________

C5E7A:	AND	A			; A=0 ?
	JR	Z,J5E83			; yep,
	INC	A			; A=0FFH ?
	RET	NZ			; nope, quit
	LD	A,B
	CP	0F6H			; OR ?
	RET

J5E83:	LD	A,B
	CP	0E6H			; AND ?
	RET

;	  Subroutine numeric compare
;	     Inputs  DE = operand2 handler
;	     Outputs ________________________

C5E87:	PUSH	HL
	PUSH	BC
	PUSH	AF
	LD	C,A
	LD	B,0
	LD	HL,I50D0
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	PUSH	BC
	POP	IY			; auxilair handler (used in operator handler) = compare handler
	POP	AF
	POP	BC
	POP	HL
	CALL	C5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C5EC0			; integer constant, integer constant
	DEFW	C5EC5			; integer constant, variable
	DEFW	C5EC8			; integer constant, generated integer
	DEFW	C5ECE			; variable, integer constant
	DEFW	C5ED5			; variable, variable
	DEFW	C5ED8			; variable, generated integer
	DEFW	C5EDE			; generated integer, integer constant
	DEFW	C5EE3			; generated integer, variable
	DEFW	C5EE8			; generated integer, generated integer
	DEFW	C60E1			; integer constant, generated float
	DEFW	C60F1			; variable, generated float
	DEFW	C60FE			; generated integer, generated float
	DEFW	C6109			; generated float, integer constant
	DEFW	C612B			; generated float, variable
	DEFW	C612E			; generated float, generated integer
	DEFW	C6131			; generated float, generated float
	
	LD	B,2			; result = generated integer
	RET

;	  Subroutine numeric compare, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5EC0:	CALL	C607E			; put LD HL,xxxx in execution buffer
	JR	C5EC8

;	  Subroutine numeric compare, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5EC5:	CALL	C6086			; put LD HL,(var) in execution buffer

;	  Subroutine numeric compare, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C5EC8:	EX	DE,HL
	CALL	C6079			; put LD DE,xxxx in execution buffer
	JR	J5EEE

;	  Subroutine numeric compare, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5ECE:	EX	DE,HL
	CALL	C6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C5EDE

;	  Subroutine numeric compare, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5ED5:	CALL	C6086			; put LD HL,(var) in execution buffer

;	  Subroutine numeric compare, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C5ED8:	EX	DE,HL
	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J5EEE

;	  Subroutine numeric compare, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C5EDE:	CALL	C6079			; put LD DE,xxxx in execution buffer
	JR	J5EEF

;	  Subroutine numeric compare, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C5EE3:	CALL	C6096			; put LD DE,(var) in execution buffer
	JR	J5EEF

;	  Subroutine numeric compare, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C5EE8:	CALL	C6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

J5EEE:	INC	A
J5EEF:	ADD	A,A
	LD	L,A
	LD	H,0
	LD	DE,I50B4
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
J5EFB:	LD	A,(HL)
	AND	A
	RET	Z
	CALL	C60B9			; put byte in execution buffer
	INC	HL
	JR	J5EFB

;	  Subroutine invoke operator handler based on operand1 and operand2 type
;	     Inputs  B = operand1 type, DE = operand2 handler
;	     Outputs ________________________

C5F04:	INC	IX
	INC	B
	DJNZ	J5F4A

; first argument = integer constant

	PUSH	HL
	PUSH	AF
	PUSH	IY
	CALL	C6030			; call DE
	CALL	C500B			; check for numeric
	POP	IY
	POP	AF
	POP	DE
	INC	B
	DJNZ	J5F25

; first argument = integer constant, second argument = integer constant

	EX	(SP),IY
	LD	C,(IY+0)
	LD	B,(IY+1)
	JP	J6020

J5F25:	DJNZ	J5F32

; first argument = integer constant, second argument = variable

	EX	(SP),IY
	LD	C,(IY+2)
	LD	B,(IY+3)
	JP	J6020

J5F32:	DJNZ	J5F3F

; first argument = integer constant, second argument = generated integer

	EX	(SP),IY
	LD	C,(IY+4)
	LD	B,(IY+5)
	JP	J6020

; first argument = integer constant, second argument = generated float

J5F3F:	EX	(SP),IY
	LD	C,(IY+18)
	LD	B,(IY+19)
	JP	J6020

J5F4A:	DJNZ	J5F8D

; first argument = variable

	PUSH	HL
	PUSH	AF
	PUSH	IY
	CALL	C6030			; call DE
	CALL	C500B			; check for numeric
	POP	IY
	POP	AF
	POP	DE
	INC	B
	DJNZ	J5F68

; first argument = variable, second argument = integer constant

	EX	(SP),IY
	LD	C,(IY+6)
	LD	B,(IY+7)
	JP	J6020

J5F68:	DJNZ	J5F75

; first argument = variable, second argument = variable

	EX	(SP),IY
	LD	C,(IY+8)
	LD	B,(IY+9)
	JP	J6020

J5F75:	DJNZ	J5F82

; first argument = variable, second argument = generated integer

	EX	(SP),IY
	LD	C,(IY+10)
	LD	B,(IY+11)
	JP	J6020

; first argument = variable, second argument = generated float

J5F82:	EX	(SP),IY
	LD	C,(IY+20)
	LD	B,(IY+21)
	JP	J6020

J5F8D:	DJNZ	J5FD6

; first argument = generated integer

	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	PUSH	AF
	PUSH	IY
	CALL	C6030			; call DE
	CALL	C500B			; check for numeric
	POP	IY
	POP	AF
	INC	B
	DJNZ	J5FB1

; first argument = generated integer, second argument = integer constant

	CALL	C60D7			; remove byte from execution buffer
	EX	(SP),IY
	LD	C,(IY+12)
	LD	B,(IY+13)
	JR	J6020

J5FB1:	DJNZ	J5FC0

; first argument = generated integer, second argument = variable

	CALL	C60D7			; remove byte from execution buffer
	EX	(SP),IY
	LD	C,(IY+14)
	LD	B,(IY+15)
	JR	J6020

J5FC0:	DJNZ	J5FCC

; first argument = generated integer, second argument = generated integer

	EX	(SP),IY
	LD	C,(IY+16)
	LD	B,(IY+17)
	JR	J6020

; first argument = generated integer, second argument = generated float

J5FCC:	EX	(SP),IY
	LD	C,(IY+22)
	LD	B,(IY+23)
	JR	J6020

J5FD6:	DEC	B
	JP	NZ,J4E10		; BASIC error: type mismatch

; first argument = generated float

	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	PUSH	BC
	DEFW	0

	PUSH	AF
	PUSH	IY
	CALL	C6030			; call DE
	CALL	C500B			; check for numeric
	POP	IY
	POP	AF
	INC	B
	DJNZ	J6000

; first argument = generated float, second argument = integer constant

	CALL	C60D7			; remove byte from execution buffer
	CALL	C60D7			; remove byte from execution buffer
	EX	(SP),IY
	LD	C,(IY+24)
	LD	B,(IY+25)
	JR	J6020

J6000:	DJNZ	J600C

; first argument = generated float, second argument = variable

	EX	(SP),IY
	LD	C,(IY+26)
	LD	B,(IY+27)
	JR	J6020

J600C:	DJNZ	J6018

; first argument = generated float, second argument = generated integer

	EX	(SP),IY
	LD	C,(IY+28)
	LD	B,(IY+29)
	JR	J6020

; first argument = generated float, second argument = generated float

J6018:	EX	(SP),IY
	LD	C,(IY+30)
	LD	B,(IY+31)

J6020:	EX	(SP),IY
	CALL	C602E			; call BC
	EX	(SP),HL
	PUSH	DE
	LD	DE,32
	ADD	HL,DE
	POP	DE
	EX	(SP),HL			; skip over table
	RET

;	  Subroutine call BC
;	     Inputs  ________________________
;	     Outputs ________________________

C602E:	PUSH	BC
	RET

;	  Subroutine call DE
;	     Inputs  ________________________
;	     Outputs ________________________

C6030:	PUSH	DE
	RET

;	  Subroutine get BASIC character, skip spaces
;	     Inputs  ________________________
;	     Outputs ________________________

C6032:	LD	A,(IX+0)
	CP	" "
	RET	NZ
	INC	IX
	JR	C6032

;	  Subroutine check for BASIC token =
;	     Inputs  ________________________
;	     Outputs ________________________

C603C:	LD	A,0EFH			; = token
	JR	C604A			; check for BASIC character

;	  Subroutine check for BASIC character ","
;	     Inputs  ________________________
;	     Outputs ________________________

C6040:	LD	A,","
	JR	C604A			; check for BASIC character

;	  Subroutine check for BASIC character "("
;	     Inputs  ________________________
;	     Outputs ________________________

C6044:	LD	A,"("
	JR	C604A			; check for BASIC character

;	  Subroutine check for BASIC character ")"
;	     Inputs  ________________________
;	     Outputs ________________________

C6048:	LD	A,")"

;	  Subroutine check for BASIC character
;	     Inputs  ________________________
;	     Outputs ________________________

C604A:	PUSH	AF
	CALL	C6032			; get BASIC character (skip spaces)
	POP	AF
	CP	(IX+0)
	JP	NZ,J4E16		; BASIC error: syntax error
	INC	IX
	RET

;	  Subroutine copy code block in execution buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C6058:	EX	(SP),IX
	PUSH	AF
J605B:	LD	A,(IX+0)
	INC	IX
	AND	A
	JR	Z,J6068
J6063:	CALL	C60B9			; put byte in execution buffer
	JR	J605B

J6068:	XOR	A
	CP	(IX+0)
	JR	NZ,J6063
	CP	(IX+1)
	JR	Z,J6063
	INC	IX
	POP	AF
	EX	(SP),IX
	RET

;	  Subroutine put LD DE,xxxx in execution buffer
;	     Inputs  HL = xxxx
;	     Outputs ________________________

C6079:	PUSH	AF
	LD	A,11H			; LD DE,xxxx
	JR	J6081

;	  Subroutine put LD HL,xxxx in execution buffer
;	     Inputs  HL = xxxx
;	     Outputs ________________________

C607E:	PUSH	AF
	LD	A,21H			; LD HL,xxxx
J6081:	CALL	C60AB			; put 3 bytes in execution buffer
	POP	AF
	RET

;	  Subroutine put LD HL,(var) in execution buffer
;	     Inputs  HL = var
;	     Outputs ________________________

C6086:	PUSH	AF
	LD	A,2AH			; LD HL,(xxxx)
	JR	J608E

;	  Subroutine put LD (var),HL in execution buffer (AF retained)
;	     Inputs  HL = var
;	     Outputs ________________________

C608B:	PUSH	AF
	LD	A,22H			; LD (xxxx),HL
J608E:	CALL	C60B9			; put byte in execution buffer
	CALL	C62E7			; create simple variable if needed, generate variable address code
	POP	AF
	RET

;	  Subroutine put LD DE,(var) in execution buffer
;	     Inputs  HL = var
;	     Outputs ________________________

C6096:	PUSH	AF
	PUSH	HL
	LD	HL,5BEDH		; LD DE,(xxxx)
	JR	J60A2

;	  Subroutine put LD (var),DE in execution buffer
;	     Inputs  HL = var
;	     Outputs ________________________

?609D:	PUSH	AF
	PUSH	HL
	LD	HL,53EDH		; LD (xxxx),DE
J60A2:	CALL	C60AE			; put word in execution buffer
	POP	HL
	CALL	C62E7			; create simple variable if needed, generate variable address code
	POP	AF
	RET

;	  Subroutine put 3 bytes in execution buffer
;	     Inputs  A = byte1, H = byte2, L = byte3
;	     Outputs ________________________

C60AB:	CALL	C60B9			; put byte in execution buffer

;	  Subroutine put word in execution buffer
;	     Inputs  HL = word
;	     Outputs ________________________

C60AE:	PUSH	AF
	LD	A,L
	CALL	C60B9			; put byte in execution buffer
	LD	A,H
	CALL	C60B9			; put byte in execution buffer
	POP	AF
	RET

;	  Subroutine put byte in execution buffer
;	     Inputs  A = byte
;	     Outputs ________________________

C60B9:	PUSH	HL
	LD	HL,(BUF+2)		; current compiled code pointer
	PUSH	HL
	PUSH	DE
	LD	DE,(BUF+23)		; end of variable list
	AND	A
	SBC	HL,DE
	POP	DE
	POP	HL
	JP	NC,J4E1F		; BASIC error: out of memory
	LD	(HL),A
	INC	HL
	LD	(BUF+2),HL		; update current compiled code pointer
	LD	HL,BUF+4
	LD	(HL),1			; bytes in the execution buffer
	POP	HL
	RET

;	  Subroutine remove byte from execution buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C60D7:	PUSH	HL
	LD	HL,(BUF+2)		; current compiled code pointer
	DEC	HL
	LD	(BUF+2),HL		; update current compiled code pointer
	POP	HL
	RET

;	  Subroutine generic handler, integer constant, generated float
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C60E1:	CALL	C6058			; copy code block in execution buffer

	EX	DE,HL
	LD	C,B
	DEFW	0

	EX	DE,HL
	CALL	C78DF			; convert integer to float
	CALL	C4FCA			; generate load float code
	JR	J613B			; generate CALL operator handler and quit

;	  Subroutine generic handler, variable, generated float
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C60F1:	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	PUSH	BC
	DEFW	0

	EX	DE,HL
	CALL	C6086			; put LD HL,(xxxx) in execution buffer
	JR	C611E

;	  Subroutine generic handler, generated integer, generated float
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C60FE:	CALL	C6058			; copy code block in execution buffer

	POP	DE
	PUSH	HL
	PUSH	BC
	EX	DE,HL
	DEFW	0

	JR	C611E

;	  Subroutine generic handler, generated float, integer constant
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C6109:	CALL	C78DF			; convert integer to float
	LD	A,0EH			; LD C,xx
	CALL	C60B9			; put byte in execution buffer
	LD	A,B
	CALL	C60B9			; put byte in execution buffer
	AND	A
	CALL	NZ,C6079		; yep, put LD DE,xxxx in execution buffer
	JR	J613B			; generate CALL operator handler and quit


C611B:	CALL	C6086			; put LD HL,(xxxx) in execution buffer
C611E:	CALL	C6140			; generate convert integer to float code
C6121:	CALL	C6058			; copy code block in execution buffer

	POP	AF
	LD	C,A
	POP	DE
	DEFW	0

	JR	J613B			; generate CALL operator handler and quit

;	  Subroutine generic handler, generated float, variable
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C612B:	CALL	C6086			; put LD HL,(xxxx) in execution buffer

;	  Subroutine generic handler, generated float, generated integer
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C612E:	CALL	C6140			; generate convert integer to float code

;	  Subroutine generic handler, generated float, generated float
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C6131:	CALL	C6058			; copy code block in execution buffer

	LD	C,B
	EX	DE,HL
	POP	AF
	LD	B,A
	POP	HL
	DEFW	0


J613B:	LD	B,3			; result = generated float
	JP	J53EB			; generate CALL operator handler

;	  Subroutine generate convert integer to float code
;	     Inputs  ________________________
;	     Outputs ________________________

C6140:	CALL	C6058			; copy code block in execution buffer

	CALL	C78DF			; convert integer to float
	DEFW	0

	RET

;	  Subroutine LEFT$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C6149:	LD	HL,I7E42		; left of string handler
	JR	J6151

;	  Subroutine RIGHT$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C614E:	LD	HL,I7E49		; right of string handler
J6151:	PUSH	HL
	CALL	C4FFE			; evaluate string expression
	CALL	C6040			; check for BASIC character ","
	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	POP	HL
	DEFW	0

	POP	HL
	LD	A,0CDH			; CALL xxxx
	CALL	C60AB			; put 3 bytes in execution buffer
	LD	B,4			; result = generated string
	RET

;	  Subroutine MID$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C6173:	CALL	C4FFE			; evaluate string expression
	CALL	C6040			; check for BASIC character ","
	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J619F
	INC	IX
	CALL	C6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	POP	BC
	DEFW	0

	JR	J61AA

J619F:	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	LD	B,A
	LD	A,0FFH
	DEFW	0

J61AA:	CALL	C6058			; copy code block in execution buffer

	POP	HL
	CALL	C7E5A
	DEFW	0

	LD	B,4			; result = generated string
	RET

;	  Subroutine MID$ statement
;	     Inputs  ________________________
;	     Outputs ________________________

J61B6:	CALL	C6044			; check for BASIC character "("
	CALL	C5BDE
	BIT	5,A			; string variable ?
	JP	Z,J4E10			; nope, BASIC error: type mismatch
	CALL	C6040			; check for BASIC character ","
	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J61E1
	INC	IX
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	JR	J61E8

J61E1:	CALL	C6058			; copy code block in execution buffer

	LD	A,0FFH
	DEFW	0

J61E8:	CALL	C6048			; check for BASIC character ")"
	CALL	C603C			; check for BASIC token =
	CALL	C6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C4FFE			; evaluate string expression
	CALL	C6058			; copy code block in execution buffer

	POP	BC
	POP	AF
	POP	DE
	CALL	C7E81			; replace in string
	DEFW	0

	RET

;	  Subroutine HEX$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C6203:	LD	HL,I7EC3		; hex handler
	JR	J6210

;	  Subroutine OCT$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C6208:	LD	HL,I7EC6		; oct handler
	JR	J6210

;	  Subroutine BIN$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C620D:	LD	HL,I7EC9		; bin handler
J6210:	PUSH	HL
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	JR	J6222

;	  Subroutine SPACE$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C6216:	LD	HL,I7EEF		; space handler
	JR	J621E

;	  Subroutine CHR$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C621B:	LD	HL,I7EA8		; CHR$ handler
J621E:	PUSH	HL
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
J6222:	CALL	C6048			; check for BASIC character ")"
	POP	HL
	JR	J626B

; STRING$ function

J6228:	CALL	C6044			; check for BASIC character "("
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6040			; check for BASIC character ","
	CALL	C6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C5012			; evaluate expression
	CALL	C6048			; check for BASIC character ")"
	LD	A,B
	CP	04H			; string ?
	JR	Z,J6247			; yep,
	CALL	C4F57			; generate LD A,byte operand code
	JR	J624E

J6247:	CALL	C6058			; copy code block in execution buffer

	INC	HL
	LD	A,(HL)			; first character of string
	DEFW	0

J624E:	CALL	C6058			; copy code block in execution buffer

	POP	BC
	CALL	C7EF2			; STRING$ handler
	DEFW	0

	LD	B,4			; result = generated string
	RET

;	  Subroutine STR$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C625A:	CALL	C4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C6048			; check for BASIC character ")"
	LD	A,B
	CP	2			; generated integer ?
	LD	HL,C7BD1		; integer to text
	JR	Z,J626B			; yep,
	LD	HL,C7C2B		; float to text
J626B:	LD	A,0CDH			; CALL xxxx
	CALL	C60AB			; put 3 bytes in execution buffer
	LD	B,4			; result = generated string
	RET

;	  Subroutine LEN function
;	     Inputs  ________________________
;	     Outputs ________________________

C6273:	CALL	C4FFE			; evaluate string expression
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	LD	L,(HL)
	LD	H,0
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine ASC function
;	     Inputs  ________________________
;	     Outputs ________________________

C6284:	CALL	C4FFE			; evaluate string expression
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	INC	HL
	LD	L,(HL)
	LD	H,0
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine VAL function
;	     Inputs  ________________________
;	     Outputs ________________________

C6296:	CALL	C4FFE			; evaluate string expression
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	CALL	C7EB0			; VAL handler
	DEFW	0

	LD	B,3			; result = generated float
	RET

; INSTR function

J62A7:	CALL	C6044			; check for BASIC character "("
	CALL	C5012			; evaluate expression
	CALL	C6040			; check for BASIC character ","
	LD	A,B
	CP	4			; string ?
	JR	Z,J62C6			; yep,
	CALL	C4F57			; generate LD A,byte operand code
	CALL	C6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C4FFE			; evaluate string expression
	CALL	C6040			; check for BASIC character ","
	JR	J62CE

J62C6:	CALL	C6058			; copy code block in execution buffer

	LD	A,1
	PUSH	AF
	DEFW	0

J62CE:	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C4FFE			; evaluate string expression
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	POP	DE
	POP	AF
	CALL	C7F15			; INSTR handler
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine create simple variable if needed, generate variable address code
;	     Inputs  HL = variable id + flags, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=0, b6=0, b5=0

C62E7:	RES	7,L			; b7=0
	JR	J62F3

;	  Subroutine create FOR variable (variable end value) if needed, generate variable address code
;	     Inputs  HL = variable id + flags, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=0, b6=1, b5=0

C62EB:	RES	7,L			; b7=0
	SET	6,L			; b6=1
	JR	J62F5

;	  Subroutine create FOR variable (variable step value) if needed, generate variable address code
;	     Inputs  HL = variable id + flags, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=1, b6=0, b5=0

C62F1:	SET	7,L			; b7=1
J62F3:	RES	6,L			; b6=0
J62F5:	RES	5,L			; b5=0
	RES	7,H			; simple variable
	JR	J631B

;	  Subroutine create array variable if needed, generate variable address code
;	     Inputs  HL = variable id + flags, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=0, b6=0, b5=0

C62FB:	RES	7,L			; b7=0
	RES	6,L			; b6=0
	JR	J630F

;	  Subroutine create FOR variable (end value and step value flags) if needed, generate variable address code
;	     Inputs  HL = variable id + flags, DE = ?, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=0, b6=1, b5=0

C6301:	RES	7,L			; b7=0
	JR	J630D

;	  Subroutine create FOR variable (constant end value) if needed, generate variable address code
;	     Inputs  HL = variable id + flags, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=1, b6=0, b5=0

C6305:	SET	7,L			; b7=1
	RES	6,L			; b6=0
	JR	J630F

;	  Subroutine create FOR variable (constant step value) if needed, generate variable address code
;	     Inputs  HL = variable id + flags, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=1, b6=1, b5=0

C630B:	SET	7,L			; b7=1
J630D:	SET	6,L			; b6=1
J630F:	RES	5,L			; b5=0
	JR	J6319

;	  Subroutine create FOR variable (code pointer start FOR) if needed, generate variable address code
;	     Inputs  HL = variable id + flags, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=1, b6=1, b5=1

J6313:	SET	7,L			; b7=1
	SET	6,L			; b6=1
	SET	5,L			; b5=1
J6319:	SET	7,H			; array variable
J631B:	PUSH	IX
	PUSH	HL
	PUSH	DE
	CALL	C6327			; create variable if needed, generate code
	POP	DE
	POP	HL
	POP	IX
	RET

;	  Subroutine create variable if needed, generate variable address code
;	     Inputs  HL = variable id + flags, C = code gen flag (0 (variable address only), 02H (store at variable), 0AH (fetch from variable))
;	     Outputs ________________________

C6327:	LD	IX,(BUF+21)		; start of variable list
J632B:	LD	A,(IX+0)
	AND	A			; end of variable list ?
	JR	Z,J638F			; yep, register new variable
	CP	L
	LD	A,(IX+1)
	DEC	IX
	DEC	IX
	DEC	IX
	DEC	IX
	JR	NZ,J632B		; not found, try again
	CP	H
	JR	NZ,J632B		; not found, try again
	BIT	7,H			; possible array variable ?
	JR	NZ,J637F		; yep,
	LD	A,H
	LD	E,(IX+6)
	LD	D,(IX+7)		; address variable
	PUSH	DE
	SET	7,D			; page 2/page 3 based (RAM)
	LD	HL,(STREND)
	AND	A
	SBC	HL,DE			; above STREND (native variable) ?
	POP	DE
	JR	NC,J637B		; nope (referenced basic variable), 
	BIT	6,A			; b6=0 ?
	LD	HL,(BUF+2)		; current compiled code pointer
	JR	Z,C6371			; yep,
	LD	A,C
	AND	A			; C=0 (address only) ?
	JR	Z,J636F			; yep,
	OR	30H			; LD (xxxx),A or LD A,(xxxx)
	CALL	C60B9			; put byte in execution buffer
	INC	HL
	CALL	C6371			; update address variable, put word in execution buffer
	JR	J63CD			; generate fetch or store HL code and quit

J636F:	RES	7,H			; simple variable

;	  Subroutine update address variable, put word in execution buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C6371:	LD	(IX+6),L
	LD	(IX+7),H		; update address variable
	EX	DE,HL
	JP	C60AE			; put word in execution buffer and quit

J637B:	EX	DE,HL
	JP	C60AE			; put word in execution buffer

; possible array variable

J637F:	BIT	7,L			; b7=1 ?
	JR	NZ,J6388		; yep, not an array variable
	BIT	6,L			; b6=0 ?
	JP	Z,J4E22			; yep (array variable), BASIC error: redemensioned array
J6388:	LD	(IX+6),E
	LD	(IX+7),D		; register address/value variable
	RET

; new variable

J638F:	LD	(IX+0),L
	LD	(IX+1),H		; register variable name + flags
	PUSH	HL
	PUSH	DE
	LD	DE,(BUF+2)		; current compiled code pointer
	PUSH	IX
	POP	HL
	DEC	HL
	DEC	HL
	DEC	HL
	DEC	HL
	LD	(BUF+23),HL		; update end of variable list
	XOR	A
	LD	(HL),A			; end marker variable list
	SBC	HL,DE			; any memory left ?
	POP	DE
	POP	HL
	JP	C,J4E1F			; nope, BASIC error: out of memory
	BIT	7,H			; b7=0 ?
	JR	Z,J63B9			; yep,
	LD	(IX+2),E
	LD	(IX+3),D		; address variable
	RET

J63B9:	BIT	6,H			; float ?
	LD	HL,(BUF+2)		; current compiled code pointer
	JR	Z,C63D5			; nope,
	LD	A,C
	AND	A			; C=0 (address only) ?
	JR	Z,J63D3			; yep,
	OR	30H			; LD A,(xxxx) or LD (xxxx),A
	CALL	C60B9			; put byte in execution buffer
	INC	HL
	CALL	C63D5			; update address variable, put word (0) in execution buffer
J63CD:	LD	A,C
	OR	20H			; LD HL,(xxxx) or LD (xxxx),HL
	JP	C60AB			; put 3 bytes in execution buffer and quit

J63D3:	RES	7,H			; simple variable

;	  Subroutine update address variable, put word (0) in execution buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C63D5:	LD	(IX+2),L
	LD	(IX+3),H		; address variable
	LD	HL,0
	JP	C60AE			; put word in execution buffer

;	  Subroutine register simple variable reference
;	     Inputs  HL = variable id + flags, DE = address
;	     Outputs ________________________

C63E1:	RES	7,H			; simple variable
	JR	J63E7

;	  Subroutine register array variable reference
;	     Inputs  HL = variable id + flags, DE = address
;	     Outputs ________________________

C63E5:	SET	7,H			; array variable
J63E7:	RES	7,L
	RES	6,L
	RES	5,L
	PUSH	IX
	PUSH	HL
	PUSH	DE
	LD	IX,(BUF+21)		; start of variable list
J63F5:	LD	A,(IX+0)
	AND	A			; end of variable list ?
	JR	Z,J6411			; yep, add to variable list
	CP	L
	LD	A,(IX+1)
	DEC	IX
	DEC	IX
	DEC	IX
	DEC	IX
	JR	NZ,J63F5
	CP	H
	JR	NZ,J63F5
	POP	DE
	POP	HL
	POP	IX
	RET

J6411:	LD	(IX+0),L
	LD	(IX+1),H		; register HL = variable id + flags
	PUSH	HL
	PUSH	DE
	LD	DE,(BUF+2)		; current compiled code pointer
	PUSH	IX
	POP	HL
	DEC	HL
	DEC	HL
	DEC	HL
	DEC	HL
	LD	(BUF+23),HL		; end of variable list
	XOR	A
	LD	(HL),A			; end marker
	SBC	HL,DE
	POP	DE
	POP	HL
	JP	C,J4E1F			; BASIC error: out of memory
	LD	(IX+2),E
	LD	(IX+3),D		; address variable
	POP	DE
	POP	HL
	POP	IX
	RET

;	  Subroutine fetch address of array variable
;	     Inputs  HL = variable id + flags
;	     Outputs ________________________
; b7=0, b6=0, b5=0

C643B:	RES	7,L
	JR	J6445

;	  Subroutine fetch address FOR variable (end value and step value flags)
;	     Inputs  HL = variable id + flags
;	     Outputs ________________________
; b7=0, b6=1, b5=0

C643F:	RES	7,L
	JR	J644B

;	  Subroutine fetch address FOR variable (constant end value)
;	     Inputs  HL = variable id + flags
;	     Outputs ________________________
; b7=1, b6=0, b5=0

C6443:	SET	7,L
J6445:	RES	6,L
	JR	J644D

;	  Subroutine fetch address FOR variable (constant step value)
;	     Inputs  HL = variable id + flags
;	     Outputs ________________________
; b7=1, b6=1, b5=0

C6449:	SET	7,L
J644B:	SET	6,L
J644D:	RES	5,L
	JR	J6457

;	  Subroutine fetch address FOR variable (code pointer start FOR)
;	     Inputs  HL = variable id + flags
;	     Outputs ________________________
; b7=1, b6=1, b5=1

C6451:	SET	7,L
	SET	6,L
	SET	5,L
J6457:	SET	7,H
	PUSH	IX
	LD	IX,(BUF+21)		; start of variable list
J645F:	LD	A,(IX+0)
	AND	A			; end of variable list ?
	JR	Z,J647F			; yep (not found), generate error
	CP	L			; variable found ?
	LD	A,(IX+1)
	DEC	IX
	DEC	IX
	DEC	IX
	DEC	IX
	JR	NZ,J645F		; nope, try next
	CP	H			; variable found ?
	JR	NZ,J645F		; nope, try next
	LD	E,(IX+6)
	LD	D,(IX+7)		; address variable
	POP	IX
	RET

J647F:	BIT	7,L
	JP	NZ,J4E1C		; BASIC error: next without for
	BIT	6,L
	JP	NZ,J4E1C		; BASIC error: next without for
	JP	J4E25			; BASIC error: subscript out of range

;	  Subroutine update compiled BASIC variable address references
;	     Inputs  ________________________
;	     Outputs ________________________

C648C:	LD	IX,(BUF+23)		; end of variable list
	LD	DE,(BUF+2)		; current compiled code pointer
J6494:	INC	IX
	INC	IX
	INC	IX
	INC	IX
	LD	HL,(BUF+21)		; start of variable list
	PUSH	IX
	POP	BC
	AND	A
	SBC	HL,BC			; past the start of variable list ?
	RET	C			; yep, quit
	BIT	7,(IX+1)		; b7=1 ?
	JR	NZ,J6494		; next variable
	LD	L,(IX+2)
	LD	H,(IX+3)		; address variable
	PUSH	HL
	SET	7,H			; top 32K address
	LD	BC,(STREND)
	SBC	HL,BC
	POP	HL			; compiled BASIC variable ?
	JR	C,J6494			; nope, next variable
	BIT	6,(IX+1)		; float ?
	JR	NZ,J64E4		; yep,
	XOR	A
	LD	(DE),A
	INC	DE
	LD	(DE),A
	DEC	DE			; clear integer / clear string (string length = 0)
J64C9:	LD	C,(HL)
	INC	HL
	LD	B,(HL)			; next location variable used
	LD	(HL),D
	DEC	HL
	LD	(HL),E			; update variable address
	LD	L,C
	LD	H,B			; next location variable used
	LD	A,L
	OR	H			; more locations ?
	JR	NZ,J64C9		; yep, update
	BIT	5,(IX+1)		; string ?
	JR	Z,J64E0			; nope, next
	LD	HL,254
	ADD	HL,DE
	EX	DE,HL			; string is 256 bytes
J64E0:	INC	DE
	INC	DE			; integer is 2 bytes
	JR	J6494			; next variable

J64E4:	XOR	A
	LD	(DE),A			; clear float
J64E6:	BIT	7,H
	SET	7,H
	LD	C,(HL)
	INC	HL
	LD	B,(HL)			; next location variable used
	DEC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; update variable address
	JR	Z,J64FA
	INC	HL
	INC	HL
	INC	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D			; update variable address
	DEC	DE
J64FA:	LD	L,C
	LD	H,B			; next location variable used
	LD	A,L
	OR	H			; more locations ?
	JR	NZ,J64E6		; yep, update
	INC	DE			; float is 3 bytes
	JR	J64E0			; next variable

;	  Subroutine fetch variable name
;	     Inputs  ________________________
;	     Outputs HL = variable id + type flags, (H b5 set if string, H b6 set if float)

C6503:	CALL	C6032			; get BASIC character (skip spaces)
	CALL	C7E39			; to upper
	CP	"A"
	JP	C,J4E16			; not a letter, BASIC error: syntax error
	CP	"Z"+1
	JP	NC,J4E16		; not a letter, BASIC error: syntax error
	LD	L,A			; first variable letter
	LD	H,0			; second variable letter clear
J6516:	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	"!"			; single real type indicator ?
	JR	Z,J656D			; yep, finish float variable
	CP	"#"			; double real type indicator ?
	JR	Z,J656D			; yep, finish float variable
	CP	"%"			; integer type indicator ?
	JR	Z,J654E			; yep, finsh integer variable
	CP	"$"			; string type indicator ?
	JR	Z,J6545			; yep, finish string variable
	CALL	C7E39			; to upper
	CP	"0"
	JR	C,J655A
	CP	"9"+1
	JR	C,J653E			; digit, valid variable name character
	CP	"A"
	JR	C,J655A
	CP	"Z"+1
	JR	NC,J655A
J653E:	INC	H
	DEC	H			; second variable name character ?
	JR	NZ,J6516		; nope, ignore and continue
	LD	H,A			; second variable letter/digit
	JR	J6516

; finish string variable

J6545:	CALL	C6576			; convert variable name to variable id
	RES	6,H			;
	SET	5,H			; type string
	JR	J6555

; finish integer variable

J654E:	CALL	C6576			; convert variable name to variable id
	RES	6,H			;
	RES	5,H			; type integer
J6555:	INC	IX
	JP	C6032			; get BASIC character (skip spaces)

J655A:	PUSH	HL
	PUSH	BC
	LD	BC,DEFTBL-"A"
	LD	H,0
	ADD	HL,BC
	LD	A,(HL)			; default variable type
	POP	BC
	POP	HL
	DEC	IX
	SUB	3			; string ?
	JR	Z,J6545			; yep, finish string variable
	JR	C,J654E			; integer, finish integer variable

; finish float variable

J656D:	CALL	C6576			; convert variable name to variable id
	SET	6,H			;
	RES	5,H			; type float
	JR	J6555

;	  Subroutine convert variable name to variable id
;	     Inputs  ________________________
;	     Outputs ________________________

C6576:	PUSH	DE
	PUSH	BC
	LD	(SWPTMP),HL		; register variable name
	PUSH	HL
	LD	A,L
	SUB	"A"
	LD	L,A
	LD	H,0
	LD	DE,37
	CALL	C7624			; multiply
	POP	AF
	AND	A			; variable name more as 1 character ?
	JR	Z,J6594			; nope,
	CP	"A"
	JR	C,J6592
	SUB	7			; letter to 3AH-
J6592:	SUB	'0'-1			; to 1-36
J6594:	LD	E,A
	LD	D,0
	ADD	HL,DE
	LD	DE,31
	CALL	C7643			; divide
	LD	H,L			; low byte result (0-31), b5-b7 are free for flags
	LD	L,E			; low byte remainer (0-30)
	INC	L			; 1-31 (b5-b7 are free for flags)
	POP	BC
	POP	DE
	RET

;	  Subroutine COLOR
;	     Inputs  ________________________
;	     Outputs ________________________

C65A4:	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JP	Z,J6683
	CP	0C7H			; SPRITE token ?
	JP	Z,J669D			; yep, COLOR SPRITE statement
	CP	0EFH			; = token ?
	JP	NZ,J663C

; COLOR = statement

	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	CP	94H			; NEW token ?
	JP	Z,J6683			; yep,
	CP	8CH			; RESTORE token ?
	JP	Z,J6690			; yep,
	CP	"("
	JP	NZ,J4E16		; BASIC error: syntax error
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6A6F			; generate PUSH AF
	CALL	C6040			; check for BASIC character ","
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J65E9
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6A6F			; generate PUSH AF
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J661E
	JR	J65F1

J65E9:	CALL	C6058			; copy code block in execution buffer

	LD	A,0FFH
	PUSH	AF
	DEFW	0

J65F1:	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J6609
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6A6F			; generate PUSH AF
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J6626
	JR	J6611

J6609:	CALL	C6058			; copy code block in execution buffer

	LD	A,0FFH
	PUSH	AF
	DEFW	0

J6611:	INC	IX
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	LD	B,A
	DEFW	0

	JR	J662D

J661E:	CALL	C6058			; copy code block in execution buffer

	LD	A,0FFH
	PUSH	AF
	DEFW	0

J6626:	CALL	C6058			; copy code block in execution buffer

	LD	B,0FFH
	DEFW	0

J662D:	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	POP	HL
	POP	DE
	POP	AF
	CALL	C710E			; change color definition handler
	DEFW	0

	RET

J663C:	CP	","
	JR	Z,J6652
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	LD	(FORCLR),A
	DEFW	0

	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J667A
J6652:	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J666D
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	LD	(BAKCLR),A
	DEFW	0

	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J667A
J666D:	INC	IX
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	LD	(BDRCLR),A
	DEFW	0

J667A:	CALL	C6058			; copy code block in execution buffer

	CALL	CHGCLR
	DEFW	0

	RET

J6683:	CALL	C6058			; copy code block in execution buffer

	LD	IX,S.INIPLT
	CALL	EXTROM
	DEFW	0

	RET

J6690:	CALL	C6058			; copy code block in execution buffer

	LD	IX,S.RSTPLT
	CALL	EXTROM
	DEFW	0

	RET

; COLOR SPRITE statement

J669D:	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	"$"
	PUSH	AF
	JR	NZ,J66A9
	INC	IX
J66A9:	CALL	C6044			; check for BASIC character "("
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6048			; check for BASIC character ")"
	CALL	C603C			; check for BASIC token =
	CALL	C6A6F			; generate PUSH AF
	POP	AF
	JR	Z,J66C8

; COLOR SPRITE()=

	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	POP	BC
	CALL	C7189			; change sprite color handler
	DEFW	0

	RET

; COLOR SPRITE$()= 

J66C8:	CALL	C4FFE			; evaluate string expression
	CALL	C6058			; copy code block in execution buffer

	POP	BC
	CALL	C7194			; change sprite color definition handler
	DEFW	0

	RET

;	  Subroutine LINE
;	     Inputs  ________________________
;	     Outputs ________________________

C66D5:	CALL	C6032			; get BASIC character (skip spaces)
	CP	0F2H			; - token ?
	JR	NZ,J66ED		; nope,
	CALL	C6058			; copy code block in execution buffer

	LD	HL,(GRPACX)
	PUSH	HL
	LD	HL,(GRPACY)
	PUSH	HL
	DEFW	0

	INC	IX
	JR	J66FB

J66ED:	CALL	C6B8B			; evaluate graphic coordinatepair, update GRPACX and GRPACY
	LD	A,0F2H			; - token
	CALL	C604A			; check for BASIC character
	CALL	C60D7			; remove byte from execution buffer
	CALL	C6A6A			; generate PUSH HL
J66FB:	CALL	C6B8B			; evaluate graphic coordinatepair, update GRPACX and GRPACY
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J673D
	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J673D
	CALL	C6058			; copy code block in execution buffer

	PUSH	DE
	PUSH	HL
	DEFW	0

	CALL	C4FA9			; evaluate integer operand
	INC	B
	DJNZ	J6726
	CALL	C60D7			; remove byte from execution buffer
	CALL	C60D7			; remove byte from execution buffer
	CALL	C4F5A			; generate LD A,constant code
	JR	J6745

J6726:	DJNZ	J6733
	CALL	C60D7			; remove byte from execution buffer
	CALL	C60D7			; remove byte from execution buffer
	CALL	C4F75			; generate LD A,(variable) code
	JR	J6745

J6733:	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	POP	HL
	POP	DE
	DEFW	0

	JR	J6745

J673D:	CALL	C6058			; copy code block in execution buffer

	LD	A,(FORCLR)
	DEFW	0

J6745:	CALL	C6058			; copy code block in execution buffer

	POP	IY
	POP	IX
	DEFW	0

	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	LD	DE,C6DA9		; draw line
	JR	NZ,J6777
	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J6777
	CP	"B"
	JP	NZ,J4E16		; BASIC error: syntax error
	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	"F"
	LD	DE,I6D4B		; draw box
	JR	NZ,J6777
	INC	IX
	LD	DE,I6E29		; draw filled box
J6777:	JP	J67D1

;	  Subroutine PSET
;	     Inputs  ________________________
;	     Outputs ________________________

C677A:	DEFB	0F6H

;	  Subroutine PRESET
;	     Inputs  ________________________
;	     Outputs ________________________

C677B:	XOR	A
	PUSH	AF
	CALL	C6B8B			; evaluate graphic coordinatepair, update GRPACX and GRPACY
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J67C0
	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J67C0
	POP	AF
	CALL	C6058			; copy code block in execution buffer

	PUSH	HL
	PUSH	DE
	DEFW	0

	CALL	C4FA9			; evaluate integer operand
	INC	B
	DJNZ	J67A9

; B=0 (integer constant)

	CALL	C60D7			; remove byte from execution buffer
	CALL	C60D7			; remove byte from execution buffer
	CALL	C4F5A			; generate LD A,constant code
	JR	J67CE

J67A9:	DJNZ	J67B6

; B=1 (variable)

	CALL	C60D7			; remove byte from execution buffer
	CALL	C60D7			; remove byte from execution buffer
	CALL	C4F75			; generate LD A,(variable) code
	JR	J67CE

; B>1

J67B6:	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	POP	DE
	POP	HL
	DEFW	0

	JR	J67CE

J67C0:	POP	AF
	LD	HL,FORCLR
	JR	NZ,J67C9
	LD	HL,BAKCLR
J67C9:	LD	A,3AH			; LD A,(xxxx)
	CALL	C60AB			; put 3 bytes in execution buffer
J67CE:	LD	DE,I6F73		; draw point
J67D1:	CALL	C67DA			; evaluate optional graphic operator
	EX	DE,HL

J67D5:	LD	A,0CDH			; CALL xxxx
	JP	C60AB			; put 3 bytes in execution buffer

;	  Subroutine evaluate optional graphic operator
;	     Inputs  ________________________
;	     Outputs ________________________

C67DA:	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J6811
	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	CP	"T"
	JR	Z,J6818
	CP	0D9H			; TO token ?
	JR	Z,J6832
	CP	0FFH			; function token ?
	JR	Z,J6840			; yep,
	CP	0F8H			; XOR token ?
	LD	H,3
	JR	Z,J6813
	CP	0F7H			; OR token ?
	LD	H,2
	JR	Z,J6813
	CP	0F6H			; AND token ?
	LD	H,1
	JR	Z,J6813
	CP	0C3H			; PRESET token ?
	LD	H,4
	JR	Z,J6813
	CP	0C2H			; PSET token ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
J6811:	LD	H,0
J6813:	LD	L,6
	JP	C60AE			; put word in execution buffer

J6818:	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	CP	0F8H			; XOR token ?
	LD	H,0BH
	JR	Z,J6813
	CP	0C3H			; PRESET token ?
	LD	H,0CH
	JR	Z,J6813
	CP	0C2H			; PSET token ?
	LD	H,08H
	JR	Z,J6813
	JP	J4E16			; nope, BASIC error: syntax error

J6832:	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	CP	"R"
	LD	H,0AH
	JR	Z,J6813
	JP	J4E16			; nope, BASIC error: syntax error

J6840:	LD	A,8DH			; GOSUB token
	CALL	C604A			; check for BASIC character
	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	CP	"D"
	LD	H,09H	; 9 
	JR	Z,J6813
	JP	J4E16			; BASIC error: syntax error

;	  Subroutine CIRCLE
;	     Inputs  ________________________
;	     Outputs ________________________

C6853:	CALL	C6B8B			; evaluate graphic coordinatepair, update GRPACX and GRPACY
	CALL	C6040			; check for BASIC character ","
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J6872
	INC	IX
	CALL	C6A6A			; generate PUSH HL
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	LD	A,0E1H			; POP HL
	CALL	C60B9			; put byte in execution buffer
	JR	J687A

J6872:	CALL	C6058			; copy code block in execution buffer

	LD	A,(FORCLR)
	DEFW	0

J687A:	LD	HL,I74DC		; circle
	JP	J67D5			; generate CALL xxxx (xxxx = HL) and quit

;	  Subroutine PUT
;	     Inputs  ________________________
;	     Outputs ________________________

C6880:	LD	A,0C7H			; SPRITE token
	CALL	C604A			; check for BASIC character
	XOR	A
	PUSH	AF
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6A6F			; generate PUSH AF
	CALL	C6040			; check for BASIC character ","
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J68AD
	CALL	C6B8B			; evaluate graphic coordinatepair, update GRPACX and GRPACY
	CALL	C60D7			; remove byte from execution buffer
	CALL	C6A6A			; generate PUSH HL
	POP	AF
	OR	80H
	PUSH	AF
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J68B4
	JR	J68E4

J68AD:	CALL	C6058			; copy code block in execution buffer

	PUSH	AF
	PUSH	AF
	DEFW	0

J68B4:	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J68D0
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6A6F			; generate PUSH AF
	POP	AF
	OR	40H
	PUSH	AF
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J68D3
	JR	J68E7

J68D0:	CALL	C6A6F			; generate PUSH AF
J68D3:	INC	IX
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	LD	H,A
	DEFW	0

	POP	AF
	OR	20H
	PUSH	AF
	JR	J68E7

J68E4:	CALL	C6A6F			; generate PUSH AF
J68E7:	POP	HL
	LD	L,6
	CALL	C60AE			; put word in execution buffer
	CALL	C6058			; copy code block in execution buffer

	POP	DE
	POP	IY
	POP	IX
	POP	AF
	CALL	C71BF			; set sprite attributes handler
	DEFW	0

	RET

; SPRITE$ statement

J68FC:	INC	IX
	CALL	C6044			; check for BASIC character "("
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6048			; check for BASIC character ")"
	CALL	C603C			; check for BASIC token =
	CALL	C6A6F			; generate PUSH AF
	CALL	C4FFE			; evaluate string expression
	CALL	C6058			; copy code block in execution buffer

	POP	AF
	CALL	C7145			; set sprite definition handler
	DEFW	0

	RET

; SPRITE function

J691A:	LD	A,"$"
	CALL	C604A			; check for BASIC character
	CALL	C6044			; check for BASIC character "("
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6048			; check for BASIC character ")"
	CALL	C6058			; copy code block in execution buffer

	CALL	C716E			; get sprite definition handler
	DEFW	0

	LD	B,4			; result = generated string
	RET

;	  Subroutine SCREEN statement
;	     Inputs  ________________________
;	     Outputs ________________________

C6933:	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J694B
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	CALL	C7369			; change screen mode handler (with MSX2+ screen mode support)
	DEFW	0

	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	RET	NZ
J694B:	INC	IX
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	LD	HL,I70BE		; set sprite mode
	JP	J67D5			; generate CALL xxxx (xxxx = HL) and quit

;	  Subroutine CLS statement
;	     Inputs  ________________________
;	     Outputs ________________________

C6956:	LD	HL,I6CE3		; clear screen
	JP	J67D5			; generate CALL xxxx (xxxx = HL) and quit

;	  Subroutine VPOKE
;	     Inputs  ________________________
;	     Outputs ________________________

C695C:	CALL	C4FA9			; evaluate integer operand
	CALL	C6040			; check for BASIC character ","
	INC	B
	DJNZ	J696F

; B=0 (address = integer constant)

	PUSH	HL
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	POP	HL
	CALL	C607E			; put LD HL,xxxx in execution buffer
	JR	J699D

J696F:	DJNZ	J697B

; B=1 (address = variable)

	PUSH	HL
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	POP	HL
	CALL	C6086			; put LD HL,(xxxx) in execution buffer
	JR	J699D

; B=2 (address = generated integer)

J697B:	CALL	C6A6A			; generate PUSH HL
	CALL	C4FA9			; evaluate integer operand
	INC	B
	DJNZ	J698C

; B=0 (value = integer constant)

	CALL	C60D7			; remove byte from execution buffer (PUSH HL)
	CALL	C4F5A			; generate LD A,constant code
	JR	J699D

; B=1 (value = variable)

J698C:	DJNZ	J6996
	CALL	C60D7			; remove byte from execution buffer (PUSH HL)
	CALL	C4F75			; generate LD A,(variable) code
	JR	J699D

; B=2 (value = generated integer)

J6996:	CALL	C6058			; copy code block in execution buffer

	LD	A,L
	POP	HL
	DEFW	0

J699D:	LD	HL,I70B7		; write VRAM
	JP	J67D5			; generate CALL xxxx (xxxx = HL) and quit

;	  Subroutine SET
;	     Inputs  ________________________
;	     Outputs ________________________

C69A3:	CALL	C6032			; get BASIC character (skip spaces)
	CP	"S"
	JR	Z,J69E4

; SET PAGE

	LD	A,"P"
	CALL	C604A			; check for BASIC character
	LD	A,"A"
	CALL	C604A			; check for BASIC character
	LD	A,"G"
	CALL	C604A			; check for BASIC character
	LD	A,"E"
	CALL	C604A			; check for BASIC character
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J69D6
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	CALL	C70CC			; change display page
	DEFW	0

	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	RET	NZ
J69D6:	INC	IX
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	LD	(ACPAGE),A		; change active page
	DEFW	0

	RET

; SET SCROLL

J69E4:	INC	IX
	LD	A,"C"
	CALL	C604A			; check for BASIC character
	LD	A,"R"
	CALL	C604A			; check for BASIC character
	LD	A,"O"
	CALL	C604A			; check for BASIC character
	LD	A,"L"
	CALL	C604A			; check for BASIC character
	CALL	C604A			; check for BASIC character
	CALL	C6A46			; generate code for optional parameter
	CALL	C6A46			; generate code for optional parameter
	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,J6A1F			; yep, generate code for mask default
	CP	","			; parameter not specified ?
	JR	Z,J6A1D			; yep, generate code for mask default
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,J6A26			; yep, generate code for pagemode
	CP	","			; parameter not specified ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	INC	IX
	JR	J6A26

J6A1D:	INC	IX
J6A1F:	CALL	C6058			; copy code block in execution buffer

	LD	A,0FFH
	DEFW	0

J6A26:	CALL	C6A6F			; generate PUSH AF
	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,J6A33			; yep, generate code for pagemode default
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	JR	J6A3A

J6A33:	CALL	C6058			; copy code block in execution buffer

	LD	A,0FFH
	DEFW	0

J6A3A:	CALL	C6058			; copy code block in execution buffer

	POP	BC
	POP	HL
	POP	DE
	CALL	C7004			; setup scroll
	DEFW	0

	RET

;	  Subroutine generate code for optional parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6A46:	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,J6A62			; yep, generate code for default value
	CP	","
	JR	Z,J6A60			; parameter not specified, generate code for default value
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C4F00			; get BASIC character (skip spaces), is end of line or statement ?
	JR	Z,C6A6A			; yep, generate PUSH HL and quit
	CP	","			; more parameters ?
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	INC	IX
	JR	C6A6A			; yep, generate PUSH HL and quit

J6A60:	INC	IX
J6A62:	CALL	C6058			; copy code block in execution buffer

	LD	HL,-1
	DEFW	0

;	  Subroutine generate PUSH HL
;	     Inputs  ________________________
;	     Outputs ________________________

C6A6A:	LD	A,0E5H			; PUSH HL
J6A6C:	JP	C60B9			; put byte in execution buffer

;	  Subroutine generate PUSH AF
;	     Inputs  ________________________
;	     Outputs ________________________

C6A6F:	LD	A,0F5H			; PUSH AF
	JR	J6A6C

;	  Subroutine VPEEK function
;	     Inputs  ________________________
;	     Outputs ________________________

C6A73:	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C6048			; check for BASIC character ")"
	LD	B,2			; result = generated integer
	LD	HL,I70A3		; read VRAM
	JP	J67D5			; generate CALL xxxx (xxxx = HL) and quit

;	  Subroutine VDP
;	     Inputs  ________________________
;	     Outputs ________________________

C6A81:	CALL	C6044			; check for BASIC character "("
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6048			; check for BASIC character ")"
	CALL	C6A6F			; generate PUSH AF
	CALL	C603C			; check for BASIC token =
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	LD	B,A
	POP	AF
	CP	8
	ADC	A,0FFH
	LD	C,A
	CALL	WRTVDP
	DEFW	0

	RET

; POINT function

J6AA3:	SCF				; do not update GRPACX and GRPACY
	CALL	C6B8C			; evaluate graphic coordinatepair
	LD	B,2			; result = generated integer
	LD	HL,I6FA9		; point
	JP	J67D5			; generate CALL xxxx (xxxx = HL) and quit

; VDP function

J6AAF:	CALL	C6044			; check for BASIC character "("
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C6048			; check for BASIC character ")"
	LD	B,2			; result = generated integer
	LD	HL,I7339		; read vdp register
	JP	J67D5			; generate CALL xxxx (xxxx = HL) and quit

;	  Subroutine PAINT
;	     Inputs  ________________________
;	     Outputs ________________________

C6AC0:	CALL	C6B8B			; evaluate graphic coordinatepair, update GRPACX and GRPACY
	CALL	C60D7			; remove byte from execution buffer
	CALL	C6A6A			; generate PUSH HL
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J6B04
	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J6AF2
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J6B0C
	INC	IX
	CALL	C6A6F			; generate PUSH AF
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	LD	A,0C1H			; POP BC
	CALL	C60B9			; put byte in execution buffer
	JR	J6B12

J6AF2:	INC	IX
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C6058			; copy code block in execution buffer

	LD	C,A
	LD	A,(FORCLR)
	LD	B,A
	LD	A,C
	DEFW	0

	JR	J6B12

J6B04:	CALL	C6058			; copy code block in execution buffer

	LD	A,(FORCLR)
	DEFW	0

J6B0C:	CALL	C6058			; copy code block in execution buffer

	LD	B,A
	DEFW	0

J6B12:	CALL	C6058			; copy code block in execution buffer

	POP	HL
	POP	DE
	CALL	C74BC			; paint handler
	DEFW	0

	RET

;	  Subroutine COPY
;	     Inputs  ________________________
;	     Outputs ________________________

C6B1D:	CALL	C6B8B			; evaluate graphic coordinatepair, update GRPACX and GRPACY
	LD	A,0F2H			; - token
	CALL	C604A			; check for BASIC character
	CALL	C60D7			; remove byte from execution buffer
	CALL	C6A6A			; generate PUSH HL
	CALL	C6B8B			; evaluate graphic coordinatepair, update GRPACX and GRPACY
	CALL	C60D7			; remove byte from execution buffer
	CALL	C6A6A			; generate PUSH HL
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J6B42
	INC	IX
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	JR	J6B4A

J6B42:	CALL	C6058			; copy code block in execution buffer

	LD	A,(ACPAGE)
	DEFW	0

J6B4A:	CALL	C6058			; copy code block in execution buffer

J6B4D:	LD	(LINWRK+0),A
	DEFW	0

	LD	A,0D9H			; TO token
	CALL	C604A			; check for BASIC character
	CALL	C6B8B			; evaluate graphic coordinatepair, update GRPACX and GRPACY
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	NZ,J6B6F
	INC	IX
	CALL	C6032			; get BASIC character (skip spaces)
	CP	","
	JR	Z,J6B6F
	CALL	C4F54			; evaluate byte operand and generate LD A, byte operand code
	JR	J6B77

J6B6F:	CALL	C6058			; copy code block in execution buffer

	LD	A,(ACPAGE)
	DEFW	0

J6B77:	CALL	C6058			; copy code block in execution buffer

	LD	(LINWRK+1),A
	POP	IY
	POP	IX
	POP	HL
	POP	DE
	DEFW	0

	LD	DE,I6EC8		; copy
	JP	J67D1

;	  Subroutine evaluate graphic coordinatepair, update GRPACX and GRPACY
;	     Inputs  ________________________
;	     Outputs ________________________

C6B8B:	AND	A			; update GRPACX and GRPACY

;	  Subroutine evaluate graphic coordinatepair
;	     Inputs  ________________________
;	     Outputs ________________________

C6B8C:	PUSH	AF
	CALL	C6032			; get BASIC character (skip spaces)
	INC	IX
	CP	"("
	JR	NZ,J6BB0
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C6040			; check for BASIC character ","
	POP	AF
	PUSH	AF
	JR	C,J6BA8			; do not update, skip update code
	CALL	C6058			; copy code block in execution buffer

	LD	(GRPACX),HL
	DEFW	0

J6BA8:	CALL	C6A6A			; generate PUSH HL
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	JR	J6BE4

J6BB0:	CP	0DCH			; STEP token
	JP	NZ,J4E16		; nope, BASIC error: syntax error
	CALL	C6044			; check for BASIC character "("
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C6040			; check for BASIC character ","
	CALL	C6058			; copy code block in execution buffer

	LD	DE,(GRPACX)
	ADD	HL,DE
	DEFW	0

	POP	AF
	PUSH	AF
	JR	C,J6BD4			; do not update, skip update code
	CALL	C6058			; copy code block in execution buffer

	LD	(GRPACX),HL
	DEFW	0

J6BD4:	CALL	C6A6A			; generate PUSH HL
	CALL	C4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C6058			; copy code block in execution buffer

	LD	DE,(GRPACY)
	ADD	HL,DE
	DEFW	0

J6BE4:	CALL	C6048			; check for BASIC character ")"
	POP	AF
	JR	C,J6BF2			; do not update, skip update code
	CALL	C6058			; copy code block in execution buffer

	LD	(GRPACY),HL
	DEFW	0

J6BF2:	LD	A,0D1H			; POP DE
	JP	C60B9			; put byte in execution buffer

;	  Subroutine swap integer
;	     Inputs  ________________________
;	     Outputs ________________________

I6BF7:	LD	B,2			; integer is 2 bytes
	JR	J6C01

;	  Subroutine swap string
;	     Inputs  ________________________
;	     Outputs ________________________

I6BFB:	LD	B,0			; string is 256 bytes
	JR	J6C01

;	  Subroutine swap float
;	     Inputs  ________________________
;	     Outputs ________________________

I6BFF:	LD	B,3			; float is 3 bytes

J6C01:	LD	C,(HL)
	LD	A,(DE)
	LD	(HL),A
	LD	A,C
	LD	(DE),A
	INC	DE
	INC	HL
	DJNZ	J6C01
	RET

;	  Subroutine put in DAC, execute routine DE, get result from DAC
;	     Inputs  ________________________
;	     Outputs ________________________

C6C0B:	LD	(DAC+2),HL
	LD	A,2
	LD	(VALTYP),A
	LD	HL,DAC
	CALL	C6C25			; CALL DE
	LD	A,(VALTYP)
	CP	2
	JP	NZ,J4E10		; BASIC error: type mismatch
	LD	HL,(DAC+2)
	RET

;	  Subroutine CALL DE
;	     Inputs  ________________________
;	     Outputs ________________________

C6C25:	PUSH	DE
	RET

;	  Subroutine check for traps handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6C27:	LD	HL,TRPTBL+10*3		; STOP trap
	BIT	0,(HL)			; trap enabled ?
	JR	Z,J6C4A			; nope, skip STOP trap
	EX	DE,HL
	LD	HL,INTFLG
	DI
	LD	A,(HL)			; get STOP or CTRL-STOP status
	EI
	LD	(HL),0			; reset STOP status
	CP	3			; CTRL-STOP pressed ?
	JR	NZ,J6C4A		; nope, skip STOP trap
	EX	DE,HL
	LD	A,(HL)
	SET	2,(HL)			; trap raised
	CP	(HL)			; trap already raised ?
	JR	Z,J6C4A			; yep, skip STOP trap
	AND	02H			; trap paused ?
	JR	NZ,J6C4A		; yep, skip STOP trap
	LD	HL,ONGSBF
	INC	(HL)			; increase trap counter
J6C4A:	LD	A,(ONGSBF)
	AND	A			; trap occured ?
	RET	Z			; nope, quit
	LD	HL,TRPTBL		; trap table
	LD	B,26
J6C54:	LD	A,(HL)
	CP	05H			; trap enabled AND trap not paused AND trap occured ?
	INC	HL
	JR	Z,J6C5F			; yep, invoke trap handler
	INC	HL
J6C5B:	INC	HL
	DJNZ	J6C54			; next trap
	RET

J6C5F:	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; trap handler
	LD	A,E
	OR	D			; trap handler defined ?
	JR	Z,J6C5B			; nope, next trap
	DEC	HL
	DEC	HL
	CALL	C6CB1			; decrease trap counter
	CALL	C6CA7			; pause trap
	PUSH	HL
	CALL	C6C25			; call trap handler
	POP	HL
	BIT	0,(HL)			; trap enabled ?
	RET	Z			; nope, quit
	DI
	LD	A,(HL)
	AND	05H			; ignore trap paused
	CP	(HL)			; trap enabled AND trap occured AND trap not paused ?
	LD	(HL),A			; resume trap
	JR	Z,J6CBE			; yep, quit
	CP	05H			; trap enabled AND trap occured ?
	JR	NZ,J6CBE		; yep, quit
J6C82:	LD	A,(ONGSBF)
	INC	A
	LD	(ONGSBF),A		; increase trap counter
	EI
	RET

;	  Subroutine enable trap
;	     Inputs  ________________________
;	     Outputs ________________________

I6C8B:	CALL	C6CC0			; disable normal function key behaviour if function key trap
	DI
	LD	A,(HL)
	AND	04H			; trap raised status
	OR	01H
	CP	(HL)			; trap already enabled AND trap not paused ?
	LD	(HL),A			; enable trap, resume trap
	JR	Z,J6CBE			; yep, quit
	AND	04H			; trap raised ?
	JR	NZ,J6C82		; yep, increase trap counter and quit
	EI
	RET

;	  Subroutine disable trap
;	     Inputs  ________________________
;	     Outputs ________________________

I6C9E:	CALL	C6CC8			; enable normal function key behaviour if function key trap
	DI
	LD	A,(HL)			; current trap status
	LD	(HL),0			; trap disabled, trap not paused, trap not occured
	JR	J6CAB			; if trap occured, reset trap occured and decrease trap counter

;	  Subroutine pause trap
;	     Inputs  ________________________
;	     Outputs ________________________

C6CA7:	DI
	LD	A,(HL)			; current trap status
	SET	1,(HL)			; pause trap

; if trap occured, reset trap occured and decrease trap counter

J6CAB:	CP	05H			; was trap enabled AND trap not paused AND trap occured ?
	JR	Z,J6CB4			; yep, reset trap occured and decrease trap counter
	EI
	RET

;	  Subroutine decrease trap counter
;	     Inputs  ________________________
;	     Outputs ________________________

C6CB1:	DI
	RES	2,(HL)			; trap not occured
J6CB4:	LD	A,(ONGSBF)
	SUB	1			; decrease trap counter
	JR	C,J6CBE			; already zero, quit
	LD	(ONGSBF),A
J6CBE:	EI
	RET

;	  Subroutine disable normal function key behaviour if function key trap
;	     Inputs  ________________________
;	     Outputs ________________________

C6CC0:	CALL	C6CCF			; get FNKFLG entry if trap is a function key trap
	RET	NC			; not a function key trap, quit
	LD	A,1
	LD	(DE),A			; function key trap enabled, disable normal function key behavior
	RET

;	  Subroutine enable normal function key behaviour if function key trap
;	     Inputs  ________________________
;	     Outputs ________________________

C6CC8:	CALL	C6CCF			; get FNKFLG entry if trap is a function key trap
	RET	NC			; not a function key trap, quit
	XOR	A
	LD	(DE),A			; function key trap disabled, enable normal function key behavior
	RET

;	  Subroutine get FNKFLG entry if trap is a function key trap
;	     Inputs  ________________________
;	     Outputs ________________________

C6CCF:	PUSH	HL
	LD	DE,TRPTBL+10*3
	AND	A
	SBC	HL,DE			; function key trap ?
	LD	C,L
	POP	HL
	RET	NC			; nope, quit
	LD	DE,FNKFLG+9+1
J6CDC:	DEC	DE
	INC	C
	INC	C
	INC	C
	JR	NZ,J6CDC
	RET

;	  Subroutine clear screen
;	     Inputs  ________________________
;	     Outputs ________________________

I6CE3:	LD	A,(SCRMOD)
	CP	5			; pattern screen mode ?
	JP	C,J746E			; yep, use CLS BIOS handler
	CALL	C73D3			; ?? screen mode 10 action
	CALL	C7079			; set VDP controlregister = DX, auto increment
	INC	C
	INC	C
	XOR	A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	LD	A,(ACPAGE)
	OUT	(C),A
	XOR	A
	OUT	(C),A
	LD	A,(SCRMOD)
	RRCA
	AND	01H
	INC	A
	OUT	(C),A
	LD	A,(MODE)
	AND	10H			; 212 lines mode ?
	JR	Z,J6D18			; yep,
	XOR	A
	OUT	(C),A
	INC	A
	JR	J6D1D

J6D18:	LD	A,0D4H
	OUT	(C),A
	XOR	A
J6D1D:	OUT	(C),A
	LD	A,(BAKCLR)
	CALL	C6D2F			; convert background color to background color byte
	OUT	(C),H
	XOR	A
	OUT	(C),A
	LD	A,0C0H
	OUT	(C),A
	RET

;	  Subroutine convert background color to background color byte
;	     Inputs  ________________________
;	     Outputs ________________________

C6D2F:	LD	H,A
	LD	A,(SCRMOD)
	CP	8			; screen mode 8 ?
	RET	Z			; yep, quit
	CP	7			; screen mode 7 ?
	JR	Z,J6D43			; yep, b7-b4 = b3-b0
	CP	5			; screen mode 5 ?
	JR	Z,J6D43			; yep, b7-b4 = b3-b0
					; b7-b6 = b5-b4 = b3-b2 = b1-b0
	LD	A,H
	ADD	A,A
	ADD	A,A
	OR	H
	LD	H,A
J6D43:	LD	A,H
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	H
	LD	H,A
	RET

;	  Subroutine draw box
;	     Inputs  ________________________
;	     Outputs ________________________

I6D4B:	PUSH	AF
	LD	A,(SCRMOD)
	CP	5			; pattern screen mode ?
	JP	C,J747B			; yep, use MSX1 draw box handler
	POP	AF
	PUSH	HL
	PUSH	IX
	POP	HL
	AND	A
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	NC,J6D62
	EX	DE,HL
	AND	A
J6D62:	EX	(SP),HL
	PUSH	DE
	PUSH	IY
	POP	DE
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	C,J6D6E
	EX	DE,HL
J6D6E:	PUSH	DE
	POP	IY
	POP	DE
	POP	IX
	PUSH	IY
	PUSH	HL
	POP	IY
	DEC	IX
	PUSH	AF
	PUSH	BC
	CALL	C6DA9			; draw line
	POP	BC
	POP	AF
	INC	IX
	POP	HL
	DEC	HL
	PUSH	IY
	PUSH	DE
	PUSH	IX
	POP	DE
	PUSH	AF
	PUSH	BC
	CALL	C6DA9			; draw line
	POP	BC
	POP	AF
	INC	HL
	POP	IX
	INC	IX
	PUSH	HL
	POP	IY
	PUSH	AF
	PUSH	BC
	CALL	C6DA9			; draw line
	POP	BC
	POP	AF
	DEC	IX
	POP	HL
	INC	HL
	PUSH	IX
	POP	DE
					; draw line and quit

;	  Subroutine draw line
;	     Inputs  ________________________
;	     Outputs ________________________

C6DA9:	PUSH	AF
	LD	A,(SCRMOD)
	CP	5			; pattern screen mode ?
	JP	C,J7476			; yep,use MSX1 draw line handler
	POP	AF
	CALL	C73D3			; ?? screen mode 10 action
	PUSH	AF
	CALL	C7441			; force X and Y coordinate within screen limits, when limits enabled (DE,HL)
	CALL	C742D			; force X and Y coordinate within screen limits, when limits enabled (IX,IY)
	POP	AF
	PUSH	DE
	PUSH	HL
	PUSH	IX
	PUSH	IY
	PUSH	AF
	PUSH	AF
	PUSH	HL
	CALL	C7079			; set VDP controlregister = DX, auto increment
	INC	C
	INC	C
	PUSH	IX
	POP	HL
	OUT	(C),L
	OUT	(C),H
	PUSH	IY
	POP	HL
	OUT	(C),L
	LD	A,(ACPAGE)
	OR	H
	OUT	(C),A
	LD	A,0CH	; 12 
	PUSH	IX
	POP	HL
	SBC	HL,DE
	JR	NC,J6DEF
	EX	DE,HL
	LD	HL,1
	SBC	HL,DE
	AND	0FBH
J6DEF:	PUSH	HL
	POP	IX
	POP	DE
	PUSH	IY
	POP	HL
	SBC	HL,DE
	JR	NC,J6E02
	EX	DE,HL
	LD	HL,1
	SBC	HL,DE
	AND	0F7H
J6E02:	PUSH	IX
	POP	DE
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	C,J6E0E
	EX	DE,HL
	OR	01H
J6E0E:	OUT	(C),E
	OUT	(C),D
	OUT	(C),L
	OUT	(C),H
	LD	E,A
	POP	AF
	OUT	(C),A
	OUT	(C),E
	LD	A,B
	OR	70H	; "p"
	OUT	(C),A
	POP	AF
	POP	IY
	POP	IX
	POP	HL
	POP	DE
	RET

;	  Subroutine draw filled box
;	     Inputs  ________________________
;	     Outputs ________________________

I6E29:	PUSH	AF
	LD	A,(SCRMOD)
	CP	5			; pattern screen mode ?
	JP	C,J7480			; yep, use MSX1 draw filled box handler
	POP	AF
	CALL	C73D3			; ?? screen mode 10 action

;	  Subroutine filled box
;	     Inputs  ________________________
;	     Outputs ________________________

C6E36:	PUSH	AF
	CALL	C7441			; force X and Y coordinate within screen limits, when limits enabled (DE,HL)
	CALL	C742D			; force X and Y coordinate within screen limits, when limits enabled (IX,IY)
	POP	AF
	PUSH	AF
	PUSH	HL			; save HL
	PUSH	IX
	POP	HL			; HL = second X
	AND	A
	PUSH	HL			; save second X
	SBC	HL,DE			; second X smaller as first X ?
	POP	HL
	JR	NC,J6E4C
	EX	DE,HL			; yep, swap
	AND	A
J6E4C:	EX	(SP),HL
	PUSH	DE			; save DE
	PUSH	IY
	POP	DE			; DE = second Y
	PUSH	HL
	SBC	HL,DE			; second Y smaller as first Y ?
	POP	HL
	JR	C,J6E58
	EX	DE,HL			; yep, swap
J6E58:	PUSH	DE
	POP	IY			; IY = DE
	POP	DE
	POP	IX
	CALL	C7079			; set VDP controlregister = DX, auto increment
	INC	C
	INC	C
	OUT	(C),E
	OUT	(C),D			; DX = DE
	OUT	(C),L
	LD	A,(ACPAGE)
	OR	H
	OUT	(C),A			; DY = HL
	PUSH	HL
	PUSH	IX
	POP	HL
	AND	A
	SBC	HL,DE
	INC	HL
	OUT	(C),L
	OUT	(C),H			; NX
	LD	A,L
	OR	E
	PUSH	IY
	POP	HL
	POP	DE
	SBC	HL,DE
	INC	HL
	OUT	(C),L
	OUT	(C),H			; NY
	LD	E,A
	POP	HL
	INC	B
	DJNZ	J6EA7
	LD	A,(SCRMOD)
	CP	8
	JR	Z,J6EBE
	CP	7
	JR	Z,J6E9C
	CP	6
	JR	Z,J6EA2
J6E9C:	LD	A,E
	RRCA
	JR	NC,J6EB7
	JR	J6EA7

J6EA2:	LD	A,E
	AND	3
	JR	Z,J6EB2
J6EA7:	OUT	(C),H
	XOR	A
	OUT	(C),A
	LD	A,B
	OR	80H
	OUT	(C),A
	RET

J6EB2:	LD	A,H
	ADD	A,A
	ADD	A,A
	OR	H
	LD	H,A
J6EB7:	LD	A,H
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	H
	LD	H,A
J6EBE:	OUT	(C),H
	XOR	A
	OUT	(C),A
	LD	A,0C0H
	OUT	(C),A
	RET

;	  Subroutine copy
;	     Inputs  ________________________
;	     Outputs ________________________

I6EC8:	CALL	C7441			; force X and Y coordinate within screen limits, when limits enabled (DE,HL)
	CALL	C742D			; force X and Y coordinate within screen limits, when limits enabled (IX,IY)
	PUSH	HL
	PUSH	DE
	LD	DE,(GRPACX)
	LD	HL,(GRPACY)
	CALL	C7441			; force X and Y coordinate within screen limits, when limits enabled
	LD	(GRPACX),DE
	LD	(GRPACY),HL
	POP	DE
	POP	HL
	PUSH	DE
	PUSH	BC
	LD	A,32			; VDP register SX, auto increment
	CALL	C707B			; set VDP controlregister
	INC	C
	INC	C
	OUT	(C),E
	OUT	(C),D
	OUT	(C),L
	LD	A,(LINWRK+0)
	OR	H
	OUT	(C),A
	PUSH	HL
	LD	HL,(GRPACX)
	OUT	(C),L
	OUT	(C),H
	LD	HL,(GRPACY)
	OUT	(C),L
	LD	A,(LINWRK+1)
	OR	H
	OUT	(C),A
	LD	B,0
	LD	A,(GRPACX)
	OR	E
	PUSH	IX
	POP	HL
	SBC	HL,DE
	JR	NC,J6F28
	LD	A,(GRPACX)
	CPL
	LD	D,A
	LD	A,E
	CPL
	OR	D
	EX	DE,HL
	LD	HL,0
	SBC	HL,DE
	SET	2,B
J6F28:	INC	HL
	OUT	(C),L
	OUT	(C),H
	OR	L
	POP	DE
	PUSH	IY
	POP	HL
	SBC	HL,DE
	JR	NC,J6F3E
	EX	DE,HL
	LD	HL,1
	SBC	HL,DE
	SET	3,B
J6F3E:	INC	HL
	OUT	(C),L
	OUT	(C),H
	OUT	(C),A
	OUT	(C),B
	LD	B,A
	POP	HL
	POP	DE
	LD	A,H
	AND	A
	JR	NZ,J6F68
	LD	A,(SCRMOD)
	CP	8
	JR	Z,J6F6E
	CP	7
	JR	Z,J6F5D
	CP	6
	JR	Z,J6F63
J6F5D:	LD	A,B
	RRCA
	JR	NC,J6F6E
	JR	J6F68

J6F63:	LD	A,B
	AND	3
	JR	Z,J6F6E
J6F68:	LD	A,H
	OR	90H
	OUT	(C),A
	RET

J6F6E:	LD	A,0D0H
	OUT	(C),A
	RET

;	  Subroutine draw point
;	     Inputs  ________________________
;	     Outputs ________________________

I6F73:	PUSH	AF
	LD	A,(SCRMOD)
	CP	5			; pattern screen mode ?
	JP	C,J749A			; yep, use MSX1 draw point handler
	POP	AF
	CALL	C73D3			; ?? screen mode 10 action
	PUSH	AF
	CALL	C7441			; force X and Y coordinate within screen limits, when limits enabled
	CALL	C7079			; set VDP controlregister = DX, auto increment
	INC	C
	INC	C
	OUT	(C),E
	OUT	(C),D
	OUT	(C),L
	LD	A,(ACPAGE)
	OR	H
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	POP	AF
	OUT	(C),A
	XOR	A
	OUT	(C),A
	LD	A,B
	OR	50H	; "P"
	OUT	(C),A
	RET

;	  Subroutine point
;	     Inputs  ________________________
;	     Outputs ________________________

I6FA9:	LD	A,(SCRMOD)
	CP	5			; pattern screen mode ?
	JP	C,J74A8			; yep, use MSX1 point handler
	CALL	C7441			; force X and Y coordinate within screen limits, when limits enabled
	LD	A,32			; VDP register SX, auto increment
	CALL	C707B			; set VDP controlregister
	INC	C
	INC	C
	OUT	(C),E
	OUT	(C),D
	OUT	(C),L
	LD	A,(ACPAGE)
	OR	H
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	XOR	A
	OUT	(C),A
	LD	A,40H
	OUT	(C),A
	DEC	C
	DEC	C
	LD	H,0
	CALL	C708A			; wait until VDP command is done
	LD	A,7			; VDP status register 7
	DI
	CALL	C709C			; read VDP status register
	IN	L,(C)
	XOR	A			; VDP status register 0
	CALL	C709C			; read VDP status register
	EI
	CALL	C73BE			; check if screen mode 10
	RET	NZ			; nope, quit
	LD	A,L
	AND	0F8H
	RRA
	RRA
	RRA
	RRA
	LD	L,A
	RET	C
	LD	L,0FFH
	RET

;	  Subroutine setup scroll
;	     Inputs  ________________________
;	     Outputs ________________________

C7004:	PUSH	AF
	LD	A,E
	AND	D
	INC	A
	JR	Z,J7023
	LD	C,E
	DEC	DE
	RR	D
	RR	E
	SRL	E
	SRL	E
	INC	E
	LD	A,E
	AND	3FH
	LD	E,A
	LD	A,C
	NEG
	AND	07H
	LD	D,A
	LD	(RG26SAV),DE
J7023:	LD	A,L
	AND	H
	INC	A
	JR	Z,J702C
	LD	A,L
	LD	(RG23SAV),A
J702C:	LD	HL,RG25SAV
	INC	B
	JR	Z,J7038
	SET	1,(HL)
	DJNZ	J7038
	RES	1,(HL)
J7038:	POP	BC
	INC	B
	JR	Z,J7042
	SET	0,(HL)
	DJNZ	J7042
	RES	0,(HL)
J7042:	LD	A,(VDP.DR)
	LD	C,A
	INC	C
	LD	A,2			; VDP status register 2
	DI
	CALL	C709C			; read VDP status register
J704D:	IN	A,(C)
	ADD	A,A
	JP	M,J704D
J7053:	IN	A,(C)
	ADD	A,A
	JP	P,J7053
	XOR	A			; VDP status register 0
	CALL	C709C			; read VDP status register
	LD	A,(RG23SAV)
	OUT	(C),A
	LD	A,128+23
	OUT	(C),A
	LD	A,25
	OUT	(C),A
	LD	A,128+17
	OUT	(C),A
	INC	C
	INC	C
	LD	B,3
	LD	HL,RG25SAV
	OTIR
	EI
	RET

;	  Subroutine set VDP controlregister = DX, auto increment
;	     Inputs  ________________________
;	     Outputs ________________________

C7079:	LD	A,36			; VDP register DX, auto increment

;	  Subroutine set VDP controlregister
;	     Inputs  ________________________
;	     Outputs ________________________

C707B:	PUSH	AF
	LD	A,(VDP.DR)
	LD	C,A
	INC	C
	POP	AF
	DI
	OUT	(C),A
	LD	A,128+17
	EI
	OUT	(C),A

;	  Subroutine wait until VDP command is done
;	     Inputs  ________________________
;	     Outputs ________________________

C708A:	LD	A,2			; VDP status register 2
	DI
	CALL	C709C			; read VDP status register
	IN	A,(C)
	RRA
	LD	A,0			; VDP status register 0
	CALL	C709C			; read VDP status register
	EI
	JR	C,C708A
	RET

;	  Subroutine read VDP status register
;	     Inputs  ________________________
;	     Outputs ________________________

C709C:	OUT	(C),A
	LD	A,128+15
	OUT	(C),A
	RET

;	  Subroutine read VRAM
;	     Inputs  HL = VRAM address
;	     Outputs HL = VRAM value

I70A3:	CALL	C70AB			; setup VDP for VRAM read
	LD	H,0
	IN	L,(C)
	RET

;	  Subroutine setup VDP for VRAM read
;	     Inputs  HL = VRAM address
;	     Outputs ________________________

C70AB:	LD	A,(VDP.DR)
	LD	C,A

;	  Subroutine setup VDP for VRAM read
;	     Inputs  HL = VRAM address, C = VDP data read port
;	     Outputs ________________________

C70AF:	CALL	C7403			; setup VDP active screen page and low byte VRAM address
	EI
	OUT	(C),A			; high byte VRAM address, read VRAM operation
	DEC	C			; data port
	RET

;	  Subroutine write VRAM
;	     Inputs  HL = VRAM address, A = byte
;	     Outputs ________________________

I70B7:	LD	B,A
	CALL	C71B1			; setup VDP for VRAM write
	OUT	(C),B
	RET

;	  Subroutine set sprite mode
;	     Inputs  ________________________
;	     Outputs ________________________

I70BE:	AND	3
	LD	HL,RG1SAV
	RES	0,(HL)
	RES	1,(HL)
	OR	(HL)
	LD	(HL),A
	JP	CLRSPR

;	  Subroutine change display page
;	     Inputs  ________________________
;	     Outputs ________________________

C70CC:	LD	(DPPAGE),A
	RRCA
	RRCA
	RRCA
	AND	0E0H
	LD	E,A			; OR mask
	LD	A,(RG2SAV)
	AND	1FH
	LD	C,2			; register 2
	CALL	C7109			; write VDP register with OR mask
	LD	A,(SCRMOD)
	CP	7
	LD	A,(DPPAGE)
	LD	D,0FCH			; AND mask
	JR	C,J70EE
	ADD	A,A
	LD	D,0FDH			; AND mask
J70EE:	LD	E,A			; OR mask
	LD	A,(RG11SAV)
	LD	C,11			; register 11
	CALL	C7108			; write VDP register with AND and OR mask
	LD	A,D
	RLCA
	RLCA
	RLCA
	RLCA
	LD	D,A			; AND mask
	LD	A,E
	RLCA
	RLCA
	RLCA
	RLCA
	LD	E,A			; OR mask
	LD	A,(RG6SAV)
	LD	C,6			; register 6

;	  Subroutine write VDP register with AND and OR mask
;	     Inputs  ________________________
;	     Outputs ________________________

C7108:	AND	D

;	  Subroutine write VDP register with OR mask
;	     Inputs  ________________________
;	     Outputs ________________________

C7109:	OR	E
	LD	B,A
	JP	WRTVDP

;	  Subroutine change color definition handler
;	     Inputs  ________________________
;	     Outputs ________________________

C710E:	PUSH	AF
	PUSH	BC
	PUSH	DE
	LD	IX,S.GETPLT
	CALL	EXTROM
	POP	DE
	LD	L,C
	LD	A,B
	RLCA
	RLCA
	RLCA
	RLCA
	AND	0FH
	LD	E,A
	LD	A,B
	POP	BC
	AND	0FH
	LD	C,A
	LD	A,D
	INC	A
	JR	NZ,J712C
	LD	D,E
J712C:	LD	A,H
	INC	A
	JR	NZ,J7131
	LD	H,L
J7131:	LD	A,B
	INC	A
	JR	NZ,J7136
	LD	B,C
J7136:	LD	A,D
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	B
	POP	DE
	LD	E,H
	LD	IX,S.SETPLT
	JP	EXTROM

;	  Subroutine set sprite definition handler
;	     Inputs  ________________________
;	     Outputs ________________________

C7145:	PUSH	HL
	CALL	CALPAT
	CALL	C71B1			; setup VDP for VRAM write
	CALL	GSPSIZ
	LD	A,8
	JR	NC,J7155
	LD	A,32
J7155:	LD	B,A			; size of sprite definition
	POP	HL
	SUB	(HL)			; string length > size of sprite definition ?
	PUSH	AF
	JR	C,J7160			; yep, use only the size of sprite definition
	LD	B,(HL)			; string length
	INC	B
	DEC	B			; empty string ?
	JR	Z,J7164			; yep, skip changing the sprite definition
J7160:	INC	HL
	CALL	C71A4			; write bytes to VRAM
J7164:	POP	AF
	RET	Z			; complete sprite definition, quit
	RET	C			; complete sprite definition, quit
	LD	B,A
	XOR	A
J7169:	OUT	(C),A
	DJNZ	J7169			; clear remainer of sprite defintion
	RET

;	  Subroutine get sprite definition handler
;	     Inputs  ________________________
;	     Outputs ________________________

C716E:	CALL	CALPAT
	CALL	C70AB			; setup VDP for VRAM read
	CALL	GSPSIZ
	LD	B,8
	JR	NC,J717D
	LD	B,32
J717D:	LD	HL,BUF
	PUSH	HL
	LD	(HL),B			; string length
	INC	HL
J7183:	INI
	JR	NZ,J7183
	POP	HL
	RET

;	  Subroutine change sprite color handler
;	     Inputs  ________________________
;	     Outputs ________________________

C7189:	AND	7FH
	PUSH	AF
	CALL	C71A9			; setup VDP for VRAM write of sprite color table
	POP	AF
	LD	B,16
	JR	J7169

;	  Subroutine change sprite color definition handler
;	     Inputs  ________________________
;	     Outputs ________________________

C7194:	PUSH	HL
	CALL	C71A9			; setup VDP for VRAM write of sprite color table
	POP	HL
	LD	A,(HL)
	AND	A
	RET	Z
	CP	16+1
	JR	C,J71A2
	LD	A,16
J71A2:	LD	B,A
	INC	HL

;	  Subroutine write bytes to VRAM
;	     Inputs  ________________________
;	     Outputs ________________________

C71A4:	OUTI
	JR	NZ,C71A4
	RET

;	  Subroutine setup VDP for VRAM write of sprite color table
;	     Inputs  ________________________
;	     Outputs ________________________

C71A9:	LD	A,B
	ADD	A,A			; *2
	ADD	A,A			; *4
	CALL	CALATR
	DEC	H
	DEC	H

;	  Subroutine setup VDP for VRAM write
;	     Inputs  HL = VRAM address
;	     Outputs ________________________

C71B1:	LD	A,(VDP.DR)
	LD	C,A

;	  Subroutine setup VDP for VRAM write
;	     Inputs  HL = VRAM address, C = VDP data write port
;	     Outputs ________________________

C71B5:	CALL	C7403			; setup VDP active screen page and low byte VRAM address
	OR	40H
	EI
	OUT	(C),A			; high byte VRAM address, write VRAM operation
	DEC	C			; data port
	RET

;	  Subroutine set sprite attributes handler
;	     Inputs  ________________________
;	     Outputs ________________________

C71BF:	PUSH	AF
	LD	A,(VDP.DR)
	LD	C,A
	LD	A,(SCRMOD)
	CP	4			; TMS9918 screen mode ?
	JP	NC,J722E		; nope,

; set sprite attributes handler sprite mode 0

	POP	AF
	PUSH	HL
	PUSH	DE
	CALL	CALATR
	POP	DE
	PUSH	HL
	CALL	C70AF			; setup VDP for VRAM read
	LD	A,B
	LD	HL,LINWRK
	LD	B,4
J71DD:	INI
	JR	NZ,J71DD
	LD	B,A
	BIT	7,B
	JR	Z,J7201
	LD	(LINWRK+0),IY
	PUSH	IX
	POP	HL
	LD	A,H
	AND	80H
	LD	E,A
	LD	A,L
	LD	HL,LINWRK+3
	JR	Z,J71F9
	ADD	A,20H	; " "
J71F9:	LD	(LINWRK+1),A
	LD	A,(HL)
	AND	7FH
	OR	E
	LD	(HL),A
J7201:	BIT	6,B
	JR	Z,J7211
	LD	HL,LINWRK+3
	LD	A,D
	AND	0FH	; 15 
	LD	D,A
	LD	A,(HL)
	AND	0F0H
	OR	D
	LD	(HL),A
J7211:	POP	HL
	EX	(SP),HL
	BIT	5,B
	JR	Z,J7222
	CALL	GSPSIZ
	LD	A,H
	JR	NC,J721F
	ADD	A,A
	ADD	A,A
J721F:	LD	(LINWRK+2),A
J7222:	POP	HL
	CALL	C71B5			; setup VDP for VRAM write
	LD	HL,LINWRK
	LD	B,4			; 4 bytes
	JP	C71A4			; write bytes to VRAM

; set sprite attributes handler sprite mode 1

J722E:	POP	AF
	PUSH	AF
	PUSH	HL
	PUSH	DE
	PUSH	AF
	CALL	CALATR
	POP	AF
	PUSH	HL
	PUSH	AF
	CALL	C70AF			; setup VDP for VRAM read
	LD	A,B
	LD	HL,LINWRK
	LD	B,3
J7242:	INI
	JR	NZ,J7242
	LD	B,A
	POP	AF
	ADD	A,A
	ADD	A,A
	CALL	CALATR
	DEC	H
	DEC	H
	PUSH	HL
	CALL	C70AF			; setup VDP for VRAM read
	LD	A,B
	LD	HL,LINWRK+4
	LD	B,16
J7259:	INI
	JR	NZ,J7259
	LD	B,A
	LD	E,0
	LD	L,0FFH
	BIT	7,B
	JR	Z,J727B
	LD	(LINWRK+0),IY
	PUSH	IX
	POP	HL
	LD	A,H
	AND	80H
	LD	E,A
	LD	A,L
	JR	Z,J7276
	ADD	A,20H	; " "
J7276:	LD	(LINWRK+1),A
	LD	L,7FH
J727B:	POP	IX
	POP	IY
	POP	AF
	BIT	6,B
	JR	Z,J728C
	AND	0FH	; 15 
	OR	E
	LD	E,A
	LD	A,L
	AND	0F0H
	LD	L,A
J728C:	PUSH	BC
	LD	D,L
	LD	HL,LINWRK+4
	LD	B,16
J7293:	LD	A,(HL)
	AND	D
	OR	E
	LD	(HL),A
	INC	HL
	DJNZ	J7293
	POP	BC
	POP	HL
	BIT	5,B
	JR	Z,J72AB
	CALL	GSPSIZ
	LD	A,H
	JR	NC,J72A8
	ADD	A,A
	ADD	A,A
J72A8:	LD	(LINWRK+2),A
J72AB:	PUSH	IX
	POP	HL
	CALL	C71B5			; setup VDP for VRAM write
	LD	HL,LINWRK+4
	LD	B,16			; 16 bytes
	CALL	C71A4			; write bytes to VRAM
	PUSH	IY
	POP	HL
	CALL	C71B5			; setup VDP for VRAM write
	LD	HL,LINWRK
	LD	B,3			; 3 bytes
	CALL	C71A4			; write bytes to VRAM
	POP	DE
	LD	A,1FH
	SUB	D
	RET	Z
	LD	E,A
	LD	D,A
	PUSH	IX
	POP	HL
J72D1:	LD	A,L
	ADD	A,10H	; 16 
	LD	L,A
	JR	NC,J72D8
	INC	H
J72D8:	CALL	C70AF			; setup VDP for VRAM read
	LD	B,16
J72DD:	IN	A,(C)
	AND	40H	; "@"
	JR	NZ,J72E7
	DJNZ	J72DD
	JR	J72EA

J72E7:	DEC	E
	JR	NZ,J72D1
J72EA:	LD	A,D
	SUB	E
	RET	Z
	LD	E,A
	PUSH	IX
	POP	HL
	PUSH	DE
	LD	A,(LINWRK+4)
	AND	80H
	LD	D,A
J72F8:	LD	A,L
	ADD	A,10H	; 16 
	LD	L,A
	JR	NC,J72FF
	INC	H
J72FF:	PUSH	HL
	CALL	C70AF			; setup VDP for VRAM read
	LD	HL,LINWRK+20
	LD	B,16
J7308:	IN	A,(C)
	AND	7FH
	OR	D
	LD	(HL),A
	INC	HL
	DJNZ	J7308
	POP	HL
	PUSH	HL
	CALL	C71B5			; setup VDP for VRAM write
	LD	HL,LINWRK+20
	LD	B,16			; 16 bytes
	CALL	C71A4			; write bytes to VRAM
	POP	HL
	DEC	E
	JR	NZ,J72F8
	POP	DE
	LD	B,E
	PUSH	IY
	POP	HL
J7327:	INC	HL
	INC	HL
	INC	HL
	INC	HL
	CALL	C71B5			; setup VDP for VRAM write
	LD	DE,(LINWRK+0)
	OUT	(C),E
	OUT	(C),D
	DJNZ	J7327
	RET

;	  Subroutine read vdp register
;	     Inputs  ________________________
;	     Outputs ________________________

I7339:	LD	A,H
	AND	A
	JR	Z,J7352
	LD	A,(VDP.DR)
	LD	C,A
	INC	C
	XOR	A
	SUB	L
	DI
	CALL	C709C			; read VDP status register
	IN	L,(C)
	XOR	A			; VDP status register 0
	CALL	C709C			; read VDP status register
	EI
	LD	H,0
	RET

J7352:	LD	DE,RG0SAV
	LD	A,L
	CP	9
	JR	C,J7364
	LD	DE,RG8SAV-9
	CP	25
	JR	C,J7364
	LD	DE,RG25SAV-26
J7364:	ADD	HL,DE
	LD	L,(HL)
	LD	H,0
	RET

;	  Subroutine change screen mode handler (with MSX2+ screen mode support)
;	     Inputs  A = screen mode (0-12)
;	     Outputs ________________________

C7369:	CP	8+1			; special MSX2+ screen mode ?
	JP	C,CHGMOD		; nope, use CHGMOD BIOS
	LD	HL,RG25SAV
	LD	B,(HL)
	LD	C,B			; save current VDP register 25
	SET	3,B
	RES	4,B			; assume YAE = 0, YJK = 1
	CP	12			; screen mode 12 ?
	JR	Z,J73AE			; yep, setup screen mode 8 if needed, setup YAE/YJK and quit
	SET	4,B			; assume YAE = 1, YJK = 1
	LD	HL,MODE
	CP	11			; screen mode 11 ?
	SET	5,(HL)			; assume flag screen mode 11
	JR	Z,J7388			; yep,
	RES	5,(HL)			; flag not screen mode 11
J7388:	BIT	3,C			; screen already in YJK mode ?
	JR	Z,J73B2			; nope, setup screen mode 8, setup YAE/YJK and quit
	BIT	4,C			; screen already in YAE mode ?
	RET	NZ			; yep, quit
	PUSH	BC
	LD	A,0F7H			; YAE attribute
	LD	B,1
	LD	DE,0			; X1 = 0
	LD	L,E
	LD	H,D			; Y1 = 0
	LD	IX,255			; X2 = 255
	LD	IY,255			; Y2 = 255
	CALL	C6E36			; filled box
	LD	A,(VDP.DR)
	LD	C,A
	INC	C
	CALL	C708A			; wait until VDP command is done
	JR	J73B8			; setup YAE/YJK and quit

J73AE:	BIT	3,C			; screen already in YJK mode ?
	JR	NZ,J73B9		; yep, setup YAE/YJK and quit
J73B2:	PUSH	BC
	LD	A,8
	CALL	CHGMOD			; screen mode 8
J73B8:	POP	BC
J73B9:	LD	C,25
	JP	WRTVDP			; setup YAE/YJK

;	  Subroutine check if screen mode 10
;	     Inputs  ________________________
;	     Outputs ________________________

C73BE:	LD	A,(IDBYT2)
	CP	2			; MSX2+ or higher ?
	SBC	A,A
	RET	NZ			; nope, quit
	LD	A,(RG25SAV)
	AND	18H			; YJK/YAE
	CP	18H			; color via color palette ?
	RET	NZ			; nope, quit
	LD	A,(MODE)
	AND	20H			; screen 11
	RET

;	  Subroutine ?? screen mode 10 action
;	     Inputs  ________________________
;	     Outputs ________________________

C73D3:	LD	C,A
	CALL	C73BE			; check if screen mode 10
	LD	A,C
	RET	NZ			; nope, quit
	EX	(SP),HL
	LD	(SWPTMP+4),HL		; save return address
	POP	HL
	INC	B
	DJNZ	J73F9

; B=0

	PUSH	AF
	PUSH	DE
	PUSH	HL
	PUSH	IX
	PUSH	IY
	LD	A,0FH
	LD	B,1
	CALL	C73FD			; invoke saved return address
	POP	IY
	POP	IX
	POP	HL
	POP	DE
	POP	AF
	LD	B,2
	SCF

J73F9:	RLA
	RLA
	RLA
	RLA

;	  Subroutine invoke saved return address
;	     Inputs  ________________________
;	     Outputs ________________________

C73FD:	PUSH	HL
	LD	HL,(SWPTMP+4)
	EX	(SP),HL
	RET

;	  Subroutine setup VDP active screen page and low byte VRAM address
;	     Inputs  HL = VRAM address
;	     Outputs ________________________

C7403:	INC	C
	LD	A,(IDBYT2)
	AND	A			; MSX1 ?
	JR	Z,J7426			; yep, skip active screen page support
	PUSH	DE
	LD	A,H
	RLCA
	RLCA
	AND	03H
	LD	E,A
	LD	A,(SCRMOD)
	CP	7
	LD	A,(ACPAGE)
	JR	C,J741C
	ADD	A,A
J741C:	ADD	A,A
	ADD	A,E
	POP	DE
	DI
	OUT	(C),A
	LD	A,128+14
	OUT	(C),A			; setup page
J7426:	DI
	OUT	(C),L			; low byte VRAM address
	LD	A,H
	AND	3FH
	RET

;	  Subroutine force X and Y coordinate within screen limits, when limits enabled
;	     Inputs  IX = X value, IY = Y value
;	     Outputs ________________________

C742D:	PUSH	HL
	PUSH	DE
	PUSH	IX
	POP	DE
	PUSH	IY
	POP	HL
	CALL	C7441			; force X and Y coordinate within screen limits, when limits enabled
	PUSH	HL
	POP	IY
	PUSH	DE
	POP	IX
	POP	DE
	POP	HL
	RET

;	  Subroutine force X and Y coordinate within screen limits, when limits enabled
;	     Inputs  DE = X value, HL = Y value
;	     Outputs ________________________

C7441:	LD	A,(MODE)
	AND	10H			; 212 lines mode ?
	RET	NZ			; nope, quit
	LD	A,D
	ADD	A,A			; X value negative ? 
	JR	NC,J7450		; nope,
	LD	DE,0			; yep, use X = 0
	JR	J745C

J7450:	LD	A,(SCRMOD)
	RRCA
	AND	01H			; screen mode 5 & 7 512, screen mode 6 & 8 256
	CP	D			; X value bigger or equal to max X ?
	JR	NC,J745C		; nope,
	LD	E,0FFH
	LD	D,A			; yep, use X = 255 or 511
J745C:	LD	A,H
	ADD	A,A			; Y value negative ? 
	JR	NC,J7464		; nope,
	LD	HL,0			; yep, use Y = 0
	RET

J7464:	JR	NZ,J746A		; Y > 255, use Y = 211
	LD	A,L
	CP	211+1
	RET	C
J746A:	LD	HL,211
	RET

J746E:	XOR	A
	LD	IX,CLS
	JP	J74EE

J7476:	LD	BC,M58FC		; line handler
	JR	J7483

J747B:	LD	BC,M5912		; line box handler
	JR	J7483

J7480:	LD	BC,M58C1		; line boxfill handler
J7483:	POP	AF
	LD	(ATRBYT),A
	PUSH	BC
	LD	(GXPOS),DE
	LD	(GYPOS),HL
	PUSH	IX
	POP	BC
	PUSH	IY
	POP	DE
	POP	IX
	JP	J74EE

J749A:	POP	AF
	LD	(ATRBYT),A
	LD	C,E
	LD	B,D
	EX	DE,HL
	LD	IX,M57F1+4
	JP	J74EE			; PSET handler

J74A8:	LD	C,E
	LD	B,D
	EX	DE,HL
	CALL	SCALXY
	LD	HL,-1
	RET	NC
	CALL	MAPXYC
	CALL	READC
	LD	L,A
	LD	H,0
	RET

;	  Subroutine paint handler
;	     Inputs  ________________________
;	     Outputs ________________________

C74BC:	LD	(BRDATR),A
	LD	A,B
	LD	(ATRBYT),A
	LD	C,E
	LD	B,D
	EX	DE,HL
	LD	A,(SCRMOD)
	CP	5			; pattern screen mode ?
	JP	C,J74D5			; yep, use MSX1 paint handler
	LD	IX,S266E
	JP	EXTROM			; PAINT handler (subrom)

J74D5:	LD	IX,M59E3		; PAINT handler
	JP	J74EE

;	  Subroutine circle
;	     Inputs  A = color
;	     Outputs ________________________

I74DC:	EX	DE,HL
	LD	HL,LINWRK+3
	LD	(HL),0
	DEC	HL
	LD	(HL),A
	DEC	HL
	LD	(HL),0FH
	DEC	HL
	LD	(HL),","		; ,<int constant>
	LD	IX,M5B19		; CIRCLE handler
J74EE:	CALL	CALBAS
	EI
	RET

;	  Subroutine print tab
;	     Inputs  ________________________
;	     Outputs ________________________

C74F3:	LD	A,9
	RST	18H
	RET

;	  Subroutine print new line
;	     Inputs  ________________________
;	     Outputs ________________________

C74F7:	LD	A,13
	RST	18H
	LD	A,10
	RST	18H
	RET

;	  Subroutine print string
;	     Inputs  ________________________
;	     Outputs ________________________

C74FE:	LD	B,(HL)
	LD	A,B
	AND	A
	RET	Z
J7502:	INC	HL
	LD	A,(HL)
	RST	18H
	DJNZ	J7502
	RET

;	  Subroutine print integer
;	     Inputs  ________________________
;	     Outputs ________________________

C7508:	CALL	C7BD1			; integer to text
	JR	J7510

;	  Subroutine print float
;	     Inputs  ________________________
;	     Outputs ________________________

C750D:	CALL	C7C2B			; float to text
J7510:	CALL	C74FE			; print string
	LD	A," "
	RST	18H
	RET

;	  Subroutine print string and get numeric input
;	     Inputs  ________________________
;	     Outputs ________________________

I7517:	CALL	C74FE			; print string

;	  Subroutine get numeric input
;	     Inputs  ________________________
;	     Outputs ________________________

J751A:	CALL	QINLIN
	JP	C,J4DFA			; abort, end program
	EX	DE,HL
	INC	DE
	CALL	C7D18			; convert numeric string to float
	LD	A,(DE)
	AND	A			; at end of string ?
	RET	Z			; yep, quit
	LD	HL,I7530
	CALL	C74FE			; print string
	JR	J751A			; try again

I7530:	DEFB	18
	DEFB	"?Redo from start",13,10

;	  Subroutine print string and get string input
;	     Inputs  ________________________
;	     Outputs ________________________

I7543:	CALL	C74FE			; print string

;	  Subroutine get string input
;	     Inputs  ________________________
;	     Outputs ________________________

I7546:	CALL	QINLIN
	JP	C,J4DFA			; abort, end program
	INC	H
	LD	E,L
	LD	D,H
	INC	DE
	LD	BC,256
	LDDR
	INC	HL
	LD	B,0FFH
J7558:	INC	B
	INC	DE
	LD	A,(DE)
	AND	A
	JR	NZ,J7558
	LD	(HL),B
	RET

; read string input handler

I7560:	CALL	C75BE			; skip to the start of DATA
J7563:	LD	A,(HL)
	INC	HL
	CP	" "
	JR	Z,J7563			; skip spaces
	LD	DE,BUF+1
	LD	B,0			; current string length = 0
	CP	'"'			; string indicator ?
	JR	Z,J7593			; yep,
	DEC	HL
J7573:	LD	A,(HL)
	AND	A			; end of line ?
	JR	Z,J758B			; yep, end of input
	CP	":"			; statement seperator ?
	JR	Z,J758B			; yep, end of input
	CP	","			; DATA item seperator ?
	JR	Z,J758B			; yep, end of input
	LD	(DE),A
	INC	DE
	INC	HL
	INC	B
	JR	J7573			; next character

J7585:	INC	HL
	LD	A,(HL)
	CP	" "
	JR	Z,J7585
J758B:	LD	(DATPTR),HL		; update current DATA pointer
	LD	HL,BUF
	LD	(HL),B			; set string length
	RET

J7593:	LD	A,(HL)
	AND	A			; end of line ?
	JR	Z,J758B			; yep, end of input
	CP	'"'			; string indicator ?
	JR	Z,J7585			; yep, end of string
	LD	(DE),A
	INC	DE
	INC	HL
J759E:	INC	B
	JR	J7593			; next character

; read numeric input handler

I75A1:	CALL	C75BE			; skip to the start of DATA
	EX	DE,HL
	CALL	C7D18			; convert numeric string to float
	LD	(DATPTR),DE		; save DATA pointer
	LD	A,(DE)
	AND	A			; end of line ?
	RET	Z			; yep, quit
	CP	":"			; end of statement ?
	RET	Z			; yep, quit
	CP	","			; next data item ?
	RET	Z			; yep, quit
	LD	HL,(DATLIN)
	LD	(CURLIN),HL		; update current BASIC line number (generated error contains the current line number)
	JP	J4E16			; BASIC error: syntax error

;	  Subroutine skip to the start of DATA
;	     Inputs  ________________________
;	     Outputs ________________________

C75BE:	LD	HL,(DATPTR)		; current DATA pointer
	LD	A,(HL)
	CP	","
	JR	NZ,J75DC
	INC	HL
	RET

J75C8:	XOR	A
	LD	B,0FFH
	CPIR				; skip to end of line
J75CD:	LD	A,(HL)
	INC	HL
	OR	(HL)			; end of program ?
	JP	Z,J4E07			; yep, BASIC error: out of data
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; line number
	LD	(DATLIN),DE		; update current DATA line number
	INC	HL

J75DC:	LD	B,0			; reset in a string flag
J75DE:	LD	A,(HL)
	INC	HL
	AND	A			; end of line ?
	JR	Z,J75CD			; yep, to the next line
	CP	84H			; DATA token ?
	JR	NZ,J75EA		; nope,
	INC	B
	DEC	B			; string indicator ?
	RET	Z			; nope, quit
J75EA:	CP	'"'			; start of DATA string ?
	JR	NZ,J75F2		; nope,
	INC	B
	DJNZ	J75DC			; in a string, continue to next character
	INC	B			; B=1, set in a sting flag
J75F2:	CP	0FFH			; function token ?
	INC	HL
	JR	Z,J75DE			; yep, continue to next character
	DEC	HL
	CP	8FH			; REM token ?
	JR	Z,J75C8			; yep, skip line and continue
	CP	1FH+1			; special number token ?
	JR	NC,J75DE		; nope, continue to next character
	CP	0BH			; unknown token ?
	JR	C,J75DE			; yep, continue to next character
	CP	0FH			; integer 11-255 ?
	LD	C,1
	JR	Z,J761C			; yep, skip next byte
	INC	C
	JR	C,J761C			; octal number, hexadecimal number, linepointer or linenumber, skip next 2 bytes
	CP	1BH			; integer 0 - integer 9 ? (?? BUG: should be CP 1CH, because of integer 10)
	JR	C,J75DE			; yep, continue to next character
	SUB	1CH			; integer ?
	JR	Z,J761C			; yep, skip next 2 bytes
	DEC	A			; single real ?
	LD	C,4
	JR	Z,J761C			; yep, skip next 4 bytes
	LD	C,8			; double real, skip next 8 bytes
J761C:	LD	A,L
	ADD	A,C
	LD	L,A
	JR	NC,J75DE
	INC	H
	JR	J75DE			; continue to next character

;	  Subroutine multiply
;	     Inputs  ________________________
;	     Outputs ________________________

C7624:	LD	A,40H
	DEFB	0CBH,037H		; SLL A (Z80), TST A (R800)
	CP	81H
	JR	Z,J7631			; Z80,
	LD	C,E
	LD	B,D
	DEFB	0EDH,0C3H		; MULUW HL,BC
	RET

J7631:	LD	C,L
	LD	B,H
	LD	HL,0
	LD	A,16
J7638:	ADD	HL,HL
	EX	DE,HL
	ADD	HL,HL
	EX	DE,HL
	JR	NC,J763F
	ADD	HL,BC
J763F:	DEC	A
	JR	NZ,J7638
	RET

;	  Subroutine divide
;	     Inputs  ________________________
;	     Outputs ________________________

C7643:	PUSH	DE
	PUSH	HL
	BIT	7,D
	JR	NZ,J764F
	XOR	A
	SUB	E
	LD	E,A
	SBC	A,A
	SUB	D
	LD	D,A
J764F:	LD	C,E
J7650:	LD	B,D
	BIT	7,H
	JR	Z,J765B
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
J765B:	EX	DE,HL
	XOR	A
	LD	L,A
	LD	H,A
	LD	A,E
	LD	E,16
	RLA
	RL	D
J7665:	ADC	HL,HL
	PUSH	HL
	ADD	HL,BC
	JR	NC,J766E
	INC	SP
	INC	SP
	DEFB	030H			; pseudo JR NC,xx (skip next instruction)
J766E:	POP	HL
	RLA
	RL	D
	DEC	E
	JR	NZ,J7665
	LD	E,A
	EX	DE,HL
	POP	AF
	AND	A
	JP	P,J7684
	XOR	A
	SUB	E
	LD	E,A
	SBC	A,A
	SUB	D
	LD	D,A
	LD	A,80H
J7684:	POP	BC
	XOR	B
	RET	P
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
	RET

;	  Subroutine RND handler
;	     Inputs  ________________________
;	     Outputs ________________________

I768E:	LD	A,B
	AND	A
	JR	Z,J76C9
	BIT	7,H
	JR	Z,J769F
	LD	(SWPTMP+2),HL
	LD	H,B
	LD	L,"5"
	LD	(SWPTMP+0),HL
J769F:	LD	HL,(SWPTMP+0)
	LD	E,L
	LD	D,H
	ADD	HL,HL
	LD	C,L
	LD	B,H
	JR	NC,J76AA
	INC	BC
J76AA:	ADD	HL,DE
	LD	(SWPTMP+0),HL
	LD	HL,(SWPTMP+2)
	LD	E,L
	LD	D,H
	ADC	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	(SWPTMP+2),HL
J76BA:	LD	A,L
	OR	H
	LD	B,A
	RET	Z
	LD	B,80H
J76C0:	BIT	7,H
	RES	7,H
	RET	NZ
	ADD	HL,HL
	DEC	B
	JR	J76C0

J76C9:	LD	HL,(SWPTMP+2)
	JR	J76BA

;	  Subroutine remainer of divide integer
;	     Inputs  ________________________
;	     Outputs ________________________

C76CE:	CALL	C7643			; divide
	EX	DE,HL
	RET

;	  Subroutine subtract floats
;	     Inputs  ________________________
;	     Outputs ________________________

C76D3:	LD	A,D
	XOR	80H
	LD	D,A

;	  Subroutine add floats
;	     Inputs  ________________________
;	     Outputs ________________________

C76D7:	LD	A,C
	AND	A
	RET	Z
	LD	A,B
	AND	A
	JP	Z,J7745
	SUB	C
	JR	NC,J76E6
	NEG
	EX	DE,HL
	LD	B,C
J76E6:	CP	11H
	RET	NC
	LD	C,A
	LD	A,H
	XOR	D
	ADD	A,A
	LD	A,H
	PUSH	AF
	SET	7,H
	SET	7,D
	INC	C
	DEC	C
	JR	Z,J7701
J76F7:	SRL	D
	RR	E
	DEC	C
	JR	NZ,J76F7
	JR	NC,J7701
	INC	DE
J7701:	POP	AF
	JR	C,J771C
	ADD	HL,DE
	JR	NC,J770E
	INC	B
	JR	Z,J7715
	RR	H
	RR	L
J770E:	RES	7,H
J7710:	AND	A
	RET	P
	SET	7,H
	RET

J7715:	LD	B,0FFH
	LD	HL,7FFFH		; (max positive float) 1.701E+38
	JR	J7710

J771C:	AND	A
	SBC	HL,DE
	JR	NC,J7728
	EX	DE,HL
	LD	HL,1
	SBC	HL,DE
	CPL
J7728:	LD	C,A
J7729:	LD	A,H
	AND	A
	JR	NZ,J773C
	OR	L
	JR	Z,J7739
	LD	H,L
	LD	L,0
	LD	A,B
	SUB	08H	; 8 
	LD	B,A
	JR	NC,J773C
J7739:	LD	B,0
	RET

J773C:	LD	A,C
J773D:	BIT	7,H
	JR	NZ,J770E
	ADD	HL,HL
	DJNZ	J773D
	RET

J7745:	LD	B,C
	EX	DE,HL
	RET

;	  Subroutine multipy floats
;	     Inputs  ________________________
;	     Outputs ________________________

C7748:	LD	A,B
	AND	A
	RET	Z
	LD	A,C
	AND	A
	JR	Z,J7739
	ADD	A,B
	LD	B,A
	RRA
	XOR	B
	LD	A,B
	JP	P,J7823
	ADD	A,80H
	LD	B,A
	RET	Z
	LD	A,H
	XOR	D
	LD	C,A
	PUSH	BC
	SET	7,H
	SET	7,D
	LD	A,40H
	DEFB	0CBH,037H		; SLL A (Z80), TST A (R800)
	CP	81H
	JR	Z,J7774			; Z80,
	LD	C,E
	LD	B,D
	DEFB	0EDH,0C3H		; MULUW HL,BC
	LD	A,H
	EX	DE,HL
	JP	J781A

J7774:	LD	C,L
	LD	A,H
	LD	HL,0
	RRA
	RR	C
	JR	NC,J777F
	ADD	HL,DE
J777F:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J7789
	ADD	HL,DE
J7789:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J7793
	ADD	HL,DE
J7793:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J779D
	ADD	HL,DE
J779D:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J77A7
	ADD	HL,DE
J77A7:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J77B1
	ADD	HL,DE
J77B1:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J77BB
	ADD	HL,DE
J77BB:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J77C5
	ADD	HL,DE
J77C5:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J77CF
	ADD	HL,DE
J77CF:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J77D9
	ADD	HL,DE
J77D9:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J77E3
	ADD	HL,DE
J77E3:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J77ED
	ADD	HL,DE
J77ED:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J77F7
	ADD	HL,DE
J77F7:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J7801
	ADD	HL,DE
J7801:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J780B
	ADD	HL,DE
J780B:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J7815
	ADD	HL,DE
J7815:	RR	H
	RR	L
	RRA
J781A:	POP	BC
	ADD	A,A
	JP	NC,J773C
	INC	HL
	JP	J773C

J7823:	AND	A
	JP	P,J7739
	LD	A,H
	XOR	D
	JP	J7715

;	  Subroutine divide floats
;	     Inputs  ________________________
;	     Outputs ________________________

C782C:	LD	A,C
	AND	A
	LD	A,H
	JP	Z,J7715
	LD	A,B
	AND	A
	RET	Z
	SUB	C
	LD	B,A
	RRA
	XOR	B
	LD	A,B
	JP	M,J7823
	ADD	A,80H
	LD	B,A
	RET	Z
	LD	A,H
	XOR	D
	INC	B
	JP	Z,J7715
	LD	C,A
	PUSH	BC
	SET	7,H
	SET	7,D
	XOR	A
	LD	C,A
	LD	B,16
	JR	J7857

J7853:	ADC	HL,HL
	JR	C,J7873
J7857:	SBC	HL,DE
	JR	NC,J785C
	ADD	HL,DE
J785C:	CCF
J785D:	RL	C
	RLA
	DJNZ	J7853
	SRL	D
	RR	E
	AND	A
	SBC	HL,DE
	LD	L,C
	LD	H,A
	POP	BC
	JP	C,J7729
	INC	HL
	JP	J7729

J7873:	OR	A
	SBC	HL,DE
	JR	J785D

;	  Subroutine ^ handler
;	     Inputs  ________________________
;	     Outputs ________________________

C7878:	LD	A,E
	OR	D
	JP	Z,C7924			; quit with 1.0
	BIT	7,D
	PUSH	AF
	JP	P,J7889
	XOR	A
	SUB	E
	LD	E,A
	SBC	A,A
	SUB	D
	LD	D,A
J7889:	PUSH	DE
	LD	C,B
	EX	DE,HL
	CALL	C7924			; 1.0
J788F:	EX	(SP),HL
	SRL	H
	RR	L
	EX	(SP),HL
	JR	NC,J789F
	PUSH	DE
	PUSH	BC
	CALL	C7748			; multipy floats
	POP	DE
	LD	C,E
	POP	DE
J789F:	EX	(SP),HL
	LD	A,L
	OR	H
	EX	(SP),HL
	JR	Z,J78B4
	PUSH	HL
	PUSH	BC
	LD	B,C
	LD	H,D
	LD	L,E
	CALL	C7748			; multipy floats
	LD	C,B
	EX	DE,HL
	POP	HL
	LD	B,H
	POP	HL
	JR	J788F

J78B4:	POP	AF
	POP	AF
	RET	P

;	  Subroutine 1/x
;	     Inputs  B:HL = float
;	     Outputs ________________________

C78B7:	LD	C,B
	EX	DE,HL			; C:DE = float
	CALL	C7924			; 1.0
	JP	C782C			; divide floats

;	  Subroutine ^
;	     Inputs  ________________________
;	     Outputs ________________________

I78BF:	PUSH	DE
	PUSH	BC
	CALL	C7B01			; LOG handler
	POP	DE
	LD	C,E
	POP	DE			; C:DE = float
	CALL	C7748			; multipy floats
	JP	J7AA8			; EXP handler

;	  Subroutine convert unsigned integer to float
;	     Inputs  HL = unsigned integer
;	     Outputs B:HL = float

C78CD:	BIT	7,H			; positive integer ?
	PUSH	AF
	RES	7,H			; to postive
	CALL	C78DF			; convert integer to float
	POP	AF
	RET	Z			; positive, quit
	LD	C,90H
	LD	DE,0			; 3.277E+04
	JP	C76D7			; add floats

;	  Subroutine convert integer to float
;	     Inputs  HL = integer
;	     Outputs B:HL = float

C78DF:	LD	A,L
	OR	H
	JR	Z,J78FF
	BIT	7,H
	PUSH	AF
	JR	Z,J78EE
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
J78EE:	LD	B,90H
J78F0:	BIT	7,H
	JR	NZ,J78F8
	ADD	HL,HL
	DEC	B
	JR	J78F0

J78F8:	RES	7,H
	POP	AF
	RET	Z
	SET	7,H
	RET

J78FF:	LD	B,A			; 0.0
	RET

;	  Subroutine convert float to integer
;	     Inputs  ________________________
;	     Outputs ________________________

C7901:	LD	A,B
	AND	A			; B=0 ?
	JR	Z,J7926			; yep, return float 0.0
	DEC	B			; B=1 ?
	JP	P,J7926			; yep, return float 0.0
	BIT	7,H
	PUSH	AF			; save sign
	SET	7,H
	LD	DE,0
J7911:	ADD	HL,HL
	RL	E
	RL	D
	DEC	B
	JP	M,J7911
	EX	DE,HL
	POP	AF			; sign set ?
	RET	Z			; nope, quit
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A			; yep, negate
	RET

;	  Subroutine float 1.0
;	     Inputs  ________________________
;	     Outputs ________________________

C7924:	LD	B,81H
J7926:	LD	HL,0
	RET

;	  Subroutine float =
;	     Inputs  B:HL = float1, C:DE = float2
;	     Outputs HL = result

C792A:	CALL	C7966			; compare floats
	LD	HL,0
	RET	NZ			; not equal, return false
	DEC	HL			; equal, return true
	RET

;	  Subroutine float <>
;	     Inputs  B:HL = float1, C:DE = float2
;	     Outputs HL = result

C7933:	CALL	C7966			; compare floats
	LD	HL,0
	RET	Z			; equal, return false
	DEC	HL			; not equal, return true
	RET

;	  Subroutine float >
;	     Inputs  B:HL = float1, C:DE = float2
;	     Outputs HL = result

C793C:	CALL	C7966			; compare floats
	LD	HL,0
	RET	C			; smaller, return false
	RET	Z			; equal, return false
	DEC	HL			; bigger, return true
	RET

;	  Subroutine float >=
;	     Inputs  B:HL = float1, C:DE = float2
;	     Outputs HL = result

C7946:	CALL	C7966			; compare floats
	LD	HL,0
	RET	C			; smaller, return false
	DEC	HL			; bigger or equal, return true
	RET

;	  Subroutine float <
;	     Inputs  B:HL = float1, C:DE = float2
;	     Outputs HL = result

C794F:	CALL	C7966			; compare floats
	LD	HL,0
	RET	NC			; bigger or equal, return false
	DEC	HL			; smaller, return true
	RET

;	  Subroutine float <=
;	     Inputs  B:HL = float1, C:DE = float2
;	     Outputs HL = result

C7958:	CALL	C7966			; compare floats
	LD	HL,-1
	RET	C			; smaller, return true
	RET	Z			; equal, return true
	INC	HL			; bigger, return false
	RET

;	  Subroutine float <=>
;	     Inputs  B:HL = float1, C:DE = float2
;	     Outputs HL = result

C7962:	LD	HL,-1			; return true
	RET

;	  Subroutine compare floats
;	     Inputs  B:HL = float1, C:DE = float2
;	     Outputs ________________________

C7966:	LD	A,C
	AND	A			; float2 0.0 ?
	JR	Z,J7986			; yep,
	LD	A,B
	AND	A			; float1 0.0 ?
	LD	A,D
	JR	Z,J7981			; yep,
	XOR	H			; float1 has same sign as float2 ?
	LD	A,D
	JP	M,J7981			; nope,
	LD	A,C
	CP	B
	JR	NZ,J797F
	LD	A,D
	CP	H
	JR	NZ,J797F
	LD	A,E
	SUB	L
	RET	Z
J797F:	RRA
	XOR	D
J7981:	CPL
	OR	01H
	RLA
	RET

J7986:	LD	A,B
	AND	A			; float 0.0 ?
	RET	Z			; yep, quit
	LD	A,H
	RLA
	RET

;	  Subroutine FIX handler
;	     Inputs  ________________________
;	     Outputs ________________________

C798C:	BIT	7,H
	PUSH	AF			; save sign
	RES	7,H			; force positive
	CALL	C7999			; INT handler
	POP	AF			; restore sign
	RET	Z			; was a positive, quit
	SET	7,H			; force negative
	RET

;	  Subroutine INT handler
;	     Inputs  ________________________
;	     Outputs ________________________

C7999:	LD	A,B
	AND	A			; float 0.0 ?
	RET	Z			; yep, quit
	CP	91H			; > float 65540 ?
	RET	NC			; yep, quit
	SUB	81H			; < 1 or < -1 ?
	JR	C,J79D7			; yep,
	LD	DE,8000H
	JR	Z,J79AF
J79A8:	SRA	D
	RR	E
	DEC	A
	JR	NZ,J79A8
J79AF:	BIT	7,H
	JR	NZ,J79BA
	LD	A,H
	AND	D
	LD	H,A
	LD	A,L
	AND	E
	LD	L,A
	RET

J79BA:	PUSH	HL
	LD	A,H
	AND	D
	LD	H,A
	LD	A,L
	AND	E
	LD	L,A
	EX	(SP),HL
	LD	A,D
	CPL
	AND	H
	JR	NZ,J79CE
	LD	A,E
	CPL
	AND	L
	JR	NZ,J79CE
	POP	HL
	RET

J79CE:	POP	HL
	LD	C,81H
	LD	DE,8000H		; float -1.0
	JP	C76D7			; add floats

J79D7:	BIT	7,H
	LD	B,0			; float 0.0
	RET	Z
	LD	B,81H
	LD	HL,8000H		; float -1.0
	RET

;	  Subroutine COS handler
;	     Inputs  ________________________
;	     Outputs ________________________

C79E2:	LD	C,81H
	LD	DE,4910H		; float 1.571 (PI/2)
	CALL	C76D7			; add floats

;	  Subroutine SIN handler
;	     Inputs  ________________________
;	     Outputs ________________________

C79EA:	LD	A,B
	CP	77H			; < 0.0004883 or < -0.0004883 ?
	RET	C			; yep, quit
	BIT	7,H			; positive float ?
	JR	Z,C79FC			; yep, calculate sinus
	RES	7,H			; force positive
	CALL	C79FC			; calculate sinus

;	  Subroutine change sign
;	     Inputs  ________________________
;	     Outputs ________________________

J79F7:	LD	A,H
	XOR	80H
	LD	H,A
	RET

;	  Subroutine calculate sinus
;	     Inputs  ________________________
;	     Outputs ________________________

C79FC:	LD	C,7EH
	LD	DE,22FAH		; float 0.1592
	CALL	C7748			; multipy floats
	PUSH	HL
	PUSH	BC
	CALL	C7999			; INT handler
	LD	C,B
	EX	DE,HL
	POP	AF
	LD	B,A
	POP	HL
	CALL	C76D3			; subtract floats
	LD	C,7FH
	LD	DE,0			; float 0.25
	CALL	C7966			; compare floats
	JR	C,J7A31			; smaller,
	LD	C,80H
	LD	DE,0C000H		; float -0.75
	CALL	C76D7			; add floats
	SET	7,H			; force negative
	LD	C,7FH
	LD	DE,0			; float 0.25
	CALL	C76D7			; add floats
	LD	A,H
	XOR	80H
	LD	H,A			; change sign
J7A31:	BIT	7,H
	PUSH	AF			; save sign
	RES	7,H			; force positive
	LD	IX,I7A53
	CALL	C7B88			; polynomial approximation odd series
	POP	AF			; restore sign
	RET	Z			; positive float, quit
	JR	J79F7			; change sign and quit

;	  Subroutine TAN handler
;	     Inputs  ________________________
;	     Outputs ________________________

I7A41:	PUSH	HL
	PUSH	BC
	CALL	C79E2			; COS handler
	LD	A,B
	POP	BC
	EX	(SP),HL
	PUSH	AF
	CALL	C79EA			; SIN handler
	POP	AF
	LD	C,A
	POP	DE
	JP	C782C			; divide floats

I7A53:	DEFB	5
	DEFB	086H,01EH,0D8H		; float  39.71
	DEFB	087H,099H,026H		; float -76.58
	DEFB	087H,023H,034H		; float  81.60
	DEFB	086H,0A5H,05EH		; float -41.34
	DEFB	083H,049H,010H		; float  6.283

;	  Subroutine ATN handler
;	     Inputs  ________________________
;	     Outputs ________________________

I7A63:	BIT	7,H			; postive float ?
	JR	Z,C7A6E			; yep, calculate arc tangent and quit
	RES	7,H			; force positive
	CALL	C7A6E			; calculate arc tangent
	JR	J79F7			; change sign and quit

;	  Subroutine calculate arc tangent
;	     Inputs  ________________________
;	     Outputs ________________________

C7A6E:	LD	A,B
	CP	81H			; < 1.0 or < -1.0 ?
	JR	C,C7A85			; yep,
	CALL	C78B7			; 1/x
	CALL	C7A85			; calculate ATN
	LD	A,H
	XOR	80H
	LD	H,A			; change sign
	LD	C,81H
	LD	DE,4910H		; float 1.571 (PI/2)
	JP	C76D7			; add floats

;	  Subroutine calculate ATN
;	     Inputs  ________________________
;	     Outputs ________________________

C7A85:	LD	IX,I7A8C		; ATN table
	JP	C7B88			; polynomial approximation odd series

I7A8C:	DEFB	9
	DEFB	078H,03BH,0D7H		; float  0.002866
	DEFB	07BH,084H,06EH		; float -0.01617
	DEFB	07CH,02FH,0C2H		; float  0.04291
	DEFB	07DH,09AH,031H		; float -0.07529
	DEFB	07DH,05AH,03EH		; float  0.1066
	DEFB	07EH,091H,080H		; float -0.1421
	DEFB	07EH,04CH,0BCH		; float  0.1999
	DEFB	07FH,0AAH,0AAH		; float -0.3333
	DEFB	081H,000H,000H		; float  1.0

;	  Subroutine EXP handler
;	     Inputs  ________________________
;	     Outputs ________________________

J7AA8:	LD	C,81H
	LD	DE,38AAH		; float 1.443
	CALL	C7748			; multipy floats
	LD	A,B
	CP	88H			; > float 128 ?
	JR	NC,J7AE1		; yep,
	CP	68H			; < float -0.0000000298
	JP	C,C7924			; yep, uit with 1.0
	PUSH	HL
	PUSH	BC
	CALL	C7999			; INT handler
	PUSH	HL
	PUSH	BC
	CALL	C7901			; convert float to integer
	LD	A,L
	ADD	A,81H
	POP	HL
	POP	DE
	POP	BC
	LD	C,H
	POP	HL
	JR	Z,J7AE1
	PUSH	AF
	CALL	C76D3			; subtract floats
	LD	IX,I7AEB
	CALL	C7B99			; polynomial approximation even series
	POP	AF
	LD	C,A
	LD	DE,0
	JP	C7748			; multipy floats

J7AE1:	BIT	7,H
	LD	B,0			; float 0.0
	RET	NZ
	DEC	B
	LD	HL,7FFFH		; float 1.701E+38 (max float)
	RET

I7AEB:	DEFB	7
	DEFB	074H,059H,088H		; float 0.0002075
	DEFB	077H,026H,098H		; float 0.001271
	DEFB	07AH,01EH,01EH		; float 0.009651
	DEFB	07CH,063H,050H		; float 0.0555
	DEFB	07EH,075H,0FEH		; float 0.2402
	DEFB	080H,031H,072H		; float 0.6932
	DEFB	081H,000H,000H		; float 1.0

;	  Subroutine LOG handler
;	     Inputs  B:HL = float
;	     Outputs ________________________

C7B01:	BIT	7,H			; sign negative ?
	RET	NZ			; yep, quit (error)
	LD	A,B
	AND	A			; float 0.0 ?
	RET	Z			; yep, quit (error)
	LD	C,B
	LD	D,H
	LD	E,L			; C:DE = float
	LD	A,80H
	LD	B,A
	XOR	C
	PUSH	AF
	PUSH	HL
	PUSH	BC
	LD	IX,I7B46
	CALL	C7B99			; polynomial approximation even series
	POP	AF
	POP	DE
	PUSH	HL
	PUSH	BC
	LD	B,A
	EX	DE,HL
	LD	IX,I7B53
	CALL	C7B99			; polynomial approximation even series
	LD	C,B
	EX	DE,HL
	POP	AF
	LD	B,A
	POP	HL
	CALL	C782C			; divide floats
	POP	AF
	PUSH	HL
	PUSH	BC
	RLCA
	RRCA
	LD	L,A
	SBC	A,A
	LD	H,A
	CALL	C78DF			; convert integer to float
	POP	AF
	LD	C,A
	POP	DE
	CALL	C76D7			; add floats
	LD	C,80H
	LD	DE,3172H		; float 0.6932
	JP	C7748			; multipy floats and quit

I7B46:	DEFB	4
	DEFB	083H,019H,0F8H		; float  4.812
	DEFB	083H,043H,063H		; float  6.106
	DEFB	084H,08DH,0CDH		; float -8.863
	DEFB	082H,083H,080H		; float -4.109
	
I7B53:	DEFB	4
	DEFB	081H,000H,000H		; float 1.0
	DEFB	083H,04DH,0B1H		; float 6.428
	DEFB	083H,011H,072H		; float 4.545
	DEFB	07FH,035H,005H		; float 0.3536

;	  Subroutine SQR handler
;	     Inputs  ________________________
;	     Outputs ________________________

I7B60:	LD	A,B
	AND	A			; float 0.0 ?
	RET	Z			; yep, quit
	RES	7,H			; force positive
	RRA
	ADC	A,40H
	LD	C,A
	LD	D,H
	LD	E,L
	LD	A,3
J7B6D:	PUSH	AF
	PUSH	HL
	PUSH	BC
	PUSH	DE
	PUSH	BC
	CALL	C782C			; divide floats
	POP	DE
	LD	C,E
	POP	DE
	CALL	C76D7			; add floats
	DEC	B
	LD	C,B
	EX	DE,HL
	POP	AF
	LD	B,A
	POP	HL
	POP	AF
	DEC	A
	JR	NZ,J7B6D
	LD	B,C
	EX	DE,HL
	RET

;	  Subroutine polynomial approximation odd series
;	     Inputs  ________________________
;	     Outputs ________________________

C7B88:	PUSH	HL
	PUSH	BC			; save float
	LD	C,B
	LD	D,H
	LD	E,L			; C:DE = float
	CALL	C7748			; multipy floats
	CALL	C7B99			; polynomial approximation even series
	POP	AF
	LD	C,A
	POP	DE			; restore float in C:DE
	JP	C7748			; multipy floats

;	  Subroutine polynomial approximation even series
;	     Inputs  B:HL = float, IX = pointer to serie of floats
;	     Outputs ________________________
; X*N1+N2

C7B99:	LD	A,(IX+0)		; number of items in serie
	INC	IX
	PUSH	AF			; save number of items in serie
	PUSH	HL
	PUSH	BC			; save float
	LD	B,(IX+0)
	LD	H,(IX+1)
	LD	L,(IX+2)		; B:HL = first float of serie
	INC	IX
	INC	IX
	INC	IX			; update pointer to next float in serie
J7BB0:	POP	AF
	LD	C,A
	POP	DE			; restore float in C:DE
	POP	AF			; restore number of items in serie
	DEC	A			; more items in serie ?
	RET	Z			; nope, quit
	PUSH	AF			; save number of items in serie
	PUSH	DE
	LD	A,C
	PUSH	AF			; save float in C:DE
	CALL	C7748			; multipy floats
	LD	C,(IX+0)
	LD	D,(IX+1)
	LD	E,(IX+2)
	CALL	C76D7			; add floats
	INC	IX
	INC	IX
	INC	IX			; update pointer to next float in serie
	JR	J7BB0			; next

;	  Subroutine integer to text
;	     Inputs  ________________________
;	     Outputs ________________________

C7BD1:	LD	IX,FBUFFR+1
	BIT	7,H			; postive integer ?
	LD	A," "
	JR	Z,J7BE6			; yep, use space as first character
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A			; negate
	JP	M,J7BF9			; still negative (was -32768), -32768 string and quit
	LD	A,"-"			; - as first character 
J7BE6:	LD	(IX+0),A
	INC	IX
	CALL	C7C0E			; generate string from integer
J7BEE:	PUSH	IX
	POP	HL
	LD	A,L
	SUB	LOW (FBUFFR+1)		; calculate string length
	LD	HL,FBUFFR+0
	LD	(HL),A			; string length
	RET

J7BF9:	LD	DE,FBUFFR+6
	LD	HL,I7C07+6
	LD	BC,7
	LDDR
	INC	DE
	EX	DE,HL
	RET

I7C07:	DEFB	6
	DEFB	"-32768"

;	  Subroutine generate string from integer
;	     Inputs  ________________________
;	     Outputs ________________________

C7C0E:	INC	H
	DEC	H
	JR	NZ,J7C17
	LD	A,L
	CP	9+1
	JR	C,J7C22
J7C17:	LD	DE,10
	CALL	C7643			; / 10
	PUSH	DE
	CALL	C7C0E
	POP	HL
J7C22:	LD	A,L
	ADD	A,"0"
	LD	(IX+0),A
	INC	IX
	RET

;	  Subroutine float to text
;	     Inputs  ________________________
;	     Outputs ________________________

C7C2B:	LD	IX,FBUFFR+1
	CALL	C7C42			; generate string from float
	JP	J7BEE			; set string length and quit

J7C35:	LD	(IX+0)," "
	INC	IX
	LD	(IX+0),"0"
	INC	IX
	RET

;	  Subroutine generate string from float
;	     Inputs  ________________________
;	     Outputs ________________________

C7C42:	LD	A,B
	AND	A			; float 0.0 ?
	JR	Z,J7C35			; yep, string 0 and quit
	BIT	7,H			; positive float ?
	LD	A," "
	JR	Z,J7C50			; yep, use space as first character
	RES	7,H			; negate
	LD	A,"-"			; use - as first character
J7C50:	LD	(IX+0),A
	INC	IX
	XOR	A
J7C56:	PUSH	AF
	LD	C,8AH
	LD	DE,79FCH		; float 1000
	CALL	C7966			; compare floats
	JR	NC,J7C6D		; > 1000,
	LD	C,84H
	LD	DE,2000H		; float 10
	CALL	C7748			; multipy floats
	POP	AF
	DEC	A
	JR	J7C56

J7C6D:	LD	C,8EH
	LD	DE,1C3EH		; float 10000
	CALL	C7966			; compare floats
	JR	C,J7C83			; < 10000,
	LD	C,84H
	LD	DE,2000H		; float 10
	CALL	C782C			; divide floats
	POP	AF
	INC	A
	JR	J7C56

J7C83:	LD	C,80H
	LD	DE,0			; float 0.5
	CALL	C76D7			; add floats
	CALL	C7901			; convert float to integer
	POP	AF
	ADD	A,5
	CP	6
	JR	NC,J7CE3
	DEC	A
	JP	P,C7CA7			; convert integer to digits
	LD	(IX+0),"."
	INC	IX
	LD	(IX+0),"0"
	INC	IX
	LD	A,0FFH			; force remainer check

;	  Subroutine convert integer to digits
;	     Inputs  HL = integer, A = flag
;	     Outputs ________________________

C7CA7:	LD	B,A
	LD	DE,1000
	CALL	C7CC0			; divide and add digit
	RET	NC			; remainer = 0, quit
	LD	DE,100
	CALL	C7CC0			; divide and add digit
	RET	NC			; remainer = 0, quit
	LD	DE,10
	CALL	C7CC0			; divide and add digit
	RET	NC			; remainer = 0, quit
	LD	DE,1

;	  Subroutine divide and add digit
;	     Inputs  HL = integer, DE = divider
;	     Outputs ________________________

C7CC0:	INC	B
	DJNZ	J7CCB			; B<>0, skip
	LD	(IX+0),"."
	INC	IX
	LD	B,0FFH			; force remainer check
J7CCB:	LD	A,"0"-1
J7CCD:	INC	A
	AND	A
	SBC	HL,DE
	JR	NC,J7CCD		; again
	ADD	HL,DE
	LD	(IX+0),A		; add digit
	INC	IX
	DEC	B			; B=1 ?
	JR	Z,J7CDE			; yep,
	SCF
	RET	P			; b7=0, quit with Cx set
J7CDE:	LD	A,L
	OR	H			; integer left = 0 ?
	RET	Z			; yep, quit with Cx reset, Zx set
	SCF				; quit with Cx set
	RET

J7CE3:	PUSH	AF
	LD	A,1			; force 1 digit
	CALL	C7CA7			; convert integer to digits
	LD	(IX+0),"E"
	INC	IX
	POP	AF
	SUB	2
	LD	L,A
	LD	A,"+"
	JP	P,J7CFE
	LD	A,L
	NEG
	LD	L,A
	LD	A,"-"
J7CFE:	LD	(IX+0),A
	INC	IX
	LD	A,L
	LD	B,"0"-1
J7D06:	INC	B
	SUB	10
	JR	NC,J7D06
	ADD	A,'0'+10
	LD	(IX+0),B
	INC	IX
	LD	(IX+0),A
	INC	IX
	RET

;	  Subroutine convert numeric string to float
;	     Inputs  ________________________
;	     Outputs ________________________

C7D18:	LD	B,0
	CALL	C7D34			; skip spaces
	CP	"-"
	JR	NZ,J7D28
	INC	DE
	CALL	C7D18			; convert numeric string to float
	JP	J79F7			; change sign and quit

J7D28:	CP	"&"
	JR	NZ,J7D8D		; nope, convert numeric string
	CALL	C7D3B			; convert &B,&O,&H string
	PUSH	DE
	CALL	C78DF			; convert integer to float
	POP	DE

;	  Subroutine skip spaces
;	     Inputs  ________________________
;	     Outputs ________________________

C7D34:	LD	A,(DE)
	CP	" "
	RET	NZ
	INC	DE
	JR	C7D34

;	  Subroutine convert &B,&O,&H string
;	     Inputs  ________________________
;	     Outputs ________________________

C7D3B:	LD	HL,0
	INC	DE
	CALL	C7E38		; get character and to upper
	INC	DE
	CP	"B"
	JR	Z,J7D7E
	CP	"O"
	JR	Z,J7D6D
	CP	"H"
	DEC	DE
	RET	NZ

; convert &H

	INC	DE
J7D50:	CALL	C7E38		; get character and to upper
	AND	A
	RET	Z
	SUB	"0"
	RET	C
	CP	9+1
	JR	C,J7D64
	CP	11H
	RET	C
	CP	17H
	RET	NC
	SUB	07H
J7D64:	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	A,L
	LD	L,A
	INC	DE
	JR	J7D50

; convert &O

J7D6D:	LD	A,(DE)
	AND	A
	RET	Z
	SUB	"0"
	RET	C
	CP	7+1
	RET	NC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	A,L
	LD	L,A
	INC	DE
	JR	J7D6D

; convert &B

J7D7E:	LD	A,(DE)
	AND	A
	RET	Z
	SUB	"0"
	RET	C
	CP	1+1
	RET	NC
	ADD	HL,HL
	ADD	A,L
	LD	L,A
	INC	DE
	JR	J7D7E

; convert numeric string

J7D8D:	LD	C,1
	DEC	DE
J7D90:	INC	DE
	CALL	C7D34			; skip spaces
	CP	"0"
	JR	C,J7DC4
	CP	"9"+1
	JR	NC,J7DC4
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	C,84H
	LD	DE,2000H		; float 10
	CALL	C7748			; multipy floats
	POP	AF
	SUB	"0"
	JR	Z,J7DBB
	LD	C,88H
J7DAE:	DEC	C
	ADD	A,A
	JP	P,J7DAE
	AND	7FH
	LD	D,A
	LD	E,0
	CALL	C76D7			; add floats
J7DBB:	POP	DE
	LD	C,E
	POP	DE
	DEC	C
	JR	NZ,J7D90
	INC	C
	JR	J7D90

J7DC4:	CP	"."
	JR	NZ,J7DCC
	DEC	C
	JR	Z,J7D90
	RET

J7DCC:	DEC	C
	JR	Z,J7DD0
	INC	C
J7DD0:	CALL	C7E39			; to upper
	CP	"E"			; exponent indicator ?
	JR	Z,J7DDB			; yep,
	CP	"D"			; exponent indicator (double real) ?
	JR	NZ,J7DF5		; nope, skip exponent
J7DDB:	INC	DE
	CALL	C7D34			; skip spaces
	CP	"+"
	JR	Z,J7DEF
	CP	"-"
	JR	NZ,J7DF0
	INC	DE			; to next character
	CALL	C7E1C			; get exponent
	NEG				; negate
	JR	J7DF3

J7DEF:	INC	DE			; to next character
J7DF0:	CALL	C7E1C			; get exponent
J7DF3:	ADD	A,C
	LD	C,A
J7DF5:	LD	A,C
	AND	A			;
	RET	Z
	PUSH	DE
	PUSH	AF
	JP	P,J7DFF
	NEG
J7DFF:	LD	E,A
	LD	D,0
	PUSH	HL
	PUSH	BC
	LD	B,84H
	LD	HL,2000H		; float 10.0
	CALL	C7878			; ^ handler
	LD	C,B
	EX	DE,HL
	POP	AF
	LD	B,A
	POP	HL
	POP	AF
	PUSH	AF
	CALL	P,C7748			; multipy floats
	POP	AF
	CALL	M,C782C			; divide floats
	POP	DE
	RET

;	  Subroutine get exponent
;	     Inputs  ________________________
;	     Outputs ________________________

C7E1C:	PUSH	HL
	LD	L,0
J7E1F:	CALL	C7D34			; skip spaces
	CP	"9"+1
	JR	NC,J7E35
	SUB	"0"
	JR	C,J7E35
	LD	H,A
	LD	A,L
	ADD	A,A
	ADD	A,A
	ADD	A,L
	ADD	A,A			; *10
	ADD	A,H
	LD	L,A
	INC	DE
	JR	J7E1F

J7E35:	LD	A,L
	POP	HL
	RET

;	  Subroutine get character and to upper
;	     Inputs  ________________________
;	     Outputs ________________________

C7E38:	LD	A,(DE)

;	  Subroutine to upper
;	     Inputs  ________________________
;	     Outputs ________________________

C7E39:	CP	"a"
	RET	C
	CP	"z"+1
	RET	NC
	AND	0DFH
	RET

;	  Subroutine left of string
;	     Inputs  ________________________
;	     Outputs ________________________

I7E42:	CP	(HL)
	JR	C,J7E46
	LD	A,(HL)
J7E46:	INC	HL
	JR	J7E70

;	  Subroutine right of string
;	     Inputs  ________________________
;	     Outputs ________________________

I7E49:	CP	(HL)
	JR	C,J7E4D
	LD	A,(HL)
J7E4D:	PUSH	AF
	LD	E,(HL)
	NEG
	ADD	A,E
	INC	A
	LD	E,A
	LD	D,0
	ADD	HL,DE
	POP	AF
	JR	J7E70

;	  Subroutine part of string
;	     Inputs  ________________________
;	     Outputs ________________________

C7E5A:	LD	C,B
	PUSH	AF
	ADD	A,C
	JR	C,J7E63
	DEC	A
	CP	(HL)
	JR	C,J7E6C
J7E63:	POP	AF
	LD	A,(HL)
	SUB	C
	JR	NC,J7E6A
	LD	A,0FFH
J7E6A:	INC	A
	PUSH	AF
J7E6C:	LD	B,0
	ADD	HL,BC
	POP	AF
J7E70:	LD	DE,BUF
	LD	(DE),A
	AND	A
	JR	Z,J7E7D
	INC	DE
	LD	C,A
	LD	B,0
	LDIR
J7E7D:	LD	HL,BUF
	RET

;	  Subroutine replace in string
;	     Inputs  ________________________
;	     Outputs ________________________

C7E81:	EX	DE,HL
	CP	(HL)
	JR	Z,J7E86
	RET	NC
J7E86:	LD	C,A
	LD	A,(DE)
	CP	B
	JR	NC,J7E8C
	LD	B,A
J7E8C:	LD	A,C
	DEC	A
	ADD	A,B
	JR	C,J7E96
	CP	(HL)
	JR	C,J7E9A
	JR	Z,J7E9A
J7E96:	LD	A,(HL)
	SUB	C
	INC	A
	LD	B,A
J7E9A:	LD	A,L
	ADD	A,C
	LD	L,A
	JR	NZ,J7EA0
	INC	H
J7EA0:	EX	DE,HL
	INC	HL
	LD	C,B
	LD	B,0
	LDIR
	RET

;	  Subroutine CHR$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

I7EA8:	LD	HL,BUF+1
	LD	(HL),A			; character
	DEC	HL
	LD	(HL),1			; string length = 1
	RET

;	  Subroutine VAL handler
;	     Inputs  ________________________
;	     Outputs ________________________

C7EB0:	LD	DE,BUF+1
	PUSH	DE
	LD	A,(HL)
	AND	A			; string length
	JR	Z,J7EBE			; empty string,
	LD	C,A
	XOR	A
	LD	B,A			; string length
	INC	HL
	LDIR				; copy string to BUF+1
J7EBE:	LD	(DE),A			; string end marker
	POP	DE
	JP	C7D18			; convert numeric string to float

;	  Subroutine HEX$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

I7EC3:	LD	C,4
	DEFB	011H

;	  Subroutine OCT$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

I7EC6:	LD	C,3
	DEFB	011H

;	  Subroutine BIN$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

I7EC9:	LD	C,1
	LD	DE,FBUFFR+16
J7ECE:	LD	B,C
	XOR	A
J7ED0:	SRL	H
	RR	L
	RRA
	DJNZ	J7ED0
	LD	B,C
J7ED8:	RLCA
	DJNZ	J7ED8
	CP	9+1
	JR	C,J7EE1
	ADD	A,7
J7EE1:	ADD	A,"0"
	LD	(DE),A
	DEC	DE
	LD	A,L
	OR	H
	JR	NZ,J7ECE
	LD	A,0D5H
	SUB	E
	LD	(DE),A
	EX	DE,HL
	RET

;	  Subroutine SPACE$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

I7EEF:	LD	B,A
	LD	A," "

;	  Subroutine STRING$ handler
;	     Inputs  B = number of characters, A = character
;	     Outputs ________________________

C7EF2:	LD	HL,BUF
	LD	(HL),B			; string length
	INC	B
	DEC	B			; length = 0 ?
	RET	Z			; yep, quit
	PUSH	HL
	INC	HL
J7EFB:	LD	(HL),A			; character
	INC	HL
	DJNZ	J7EFB
	POP	HL
	RET

;	  Subroutine INKEY$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

C7F01:	CALL	CHSNS			; key in buffer ?
	LD	HL,BUF
	LD	A,0
	JR	Z,J7F13			; nope, quit with empty string
	CALL	CHGET			; get key from buffer
	INC	HL
	LD	(HL),A			; character (key)
	DEC	HL
	LD	A,1			; string length = 1
J7F13:	LD	(HL),A
	RET

;	  Subroutine INSTR handler
;	     Inputs  ________________________
;	     Outputs ________________________

C7F15:	LD	C,A
	LD	A,(DE)
	SUB	C
	SUB	(HL)
	ADD	A,2
	LD	B,A
	LD	A,C
	DEC	A
	ADD	A,E
	LD	E,A
	JR	NC,J7F23
	INC	D
J7F23:	PUSH	BC
	PUSH	HL
	LD	B,(HL)
	INC	HL
	INC	DE
	PUSH	DE
J7F29:	LD	A,(DE)
	CP	(HL)
	JR	NZ,J7F37
	INC	DE
	INC	HL
	DJNZ	J7F29
	POP	AF
	POP	AF
	POP	AF
	LD	L,C
	LD	H,B
	RET

J7F37:	POP	DE
	POP	HL
	POP	BC
	INC	C
	DJNZ	J7F23
	LD	L,B
	LD	H,B
	RET

;	  Subroutine copy string to NULBUF
;	     Inputs  HL = pointer to string
;	     Outputs ________________________

C7F40:	LD	DE,(NULBUF)
	LD	C,(HL)			; size of string
	LD	B,0
	INC	BC			; include size byte
	LDIR
	RET

;	  Subroutine string1 > string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C7F4B:	CALL	C7F7B			; compare strings
	LD	HL,0
	RET	C			; smaller, return false
	RET	Z			; equal, return false
	DEC	HL			; bigger, return true
	RET

;	  Subroutine string1 = string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C7F55:	CALL	C7F74			; compare strings, assume true
	RET	Z			; equal, return true
	INC	HL			; not equal, return false
	RET

;	  Subroutine string1 >= string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C7F5B:	CALL	C7F74			; compare strings, assume true
	RET	NC			; bigger or equal, return true
	INC	HL			; smaller, return false
	RET

;	  Subroutine string1 < string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C7F61:	CALL	C7F74			; compare strings, assume true
	RET	C			; smaller, return true
	INC	HL			; bigger or equal, return false
	RET

;	  Subroutine string1 <> string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C7F67:	CALL	C7F74			; compare strings, assume true
	RET	NZ			; not equal, return true
	INC	HL			; equal, return false
	RET

;	  Subroutine string1 <= string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C7F6D:	CALL	C7F74			; compare strings, assume true
	RET	C			; smaller, return true
	RET	Z			; equal, return true
	INC	HL			; bigger, return false
	RET

;	  Subroutine compare strings, assume true
;	     Inputs  ________________________
;	     Outputs ________________________

C7F74:	CALL	C7F7B			; compare strings

;	  Subroutine string1 <=> string2
;	     Inputs  ________________________
;	     Outputs ________________________

C7F77:	LD	HL,-1			; return true
	RET

;	  Subroutine compare strings
;	     Inputs  NULBUF = first string, HL = second string
;	     Outputs ________________________

C7F7B:	LD	B,(HL)			; size second string
	INC	HL
	LD	DE,(NULBUF)
	LD	A,(DE)
	LD	C,A			; size first string
	INC	DE
J7F84:	LD	A,C
	OR	B			; at the end of both strings ?
	RET	Z			; yep, quit with Zx set
	LD	A,C
	SUB	1			; at the end of first string ?
	RET	C			; yep, quit with Cx set, Zx reset
	LD	A,B
	SUB	1			; at the end of second string
	CCF
	RET	NC			; yep, quit with Cx reset, Zx reset
	DEC	B
	DEC	C
	LD	A,(DE)
	CP	(HL)			; compare character
	INC	DE
	INC	HL
	JR	Z,J7F84			; equal, next character
	RET

;	  Subroutine concat strings
;	     Inputs  NULBUF = string1, HL = string2
;	     Outputs BUF = result string

C7F99:	LD	DE,BUF
	LD	BC,(NULBUF)
	AND	A
	PUSH	HL
	SBC	HL,DE			; string2 in BUF ?
	POP	HL
	JR	Z,J7FD2			; yep,
	LD	A,(BC)			; size of string1
	ADD	A,(HL)			; size of string2
	JR	NC,J7FAD
	LD	A,255			; concat string to 255 characters
J7FAD:	LD	(DE),A			; result string size
	INC	DE
	PUSH	HL
	LD	A,(BC)			; size of string1
	PUSH	AF
	AND	A			; empty string1 ?
	JR	Z,J7FBD			; yep, skip copy string1
	INC	BC
	LD	L,C
	LD	H,B
	LD	C,A
	LD	B,0
	LDIR				; copy string1
J7FBD:	POP	AF			; size of string1
	POP	HL			; string2
	LD	B,A
	LD	A,(HL)			; size string2
	JR	NC,J7FC5		; string2 not limited
	LD	A,B
J7FC4:	CPL
J7FC5:	AND	A			; empty string2 ?
	JR	Z,J7FCE			; yep, skip copy string2
	INC	HL
	LD	C,A
	LD	B,0
	LDIR				; copy string2
J7FCE:	LD	HL,BUF			; string in BUF
	RET

J7FD2:	PUSH	BC
	PUSH	HL
	LD	E,C
	LD	D,B
	LD	A,(DE)
	CP	(HL)
	JR	NC,J7FDB
	LD	A,(HL)
J7FDB:	LD	B,A
	INC	B
J7FDD:	LD	C,(HL)
	LD	A,(DE)
	LD	(HL),A
	LD	A,C
	LD	(DE),A
	INC	DE
	INC	HL
	DJNZ	J7FDD
	POP	BC
	LD	A,(BC)
	LD	L,A
	LD	H,0
	INC	HL
	ADD	HL,BC
	EX	DE,HL
	POP	HL
	ADD	A,(HL)
	JR	C,J7FF6
	LD	(BC),A
	LD	A,(HL)
	JR	J7FC5

J7FF6:	LD	A,(BC)
	PUSH	AF
	LD	A,0FFH
	LD	(BC),A
	POP	AF
	JR	J7FC4

	DEFS	08000H-$,0FFH

	END
