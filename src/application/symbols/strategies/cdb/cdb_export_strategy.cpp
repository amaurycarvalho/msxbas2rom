/***
 * @file cdb_export_strategy.cpp
 * @brief CDB (*.cdb) dummy export strategy implementation
 * @author Amaury Carvalho (2019-2026)
 * @note
 */

#include "cdb_export_strategy.h"

bool CdbExportStrategy::save(SymbolManager* symbolManager, BuildOptions* opts) {
  FILE* file;
  CodeNode* codeItem;
  int i, t;
  char s[512];

  vector<CodeNode*>& codeList = symbolManager->codeList;
  vector<CodeNode*>& dataList = symbolManager->dataList;

  if ((file = fopen(opts->cdbFilename.c_str(), "w"))) {
    fprintf(file, "; CDB generated by msxbas2rom\n");
    fprintf(file, "; SDCC compatible BASIC symbols\n\n");

    // =====================================================
    // VARIABLES (dataList)
    // =====================================================
    t = dataList.size();

    for (i = 0; i < t; i++) {
      codeItem = dataList[i];
      if (!codeItem || !codeItem->debug) continue;

      const string& name = codeItem->name;
      int totalSize = codeItem->length;
      unsigned int addr = (codeItem->segm << 16) | codeItem->addr_within_segm;
      string descriptor = "";

      // -------- Determine variable type ----------

      if (codeItem->lexeme) {
        if (codeItem->lexeme->isArray) {
          if (codeItem->lexeme->x_size)
            descriptor += "DA" + to_string(codeItem->lexeme->x_size) + "d,";
          if (codeItem->lexeme->y_size)
            descriptor += "DA" + to_string(codeItem->lexeme->y_size) + "d,";
        }
        switch (codeItem->lexeme->subtype) {
          case Lexeme::subtype_numeric:
            descriptor += "SI:B";
            break;
          case Lexeme::subtype_single_decimal:
          case Lexeme::subtype_double_decimal:
            descriptor += "SF";
            break;
          case Lexeme::subtype_string:
          case Lexeme::subtype_basic_string:
            descriptor += "ST,SC:B,DA255d,SC:B";
            break;
          default:
            descriptor += "SC:B";
            break;
        }
      } else {
        descriptor = "SC:B";
      }

      // -------- S:G (definition) ----------
      snprintf(s, sizeof(s), "S:G$%s$0_0$0({%d}%s),G,0,0\n", name.c_str(),
               totalSize, descriptor.c_str());
      fwrite(s, 1, strlen(s), file);

      // -------- L:G (address binding) ----------
      if (opts->megaROM) {
        snprintf(s, sizeof(s), "L:G$%s$0_0$0:%06X\n", name.c_str(), addr);
      } else {
        snprintf(s, sizeof(s), "L:G$%s$0_0$0:%04X\n", name.c_str(),
                 codeItem->addr_within_segm);
      }
      fwrite(s, 1, strlen(s), file);
    }

    fprintf(file, "\n");

    // =====================================================
    // SOURCE LINE MAPPING (codeList)
    // =====================================================
    t = codeList.size();

    for (i = 0; i < t; i++) {
      codeItem = codeList[i];
      if (!codeItem || !codeItem->debug) continue;

      unsigned int addr = (codeItem->segm << 16) | codeItem->addr_within_segm;

      if (opts->megaROM) {
        snprintf(s, sizeof(s), "L:A$%s$%s$0_0$0:%06X\n",
                 opts->inputFilename.c_str(), codeItem->name.c_str(), addr);
      } else {
        snprintf(s, sizeof(s), "L:A$%s$%s$0_0$0:%04X\n",
                 opts->inputFilename.c_str(), codeItem->name.c_str(),
                 codeItem->addr_within_segm);
      }
      fwrite(s, 1, strlen(s), file);
    }

    fclose(file);
    return true;
  }

  return false;
}